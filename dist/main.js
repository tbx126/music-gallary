// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/ms/index.js":[function(require,module,exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],"node_modules/debug/src/common.js":[function(require,module,exports) {
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    var hash = 0;
    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      var self = debug;

      // Set `diff` timestamp
      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        var formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function () {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: function (v) {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }
    var i;
    var len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;
},{"ms":"node_modules/ms/index.js"}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"node_modules/debug/src/browser.js":[function(require,module,exports) {
var process = require("process");
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || function () {};

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  var r;
  try {
    r = exports.storage.getItem('debug');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = undefined;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = require('./common')(exports);
var {
  formatters: formatters
} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};
},{"./common":"node_modules/debug/src/common.js","process":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/peek-readable/lib/EndOfFileStream.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EndOfStreamError = exports.defaultMessages = void 0;
exports.defaultMessages = 'End-Of-Stream';
/**
 * Thrown on read operation of the end of file or stream has been reached
 */
var EndOfStreamError = /*#__PURE__*/function (_Error) {
  _inherits(EndOfStreamError, _Error);
  var _super = _createSuper(EndOfStreamError);
  function EndOfStreamError() {
    _classCallCheck(this, EndOfStreamError);
    return _super.call(this, exports.defaultMessages);
  }
  return _createClass(EndOfStreamError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.EndOfStreamError = EndOfStreamError;
},{}],"node_modules/peek-readable/lib/Deferred.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Deferred = void 0;
var Deferred = /*#__PURE__*/_createClass(function Deferred() {
  var _this = this;
  _classCallCheck(this, Deferred);
  this.resolve = function () {
    return null;
  };
  this.reject = function () {
    return null;
  };
  this.promise = new Promise(function (resolve, reject) {
    _this.reject = reject;
    _this.resolve = resolve;
  });
});
exports.Deferred = Deferred;
},{}],"node_modules/peek-readable/lib/StreamReader.js":[function(require,module,exports) {
var define;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamReader = exports.EndOfStreamError = void 0;
var EndOfFileStream_1 = require("./EndOfFileStream");
var Deferred_1 = require("./Deferred");
var EndOfFileStream_2 = require("./EndOfFileStream");
Object.defineProperty(exports, "EndOfStreamError", {
  enumerable: true,
  get: function get() {
    return EndOfFileStream_2.EndOfStreamError;
  }
});
var maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation
var StreamReader = /*#__PURE__*/function () {
  function StreamReader(s) {
    var _this = this;
    _classCallCheck(this, StreamReader);
    this.s = s;
    /**
     * Deferred used for postponed read request (as not data is yet available to read)
     */
    this.deferred = null;
    this.endOfStream = false;
    /**
     * Store peeked data
     * @type {Array}
     */
    this.peekQueue = [];
    if (!s.read || !s.once) {
      throw new Error('Expected an instance of stream.Readable');
    }
    this.s.once('end', function () {
      return _this.reject(new EndOfFileStream_1.EndOfStreamError());
    });
    this.s.once('error', function (err) {
      return _this.reject(err);
    });
    this.s.once('close', function () {
      return _this.reject(new Error('Stream closed'));
    });
  }
  /**
   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
   * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
   * @param offset - Offset target
   * @param length - Number of bytes to read
   * @returns Number of bytes peeked
   */
  _createClass(StreamReader, [{
    key: "peek",
    value: function () {
      var _peek = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(uint8Array, offset, length) {
        var bytesRead;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.read(uint8Array, offset, length);
            case 2:
              bytesRead = _context.sent;
              this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer
              return _context.abrupt("return", bytesRead);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function peek(_x, _x2, _x3) {
        return _peek.apply(this, arguments);
      }
      return peek;
    }()
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */
  }, {
    key: "read",
    value: function () {
      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(buffer, offset, length) {
        var remaining, bytesRead, peekData, lenCopy, reqLen, chunkLen;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(length === 0)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return", 0);
            case 2:
              if (!(this.peekQueue.length === 0 && this.endOfStream)) {
                _context2.next = 4;
                break;
              }
              throw new EndOfFileStream_1.EndOfStreamError();
            case 4:
              remaining = length;
              bytesRead = 0; // consume peeked data first
            case 6:
              if (!(this.peekQueue.length > 0 && remaining > 0)) {
                _context2.next = 17;
                break;
              }
              peekData = this.peekQueue.pop(); // Front of queue
              if (peekData) {
                _context2.next = 10;
                break;
              }
              throw new Error('peekData should be defined');
            case 10:
              lenCopy = Math.min(peekData.length, remaining);
              buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
              bytesRead += lenCopy;
              remaining -= lenCopy;
              if (lenCopy < peekData.length) {
                // remainder back to queue
                this.peekQueue.push(peekData.subarray(lenCopy));
              }
              _context2.next = 6;
              break;
            case 17:
              if (!(remaining > 0 && !this.endOfStream)) {
                _context2.next = 28;
                break;
              }
              reqLen = Math.min(remaining, maxStreamReadSize);
              _context2.next = 21;
              return this.readFromStream(buffer, offset + bytesRead, reqLen);
            case 21:
              chunkLen = _context2.sent;
              bytesRead += chunkLen;
              if (!(chunkLen < reqLen)) {
                _context2.next = 25;
                break;
              }
              return _context2.abrupt("break", 28);
            case 25:
              remaining -= chunkLen;
              _context2.next = 17;
              break;
            case 28:
              return _context2.abrupt("return", bytesRead);
            case 29:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function read(_x4, _x5, _x6) {
        return _read.apply(this, arguments);
      }
      return read;
    }()
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */
  }, {
    key: "readFromStream",
    value: function () {
      var _readFromStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(buffer, offset, length) {
        var _this2 = this;
        var readBuffer, request;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              readBuffer = this.s.read(length);
              if (!readBuffer) {
                _context3.next = 6;
                break;
              }
              buffer.set(readBuffer, offset);
              return _context3.abrupt("return", readBuffer.length);
            case 6:
              request = {
                buffer: buffer,
                offset: offset,
                length: length,
                deferred: new Deferred_1.Deferred()
              };
              this.deferred = request.deferred;
              this.s.once('readable', function () {
                _this2.readDeferred(request);
              });
              return _context3.abrupt("return", request.deferred.promise);
            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function readFromStream(_x7, _x8, _x9) {
        return _readFromStream.apply(this, arguments);
      }
      return readFromStream;
    }()
    /**
     * Process deferred read request
     * @param request Deferred read request
     */
  }, {
    key: "readDeferred",
    value: function readDeferred(request) {
      var _this3 = this;
      var readBuffer = this.s.read(request.length);
      if (readBuffer) {
        request.buffer.set(readBuffer, request.offset);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once('readable', function () {
          _this3.readDeferred(request);
        });
      }
    }
  }, {
    key: "reject",
    value: function reject(err) {
      this.endOfStream = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
  }]);
  return StreamReader;
}();
exports.StreamReader = StreamReader;
},{"./EndOfFileStream":"node_modules/peek-readable/lib/EndOfFileStream.js","./Deferred":"node_modules/peek-readable/lib/Deferred.js"}],"node_modules/peek-readable/lib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamReader = exports.EndOfStreamError = void 0;
var EndOfFileStream_1 = require("./EndOfFileStream");
Object.defineProperty(exports, "EndOfStreamError", {
  enumerable: true,
  get: function get() {
    return EndOfFileStream_1.EndOfStreamError;
  }
});
var StreamReader_1 = require("./StreamReader");
Object.defineProperty(exports, "StreamReader", {
  enumerable: true,
  get: function get() {
    return StreamReader_1.StreamReader;
  }
});
},{"./EndOfFileStream":"node_modules/peek-readable/lib/EndOfFileStream.js","./StreamReader":"node_modules/peek-readable/lib/StreamReader.js"}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/base64-js/index.js","ieee754":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/ieee754/index.js","isarray":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/isarray/index.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/strtok3/lib/AbstractTokenizer.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractTokenizer = void 0;
var peek_readable_1 = require("peek-readable");
/**
 * Core tokenizer
 */
var AbstractTokenizer = /*#__PURE__*/function () {
  function AbstractTokenizer(fileInfo) {
    _classCallCheck(this, AbstractTokenizer);
    /**
     * Tokenizer-stream position
     */
    this.position = 0;
    this.numBuffer = new Uint8Array(8);
    this.fileInfo = fileInfo ? fileInfo : {};
  }
  /**
   * Read a token from the tokenizer-stream
   * @param token - The token to read
   * @param position - If provided, the desired position in the tokenizer-stream
   * @returns Promise with token data
   */
  _createClass(AbstractTokenizer, [{
    key: "readToken",
    value: function () {
      var _readToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(token) {
        var position,
          uint8Array,
          len,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              position = _args.length > 1 && _args[1] !== undefined ? _args[1] : this.position;
              uint8Array = Buffer.alloc(token.len);
              _context.next = 4;
              return this.readBuffer(uint8Array, {
                position: position
              });
            case 4:
              len = _context.sent;
              if (!(len < token.len)) {
                _context.next = 7;
                break;
              }
              throw new peek_readable_1.EndOfStreamError();
            case 7:
              return _context.abrupt("return", token.get(uint8Array, 0));
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function readToken(_x) {
        return _readToken.apply(this, arguments);
      }
      return readToken;
    }()
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */
  }, {
    key: "peekToken",
    value: function () {
      var _peekToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(token) {
        var position,
          uint8Array,
          len,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              position = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : this.position;
              uint8Array = Buffer.alloc(token.len);
              _context2.next = 4;
              return this.peekBuffer(uint8Array, {
                position: position
              });
            case 4:
              len = _context2.sent;
              if (!(len < token.len)) {
                _context2.next = 7;
                break;
              }
              throw new peek_readable_1.EndOfStreamError();
            case 7:
              return _context2.abrupt("return", token.get(uint8Array, 0));
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function peekToken(_x2) {
        return _peekToken.apply(this, arguments);
      }
      return peekToken;
    }()
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
  }, {
    key: "readNumber",
    value: function () {
      var _readNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(token) {
        var len;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.readBuffer(this.numBuffer, {
                length: token.len
              });
            case 2:
              len = _context3.sent;
              if (!(len < token.len)) {
                _context3.next = 5;
                break;
              }
              throw new peek_readable_1.EndOfStreamError();
            case 5:
              return _context3.abrupt("return", token.get(this.numBuffer, 0));
            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function readNumber(_x3) {
        return _readNumber.apply(this, arguments);
      }
      return readNumber;
    }()
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
  }, {
    key: "peekNumber",
    value: function () {
      var _peekNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(token) {
        var len;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.peekBuffer(this.numBuffer, {
                length: token.len
              });
            case 2:
              len = _context4.sent;
              if (!(len < token.len)) {
                _context4.next = 5;
                break;
              }
              throw new peek_readable_1.EndOfStreamError();
            case 5:
              return _context4.abrupt("return", token.get(this.numBuffer, 0));
            case 6:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function peekNumber(_x4) {
        return _peekNumber.apply(this, arguments);
      }
      return peekNumber;
    }()
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */
  }, {
    key: "ignore",
    value: function () {
      var _ignore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(length) {
        var bytesLeft;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!(this.fileInfo.size !== undefined)) {
                _context5.next = 5;
                break;
              }
              bytesLeft = this.fileInfo.size - this.position;
              if (!(length > bytesLeft)) {
                _context5.next = 5;
                break;
              }
              this.position += bytesLeft;
              return _context5.abrupt("return", bytesLeft);
            case 5:
              this.position += length;
              return _context5.abrupt("return", length);
            case 7:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function ignore(_x5) {
        return _ignore.apply(this, arguments);
      }
      return ignore;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      function close() {
        return _close.apply(this, arguments);
      }
      return close;
    }()
  }, {
    key: "normalizeOptions",
    value: function normalizeOptions(uint8Array, options) {
      if (options && options.position !== undefined && options.position < this.position) {
        throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
      }
      if (options) {
        return {
          mayBeLess: options.mayBeLess === true,
          offset: options.offset ? options.offset : 0,
          length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
          position: options.position ? options.position : this.position
        };
      }
      return {
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      };
    }
  }]);
  return AbstractTokenizer;
}();
exports.AbstractTokenizer = AbstractTokenizer;
},{"peek-readable":"node_modules/peek-readable/lib/index.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/strtok3/lib/ReadStreamTokenizer.js":[function(require,module,exports) {
var define;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReadStreamTokenizer = void 0;
var AbstractTokenizer_1 = require("./AbstractTokenizer");
var peek_readable_1 = require("peek-readable");
var maxBufferSize = 256000;
var ReadStreamTokenizer = /*#__PURE__*/function (_AbstractTokenizer_1$) {
  _inherits(ReadStreamTokenizer, _AbstractTokenizer_1$);
  var _super = _createSuper(ReadStreamTokenizer);
  function ReadStreamTokenizer(stream, fileInfo) {
    var _this;
    _classCallCheck(this, ReadStreamTokenizer);
    _this = _super.call(this, fileInfo);
    _this.streamReader = new peek_readable_1.StreamReader(stream);
    return _this;
  }
  /**
   * Get file information, an HTTP-client may implement this doing a HEAD request
   * @return Promise with file information
   */
  _createClass(ReadStreamTokenizer, [{
    key: "getFileInfo",
    value: function () {
      var _getFileInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.fileInfo);
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getFileInfo() {
        return _getFileInfo.apply(this, arguments);
      }
      return getFileInfo;
    }()
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */
  }, {
    key: "readBuffer",
    value: function () {
      var _readBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(uint8Array, options) {
        var normOptions, skipBytes, bytesRead;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              normOptions = this.normalizeOptions(uint8Array, options);
              skipBytes = normOptions.position - this.position;
              if (!(skipBytes > 0)) {
                _context2.next = 8;
                break;
              }
              _context2.next = 5;
              return this.ignore(skipBytes);
            case 5:
              return _context2.abrupt("return", this.readBuffer(uint8Array, options));
            case 8:
              if (!(skipBytes < 0)) {
                _context2.next = 10;
                break;
              }
              throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
            case 10:
              if (!(normOptions.length === 0)) {
                _context2.next = 12;
                break;
              }
              return _context2.abrupt("return", 0);
            case 12:
              _context2.next = 14;
              return this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
            case 14:
              bytesRead = _context2.sent;
              this.position += bytesRead;
              if (!((!options || !options.mayBeLess) && bytesRead < normOptions.length)) {
                _context2.next = 18;
                break;
              }
              throw new peek_readable_1.EndOfStreamError();
            case 18:
              return _context2.abrupt("return", bytesRead);
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function readBuffer(_x, _x2) {
        return _readBuffer.apply(this, arguments);
      }
      return readBuffer;
    }()
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */
  }, {
    key: "peekBuffer",
    value: function () {
      var _peekBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(uint8Array, options) {
        var normOptions, bytesRead, skipBytes, skipBuffer;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              normOptions = this.normalizeOptions(uint8Array, options);
              bytesRead = 0;
              if (!normOptions.position) {
                _context3.next = 15;
                break;
              }
              skipBytes = normOptions.position - this.position;
              if (!(skipBytes > 0)) {
                _context3.next = 13;
                break;
              }
              skipBuffer = new Uint8Array(normOptions.length + skipBytes);
              _context3.next = 8;
              return this.peekBuffer(skipBuffer, {
                mayBeLess: normOptions.mayBeLess
              });
            case 8:
              bytesRead = _context3.sent;
              uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
              return _context3.abrupt("return", bytesRead - skipBytes);
            case 13:
              if (!(skipBytes < 0)) {
                _context3.next = 15;
                break;
              }
              throw new Error('Cannot peek from a negative offset in a stream');
            case 15:
              if (!(normOptions.length > 0)) {
                _context3.next = 29;
                break;
              }
              _context3.prev = 16;
              _context3.next = 19;
              return this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
            case 19:
              bytesRead = _context3.sent;
              _context3.next = 27;
              break;
            case 22:
              _context3.prev = 22;
              _context3.t0 = _context3["catch"](16);
              if (!(options && options.mayBeLess && _context3.t0 instanceof peek_readable_1.EndOfStreamError)) {
                _context3.next = 26;
                break;
              }
              return _context3.abrupt("return", 0);
            case 26:
              throw _context3.t0;
            case 27:
              if (!(!normOptions.mayBeLess && bytesRead < normOptions.length)) {
                _context3.next = 29;
                break;
              }
              throw new peek_readable_1.EndOfStreamError();
            case 29:
              return _context3.abrupt("return", bytesRead);
            case 30:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[16, 22]]);
      }));
      function peekBuffer(_x3, _x4) {
        return _peekBuffer.apply(this, arguments);
      }
      return peekBuffer;
    }()
  }, {
    key: "ignore",
    value: function () {
      var _ignore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(length) {
        var bufSize, buf, totBytesRead, remaining, bytesRead;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              // debug(`ignore ${this.position}...${this.position + length - 1}`);
              bufSize = Math.min(maxBufferSize, length);
              buf = new Uint8Array(bufSize);
              totBytesRead = 0;
            case 3:
              if (!(totBytesRead < length)) {
                _context4.next = 13;
                break;
              }
              remaining = length - totBytesRead;
              _context4.next = 7;
              return this.readBuffer(buf, {
                length: Math.min(bufSize, remaining)
              });
            case 7:
              bytesRead = _context4.sent;
              if (!(bytesRead < 0)) {
                _context4.next = 10;
                break;
              }
              return _context4.abrupt("return", bytesRead);
            case 10:
              totBytesRead += bytesRead;
              _context4.next = 3;
              break;
            case 13:
              return _context4.abrupt("return", totBytesRead);
            case 14:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function ignore(_x5) {
        return _ignore.apply(this, arguments);
      }
      return ignore;
    }()
  }]);
  return ReadStreamTokenizer;
}(AbstractTokenizer_1.AbstractTokenizer);
exports.ReadStreamTokenizer = ReadStreamTokenizer;
},{"./AbstractTokenizer":"node_modules/strtok3/lib/AbstractTokenizer.js","peek-readable":"node_modules/peek-readable/lib/index.js"}],"node_modules/strtok3/lib/BufferTokenizer.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferTokenizer = void 0;
var peek_readable_1 = require("peek-readable");
var AbstractTokenizer_1 = require("./AbstractTokenizer");
var BufferTokenizer = /*#__PURE__*/function (_AbstractTokenizer_1$) {
  _inherits(BufferTokenizer, _AbstractTokenizer_1$);
  var _super = _createSuper(BufferTokenizer);
  /**
   * Construct BufferTokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param fileInfo - Pass additional file information to the tokenizer
   */
  function BufferTokenizer(uint8Array, fileInfo) {
    var _this;
    _classCallCheck(this, BufferTokenizer);
    _this = _super.call(this, fileInfo);
    _this.uint8Array = uint8Array;
    _this.fileInfo.size = _this.fileInfo.size ? _this.fileInfo.size : uint8Array.length;
    return _this;
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  _createClass(BufferTokenizer, [{
    key: "readBuffer",
    value: function () {
      var _readBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(uint8Array, options) {
        var bytesRead;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(options && options.position)) {
                _context.next = 4;
                break;
              }
              if (!(options.position < this.position)) {
                _context.next = 3;
                break;
              }
              throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
            case 3:
              this.position = options.position;
            case 4:
              _context.next = 6;
              return this.peekBuffer(uint8Array, options);
            case 6:
              bytesRead = _context.sent;
              this.position += bytesRead;
              return _context.abrupt("return", bytesRead);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function readBuffer(_x, _x2) {
        return _readBuffer.apply(this, arguments);
      }
      return readBuffer;
    }()
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
  }, {
    key: "peekBuffer",
    value: function () {
      var _peekBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(uint8Array, options) {
        var normOptions, bytes2read;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              normOptions = this.normalizeOptions(uint8Array, options);
              bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
              if (!(!normOptions.mayBeLess && bytes2read < normOptions.length)) {
                _context2.next = 6;
                break;
              }
              throw new peek_readable_1.EndOfStreamError();
            case 6:
              uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
              return _context2.abrupt("return", bytes2read);
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function peekBuffer(_x3, _x4) {
        return _peekBuffer.apply(this, arguments);
      }
      return peekBuffer;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function close() {
        return _close.apply(this, arguments);
      }
      return close;
    }()
  }]);
  return BufferTokenizer;
}(AbstractTokenizer_1.AbstractTokenizer);
exports.BufferTokenizer = BufferTokenizer;
},{"peek-readable":"node_modules/peek-readable/lib/index.js","./AbstractTokenizer":"node_modules/strtok3/lib/AbstractTokenizer.js"}],"node_modules/strtok3/lib/core.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromBuffer = exports.fromStream = exports.EndOfStreamError = void 0;
var ReadStreamTokenizer_1 = require("./ReadStreamTokenizer");
var BufferTokenizer_1 = require("./BufferTokenizer");
var peek_readable_1 = require("peek-readable");
Object.defineProperty(exports, "EndOfStreamError", {
  enumerable: true,
  get: function get() {
    return peek_readable_1.EndOfStreamError;
  }
});
/**
 * Construct ReadStreamTokenizer from given Stream.
 * Will set fileSize, if provided given Stream has set the .path property/
 * @param stream - Read from Node.js Stream.Readable
 * @param fileInfo - Pass the file information, like size and MIME-type of the corresponding stream.
 * @returns ReadStreamTokenizer
 */
function fromStream(stream, fileInfo) {
  fileInfo = fileInfo ? fileInfo : {};
  return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream, fileInfo);
}
exports.fromStream = fromStream;
/**
 * Construct ReadStreamTokenizer from given Buffer.
 * @param uint8Array - Uint8Array to tokenize
 * @param fileInfo - Pass additional file information to the tokenizer
 * @returns BufferTokenizer
 */
function fromBuffer(uint8Array, fileInfo) {
  return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
}
exports.fromBuffer = fromBuffer;
},{"./ReadStreamTokenizer":"node_modules/strtok3/lib/ReadStreamTokenizer.js","./BufferTokenizer":"node_modules/strtok3/lib/BufferTokenizer.js","peek-readable":"node_modules/peek-readable/lib/index.js"}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/token-types/lib/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = void 0;
var ieee754 = require("ieee754");
// Primitive types
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}
/**
 * 8-bit unsigned integer
 */
exports.UINT8 = {
  len: 1,
  get: function get(array, offset) {
    return dv(array).getUint8(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setUint8(offset, value);
    return offset + 1;
  }
};
/**
 * 16-bit unsigned integer, Little Endian byte order
 */
exports.UINT16_LE = {
  len: 2,
  get: function get(array, offset) {
    return dv(array).getUint16(offset, true);
  },
  put: function put(array, offset, value) {
    dv(array).setUint16(offset, value, true);
    return offset + 2;
  }
};
/**
 * 16-bit unsigned integer, Big Endian byte order
 */
exports.UINT16_BE = {
  len: 2,
  get: function get(array, offset) {
    return dv(array).getUint16(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setUint16(offset, value);
    return offset + 2;
  }
};
/**
 * 24-bit unsigned integer, Little Endian byte order
 */
exports.UINT24_LE = {
  len: 3,
  get: function get(array, offset) {
    var dataView = dv(array);
    return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
  },
  put: function put(array, offset, value) {
    var dataView = dv(array);
    dataView.setUint8(offset, value & 0xff);
    dataView.setUint16(offset + 1, value >> 8, true);
    return offset + 3;
  }
};
/**
 * 24-bit unsigned integer, Big Endian byte order
 */
exports.UINT24_BE = {
  len: 3,
  get: function get(array, offset) {
    var dataView = dv(array);
    return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
  },
  put: function put(array, offset, value) {
    var dataView = dv(array);
    dataView.setUint16(offset, value >> 8);
    dataView.setUint8(offset + 2, value & 0xff);
    return offset + 3;
  }
};
/**
 * 32-bit unsigned integer, Little Endian byte order
 */
exports.UINT32_LE = {
  len: 4,
  get: function get(array, offset) {
    return dv(array).getUint32(offset, true);
  },
  put: function put(array, offset, value) {
    dv(array).setUint32(offset, value, true);
    return offset + 4;
  }
};
/**
 * 32-bit unsigned integer, Big Endian byte order
 */
exports.UINT32_BE = {
  len: 4,
  get: function get(array, offset) {
    return dv(array).getUint32(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setUint32(offset, value);
    return offset + 4;
  }
};
/**
 * 8-bit signed integer
 */
exports.INT8 = {
  len: 1,
  get: function get(array, offset) {
    return dv(array).getInt8(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setInt8(offset, value);
    return offset + 1;
  }
};
/**
 * 16-bit signed integer, Big Endian byte order
 */
exports.INT16_BE = {
  len: 2,
  get: function get(array, offset) {
    return dv(array).getInt16(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setInt16(offset, value);
    return offset + 2;
  }
};
/**
 * 16-bit signed integer, Little Endian byte order
 */
exports.INT16_LE = {
  len: 2,
  get: function get(array, offset) {
    return dv(array).getInt16(offset, true);
  },
  put: function put(array, offset, value) {
    dv(array).setInt16(offset, value, true);
    return offset + 2;
  }
};
/**
 * 24-bit signed integer, Little Endian byte order
 */
exports.INT24_LE = {
  len: 3,
  get: function get(array, offset) {
    var unsigned = exports.UINT24_LE.get(array, offset);
    return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
  },
  put: function put(array, offset, value) {
    var dataView = dv(array);
    dataView.setUint8(offset, value & 0xff);
    dataView.setUint16(offset + 1, value >> 8, true);
    return offset + 3;
  }
};
/**
 * 24-bit signed integer, Big Endian byte order
 */
exports.INT24_BE = {
  len: 3,
  get: function get(array, offset) {
    var unsigned = exports.UINT24_BE.get(array, offset);
    return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
  },
  put: function put(array, offset, value) {
    var dataView = dv(array);
    dataView.setUint16(offset, value >> 8);
    dataView.setUint8(offset + 2, value & 0xff);
    return offset + 3;
  }
};
/**
 * 32-bit signed integer, Big Endian byte order
 */
exports.INT32_BE = {
  len: 4,
  get: function get(array, offset) {
    return dv(array).getInt32(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setInt32(offset, value);
    return offset + 4;
  }
};
/**
 * 32-bit signed integer, Big Endian byte order
 */
exports.INT32_LE = {
  len: 4,
  get: function get(array, offset) {
    return dv(array).getInt32(offset, true);
  },
  put: function put(array, offset, value) {
    dv(array).setInt32(offset, value, true);
    return offset + 4;
  }
};
/**
 * 64-bit unsigned integer, Little Endian byte order
 */
exports.UINT64_LE = {
  len: 8,
  get: function get(array, offset) {
    return dv(array).getBigUint64(offset, true);
  },
  put: function put(array, offset, value) {
    dv(array).setBigUint64(offset, value, true);
    return offset + 8;
  }
};
/**
 * 64-bit signed integer, Little Endian byte order
 */
exports.INT64_LE = {
  len: 8,
  get: function get(array, offset) {
    return dv(array).getBigInt64(offset, true);
  },
  put: function put(array, offset, value) {
    dv(array).setBigInt64(offset, value, true);
    return offset + 8;
  }
};
/**
 * 64-bit unsigned integer, Big Endian byte order
 */
exports.UINT64_BE = {
  len: 8,
  get: function get(array, offset) {
    return dv(array).getBigUint64(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setBigUint64(offset, value);
    return offset + 8;
  }
};
/**
 * 64-bit signed integer, Big Endian byte order
 */
exports.INT64_BE = {
  len: 8,
  get: function get(array, offset) {
    return dv(array).getBigInt64(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setBigInt64(offset, value);
    return offset + 8;
  }
};
/**
 * IEEE 754 16-bit (half precision) float, big endian
 */
exports.Float16_BE = {
  len: 2,
  get: function get(dataView, offset) {
    return ieee754.read(dataView, offset, false, 10, this.len);
  },
  put: function put(dataView, offset, value) {
    ieee754.write(dataView, value, offset, false, 10, this.len);
    return offset + this.len;
  }
};
/**
 * IEEE 754 16-bit (half precision) float, little endian
 */
exports.Float16_LE = {
  len: 2,
  get: function get(array, offset) {
    return ieee754.read(array, offset, true, 10, this.len);
  },
  put: function put(array, offset, value) {
    ieee754.write(array, value, offset, true, 10, this.len);
    return offset + this.len;
  }
};
/**
 * IEEE 754 32-bit (single precision) float, big endian
 */
exports.Float32_BE = {
  len: 4,
  get: function get(array, offset) {
    return dv(array).getFloat32(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setFloat32(offset, value);
    return offset + 4;
  }
};
/**
 * IEEE 754 32-bit (single precision) float, little endian
 */
exports.Float32_LE = {
  len: 4,
  get: function get(array, offset) {
    return dv(array).getFloat32(offset, true);
  },
  put: function put(array, offset, value) {
    dv(array).setFloat32(offset, value, true);
    return offset + 4;
  }
};
/**
 * IEEE 754 64-bit (double precision) float, big endian
 */
exports.Float64_BE = {
  len: 8,
  get: function get(array, offset) {
    return dv(array).getFloat64(offset);
  },
  put: function put(array, offset, value) {
    dv(array).setFloat64(offset, value);
    return offset + 8;
  }
};
/**
 * IEEE 754 64-bit (double precision) float, little endian
 */
exports.Float64_LE = {
  len: 8,
  get: function get(array, offset) {
    return dv(array).getFloat64(offset, true);
  },
  put: function put(array, offset, value) {
    dv(array).setFloat64(offset, value, true);
    return offset + 8;
  }
};
/**
 * IEEE 754 80-bit (extended precision) float, big endian
 */
exports.Float80_BE = {
  len: 10,
  get: function get(array, offset) {
    return ieee754.read(array, offset, false, 63, this.len);
  },
  put: function put(array, offset, value) {
    ieee754.write(array, value, offset, false, 63, this.len);
    return offset + this.len;
  }
};
/**
 * IEEE 754 80-bit (extended precision) float, little endian
 */
exports.Float80_LE = {
  len: 10,
  get: function get(array, offset) {
    return ieee754.read(array, offset, true, 63, this.len);
  },
  put: function put(array, offset, value) {
    ieee754.write(array, value, offset, true, 63, this.len);
    return offset + this.len;
  }
};
/**
 * Ignore a given number of bytes
 */
var IgnoreType = /*#__PURE__*/function () {
  /**
   * @param len number of bytes to ignore
   */
  function IgnoreType(len) {
    _classCallCheck(this, IgnoreType);
    this.len = len;
  }
  // ToDo: don't read, but skip data
  _createClass(IgnoreType, [{
    key: "get",
    value: function get(array, off) {}
  }]);
  return IgnoreType;
}();
exports.IgnoreType = IgnoreType;
var Uint8ArrayType = /*#__PURE__*/function () {
  function Uint8ArrayType(len) {
    _classCallCheck(this, Uint8ArrayType);
    this.len = len;
  }
  _createClass(Uint8ArrayType, [{
    key: "get",
    value: function get(array, offset) {
      return array.subarray(offset, offset + this.len);
    }
  }]);
  return Uint8ArrayType;
}();
exports.Uint8ArrayType = Uint8ArrayType;
var BufferType = /*#__PURE__*/function () {
  function BufferType(len) {
    _classCallCheck(this, BufferType);
    this.len = len;
  }
  _createClass(BufferType, [{
    key: "get",
    value: function get(uint8Array, off) {
      return Buffer.from(uint8Array.subarray(off, off + this.len));
    }
  }]);
  return BufferType;
}();
exports.BufferType = BufferType;
/**
 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
 */
var StringType = /*#__PURE__*/function () {
  function StringType(len, encoding) {
    _classCallCheck(this, StringType);
    this.len = len;
    this.encoding = encoding;
  }
  _createClass(StringType, [{
    key: "get",
    value: function get(uint8Array, offset) {
      return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
    }
  }]);
  return StringType;
}();
exports.StringType = StringType;
/**
 * ANSI Latin 1 String
 * Using windows-1252 / ISO 8859-1 decoding
 */
var AnsiStringType = /*#__PURE__*/function () {
  function AnsiStringType(len) {
    _classCallCheck(this, AnsiStringType);
    this.len = len;
  }
  _createClass(AnsiStringType, [{
    key: "get",
    value: function get(buffer) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return AnsiStringType.decode(buffer, offset, offset + this.len);
    }
  }], [{
    key: "decode",
    value: function decode(buffer, offset, until) {
      var str = '';
      for (var i = offset; i < until; ++i) {
        str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
      }
      return str;
    }
  }, {
    key: "inRange",
    value: function inRange(a, min, max) {
      return min <= a && a <= max;
    }
  }, {
    key: "codePointToString",
    value: function codePointToString(cp) {
      if (cp <= 0xFFFF) {
        return String.fromCharCode(cp);
      } else {
        cp -= 0x10000;
        return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
      }
    }
  }, {
    key: "singleByteDecoder",
    value: function singleByteDecoder(bite) {
      if (AnsiStringType.inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      var codePoint = AnsiStringType.windows1252[bite - 0x80];
      if (codePoint === null) {
        throw Error('invaliding encoding');
      }
      return codePoint;
    }
  }]);
  return AnsiStringType;
}();
exports.AnsiStringType = AnsiStringType;
AnsiStringType.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
},{"ieee754":"node_modules/ieee754/index.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/file-type/util.js":[function(require,module,exports) {
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
exports.stringToBytes = function (string) {
  return _toConsumableArray(string).map(function (character) {
    return character.charCodeAt(0);
  });
};

/**
Checks whether the TAR checksum is valid.

@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.
@param {number} offset - TAR header offset.
@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.
*/
exports.tarHeaderChecksumMatches = function (buffer) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\0.*$/, '').trim(), 8); // Read sum in header
  if (isNaN(readSum)) {
    return false;
  }
  var sum = 8 * 0x20; // Initialize signed bit sum

  for (var i = offset; i < offset + 148; i++) {
    sum += buffer[i];
  }
  for (var _i = offset + 156; _i < offset + 512; _i++) {
    sum += buffer[_i];
  }
  return readSum === sum;
};

/**
ID3 UINT32 sync-safe tokenizer token.
28 bits (representing up to 256MB) integer, the msb is 0 to avoid "false syncsignals".
*/
exports.uint32SyncSafeToken = {
  get: function get(buffer, offset) {
    return buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
  },
  len: 4
};
},{}],"node_modules/file-type/supported.js":[function(require,module,exports) {
'use strict';

module.exports = {
  extensions: ['jpg', 'png', 'apng', 'gif', 'webp', 'flif', 'xcf', 'cr2', 'cr3', 'orf', 'arw', 'dng', 'nef', 'rw2', 'raf', 'tif', 'bmp', 'icns', 'jxr', 'psd', 'indd', 'zip', 'tar', 'rar', 'gz', 'bz2', '7z', 'dmg', 'mp4', 'mid', 'mkv', 'webm', 'mov', 'avi', 'mpg', 'mp2', 'mp3', 'm4a', 'oga', 'ogg', 'ogv', 'opus', 'flac', 'wav', 'spx', 'amr', 'pdf', 'epub', 'exe', 'swf', 'rtf', 'wasm', 'woff', 'woff2', 'eot', 'ttf', 'otf', 'ico', 'flv', 'ps', 'xz', 'sqlite', 'nes', 'crx', 'xpi', 'cab', 'deb', 'ar', 'rpm', 'Z', 'lz', 'cfb', 'mxf', 'mts', 'blend', 'bpg', 'docx', 'pptx', 'xlsx', '3gp', '3g2', 'jp2', 'jpm', 'jpx', 'mj2', 'aif', 'qcp', 'odt', 'ods', 'odp', 'xml', 'mobi', 'heic', 'cur', 'ktx', 'ape', 'wv', 'dcm', 'ics', 'glb', 'pcap', 'dsf', 'lnk', 'alias', 'voc', 'ac3', 'm4v', 'm4p', 'm4b', 'f4v', 'f4p', 'f4b', 'f4a', 'mie', 'asf', 'ogm', 'ogx', 'mpc', 'arrow', 'shp', 'aac', 'mp1', 'it', 's3m', 'xm', 'ai', 'skp', 'avif', 'eps', 'lzh', 'pgp', 'asar', 'stl', 'chm', '3mf', 'zst', 'jxl', 'vcf'],
  mimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/flif', 'image/x-xcf', 'image/x-canon-cr2', 'image/x-canon-cr3', 'image/tiff', 'image/bmp', 'image/vnd.ms-photo', 'image/vnd.adobe.photoshop', 'application/x-indesign', 'application/epub+zip', 'application/x-xpinstall', 'application/vnd.oasis.opendocument.text', 'application/vnd.oasis.opendocument.spreadsheet', 'application/vnd.oasis.opendocument.presentation', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.openxmlformats-officedocument.presentationml.presentation', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/zip', 'application/x-tar', 'application/x-rar-compressed', 'application/gzip', 'application/x-bzip2', 'application/x-7z-compressed', 'application/x-apple-diskimage', 'application/x-apache-arrow', 'video/mp4', 'audio/midi', 'video/x-matroska', 'video/webm', 'video/quicktime', 'video/vnd.avi', 'audio/vnd.wave', 'audio/qcelp', 'audio/x-ms-asf', 'video/x-ms-asf', 'application/vnd.ms-asf', 'video/mpeg', 'video/3gpp', 'audio/mpeg', 'audio/mp4',
  // RFC 4337
  'audio/opus', 'video/ogg', 'audio/ogg', 'application/ogg', 'audio/x-flac', 'audio/ape', 'audio/wavpack', 'audio/amr', 'application/pdf', 'application/x-msdownload', 'application/x-shockwave-flash', 'application/rtf', 'application/wasm', 'font/woff', 'font/woff2', 'application/vnd.ms-fontobject', 'font/ttf', 'font/otf', 'image/x-icon', 'video/x-flv', 'application/postscript', 'application/eps', 'application/x-xz', 'application/x-sqlite3', 'application/x-nintendo-nes-rom', 'application/x-google-chrome-extension', 'application/vnd.ms-cab-compressed', 'application/x-deb', 'application/x-unix-archive', 'application/x-rpm', 'application/x-compress', 'application/x-lzip', 'application/x-cfb', 'application/x-mie', 'application/mxf', 'video/mp2t', 'application/x-blender', 'image/bpg', 'image/jp2', 'image/jpx', 'image/jpm', 'image/mj2', 'audio/aiff', 'application/xml', 'application/x-mobipocket-ebook', 'image/heif', 'image/heif-sequence', 'image/heic', 'image/heic-sequence', 'image/icns', 'image/ktx', 'application/dicom', 'audio/x-musepack', 'text/calendar', 'text/vcard', 'model/gltf-binary', 'application/vnd.tcpdump.pcap', 'audio/x-dsf',
  // Non-standard
  'application/x.ms.shortcut',
  // Invented by us
  'application/x.apple.alias',
  // Invented by us
  'audio/x-voc', 'audio/vnd.dolby.dd-raw', 'audio/x-m4a', 'image/apng', 'image/x-olympus-orf', 'image/x-sony-arw', 'image/x-adobe-dng', 'image/x-nikon-nef', 'image/x-panasonic-rw2', 'image/x-fujifilm-raf', 'video/x-m4v', 'video/3gpp2', 'application/x-esri-shape', 'audio/aac', 'audio/x-it', 'audio/x-s3m', 'audio/x-xm', 'video/MP1S', 'video/MP2P', 'application/vnd.sketchup.skp', 'image/avif', 'application/x-lzh-compressed', 'application/pgp-encrypted', 'application/x-asar', 'model/stl', 'application/vnd.ms-htmlhelp', 'model/3mf', 'image/jxl', 'application/zstd']
};
},{}],"node_modules/file-type/core.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var Token = require('token-types');
var strtok3 = require('strtok3/lib/core');
var _require = require('./util'),
  stringToBytes = _require.stringToBytes,
  tarHeaderChecksumMatches = _require.tarHeaderChecksumMatches,
  uint32SyncSafeToken = _require.uint32SyncSafeToken;
var supported = require('./supported');
var minimumBytes = 4100; // A fair amount of file-types are detectable within this range
function fromStream(_x) {
  return _fromStream.apply(this, arguments);
}
function _fromStream() {
  _fromStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(stream) {
    var tokenizer;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return strtok3.fromStream(stream);
        case 2:
          tokenizer = _context2.sent;
          _context2.prev = 3;
          _context2.next = 6;
          return fromTokenizer(tokenizer);
        case 6:
          return _context2.abrupt("return", _context2.sent);
        case 7:
          _context2.prev = 7;
          _context2.next = 10;
          return tokenizer.close();
        case 10:
          return _context2.finish(7);
        case 11:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[3,, 7, 11]]);
  }));
  return _fromStream.apply(this, arguments);
}
function fromBuffer(_x2) {
  return _fromBuffer.apply(this, arguments);
}
function _fromBuffer() {
  _fromBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(input) {
    var buffer, tokenizer;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          if (input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input)) {
            _context3.next = 2;
            break;
          }
          throw new TypeError("Expected the `input` argument to be of type `Uint8Array` or `Buffer` or `ArrayBuffer`, got `".concat(_typeof(input), "`"));
        case 2:
          buffer = input instanceof Buffer ? input : Buffer.from(input);
          if (buffer && buffer.length > 1) {
            _context3.next = 5;
            break;
          }
          return _context3.abrupt("return");
        case 5:
          tokenizer = strtok3.fromBuffer(buffer);
          return _context3.abrupt("return", fromTokenizer(tokenizer));
        case 7:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _fromBuffer.apply(this, arguments);
}
function _check(buffer, headers, options) {
  options = _objectSpread({
    offset: 0
  }, options);
  var _iterator = _createForOfIteratorHelper(headers.entries()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        index = _step$value[0],
        header = _step$value[1];
      // If a bitmask is set
      if (options.mask) {
        // If header doesn't equal `buf` with bits masked off
        if (header !== (options.mask[index] & buffer[index + options.offset])) {
          return false;
        }
      } else if (header !== buffer[index + options.offset]) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
}
function fromTokenizer(_x3) {
  return _fromTokenizer2.apply(this, arguments);
}
function _fromTokenizer2() {
  _fromTokenizer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tokenizer) {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;
          return _context4.abrupt("return", _fromTokenizer(tokenizer));
        case 4:
          _context4.prev = 4;
          _context4.t0 = _context4["catch"](0);
          if (_context4.t0 instanceof strtok3.EndOfStreamError) {
            _context4.next = 8;
            break;
          }
          throw _context4.t0;
        case 8:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[0, 4]]);
  }));
  return _fromTokenizer2.apply(this, arguments);
}
function _fromTokenizer(_x4) {
  return _fromTokenizer3.apply(this, arguments);
}
function _fromTokenizer3() {
  _fromTokenizer3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(tokenizer) {
    var buffer, bytesRead, check, checkString, id3HeaderLen, zipHeader, type, mimeType, nextHeaderIndex, _type, brandMajor, maxBufferSize, _buffer, readField, readElement, readChildren, re, docType, str, readChunkHeader, chunk, readHeader, header, payload, typeId, _type2, jsonSize, _header, json;
    return _regeneratorRuntime().wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          buffer = Buffer.alloc(minimumBytes);
          bytesRead = 12;
          check = function check(header, options) {
            return _check(buffer, header, options);
          };
          checkString = function checkString(header, options) {
            return check(stringToBytes(header), options);
          }; // Keep reading until EOF if the file size is unknown.
          if (!tokenizer.fileInfo.size) {
            tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
          }
          _context10.next = 7;
          return tokenizer.peekBuffer(buffer, {
            length: bytesRead,
            mayBeLess: true
          });
        case 7:
          if (!check([0x42, 0x4D])) {
            _context10.next = 9;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'bmp',
            mime: 'image/bmp'
          });
        case 9:
          if (!check([0x0B, 0x77])) {
            _context10.next = 11;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ac3',
            mime: 'audio/vnd.dolby.dd-raw'
          });
        case 11:
          if (!check([0x78, 0x01])) {
            _context10.next = 13;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'dmg',
            mime: 'application/x-apple-diskimage'
          });
        case 13:
          if (!check([0x4D, 0x5A])) {
            _context10.next = 15;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'exe',
            mime: 'application/x-msdownload'
          });
        case 15:
          if (!check([0x25, 0x21])) {
            _context10.next = 21;
            break;
          }
          _context10.next = 18;
          return tokenizer.peekBuffer(buffer, {
            length: 24,
            mayBeLess: true
          });
        case 18:
          if (!(checkString('PS-Adobe-', {
            offset: 2
          }) && checkString(' EPSF-', {
            offset: 14
          }))) {
            _context10.next = 20;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'eps',
            mime: 'application/eps'
          });
        case 20:
          return _context10.abrupt("return", {
            ext: 'ps',
            mime: 'application/postscript'
          });
        case 21:
          if (!(check([0x1F, 0xA0]) || check([0x1F, 0x9D]))) {
            _context10.next = 23;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'Z',
            mime: 'application/x-compress'
          });
        case 23:
          if (!check([0xFF, 0xD8, 0xFF])) {
            _context10.next = 25;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'jpg',
            mime: 'image/jpeg'
          });
        case 25:
          if (!check([0x49, 0x49, 0xBC])) {
            _context10.next = 27;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'jxr',
            mime: 'image/vnd.ms-photo'
          });
        case 27:
          if (!check([0x1F, 0x8B, 0x8])) {
            _context10.next = 29;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'gz',
            mime: 'application/gzip'
          });
        case 29:
          if (!check([0x42, 0x5A, 0x68])) {
            _context10.next = 31;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'bz2',
            mime: 'application/x-bzip2'
          });
        case 31:
          if (!checkString('ID3')) {
            _context10.next = 42;
            break;
          }
          _context10.next = 34;
          return tokenizer.ignore(6);
        case 34:
          _context10.next = 36;
          return tokenizer.readToken(uint32SyncSafeToken);
        case 36:
          id3HeaderLen = _context10.sent;
          if (!(tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size)) {
            _context10.next = 39;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mp3',
            mime: 'audio/mpeg'
          });
        case 39:
          _context10.next = 41;
          return tokenizer.ignore(id3HeaderLen);
        case 41:
          return _context10.abrupt("return", fromTokenizer(tokenizer));
        case 42:
          if (!checkString('MP+')) {
            _context10.next = 44;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mpc',
            mime: 'audio/x-musepack'
          });
        case 44:
          if (!((buffer[0] === 0x43 || buffer[0] === 0x46) && check([0x57, 0x53], {
            offset: 1
          }))) {
            _context10.next = 46;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'swf',
            mime: 'application/x-shockwave-flash'
          });
        case 46:
          if (!check([0x47, 0x49, 0x46])) {
            _context10.next = 48;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'gif',
            mime: 'image/gif'
          });
        case 48:
          if (!checkString('FLIF')) {
            _context10.next = 50;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'flif',
            mime: 'image/flif'
          });
        case 50:
          if (!checkString('8BPS')) {
            _context10.next = 52;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'psd',
            mime: 'image/vnd.adobe.photoshop'
          });
        case 52:
          if (!checkString('WEBP', {
            offset: 8
          })) {
            _context10.next = 54;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'webp',
            mime: 'image/webp'
          });
        case 54:
          if (!checkString('MPCK')) {
            _context10.next = 56;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mpc',
            mime: 'audio/x-musepack'
          });
        case 56:
          if (!checkString('FORM')) {
            _context10.next = 58;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'aif',
            mime: 'audio/aiff'
          });
        case 58:
          if (!checkString('icns', {
            offset: 0
          })) {
            _context10.next = 60;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'icns',
            mime: 'image/icns'
          });
        case 60:
          if (!check([0x50, 0x4B, 0x3, 0x4])) {
            _context10.next = 121;
            break;
          }
          _context10.prev = 61;
        case 62:
          if (!(tokenizer.position + 30 < tokenizer.fileInfo.size)) {
            _context10.next = 114;
            break;
          }
          _context10.next = 65;
          return tokenizer.readBuffer(buffer, {
            length: 30
          });
        case 65:
          // https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
          zipHeader = {
            compressedSize: buffer.readUInt32LE(18),
            uncompressedSize: buffer.readUInt32LE(22),
            filenameLength: buffer.readUInt16LE(26),
            extraFieldLength: buffer.readUInt16LE(28)
          };
          _context10.next = 68;
          return tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, 'utf-8'));
        case 68:
          zipHeader.filename = _context10.sent;
          _context10.next = 71;
          return tokenizer.ignore(zipHeader.extraFieldLength);
        case 71:
          if (!(zipHeader.filename === 'META-INF/mozilla.rsa')) {
            _context10.next = 73;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'xpi',
            mime: 'application/x-xpinstall'
          });
        case 73:
          if (!(zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml'))) {
            _context10.next = 83;
            break;
          }
          type = zipHeader.filename.split('/')[0];
          _context10.t0 = type;
          _context10.next = _context10.t0 === '_rels' ? 78 : _context10.t0 === 'word' ? 79 : _context10.t0 === 'ppt' ? 80 : _context10.t0 === 'xl' ? 81 : 82;
          break;
        case 78:
          return _context10.abrupt("break", 83);
        case 79:
          return _context10.abrupt("return", {
            ext: 'docx',
            mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
          });
        case 80:
          return _context10.abrupt("return", {
            ext: 'pptx',
            mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
          });
        case 81:
          return _context10.abrupt("return", {
            ext: 'xlsx',
            mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
          });
        case 82:
          return _context10.abrupt("break", 83);
        case 83:
          if (!zipHeader.filename.startsWith('xl/')) {
            _context10.next = 85;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'xlsx',
            mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
          });
        case 85:
          if (!(zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model'))) {
            _context10.next = 87;
            break;
          }
          return _context10.abrupt("return", {
            ext: '3mf',
            mime: 'model/3mf'
          });
        case 87:
          if (!(zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize)) {
            _context10.next = 98;
            break;
          }
          _context10.next = 90;
          return tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, 'utf-8'));
        case 90:
          mimeType = _context10.sent;
          _context10.t1 = mimeType;
          _context10.next = _context10.t1 === 'application/epub+zip' ? 94 : _context10.t1 === 'application/vnd.oasis.opendocument.text' ? 95 : _context10.t1 === 'application/vnd.oasis.opendocument.spreadsheet' ? 96 : _context10.t1 === 'application/vnd.oasis.opendocument.presentation' ? 97 : 98;
          break;
        case 94:
          return _context10.abrupt("return", {
            ext: 'epub',
            mime: 'application/epub+zip'
          });
        case 95:
          return _context10.abrupt("return", {
            ext: 'odt',
            mime: 'application/vnd.oasis.opendocument.text'
          });
        case 96:
          return _context10.abrupt("return", {
            ext: 'ods',
            mime: 'application/vnd.oasis.opendocument.spreadsheet'
          });
        case 97:
          return _context10.abrupt("return", {
            ext: 'odp',
            mime: 'application/vnd.oasis.opendocument.presentation'
          });
        case 98:
          if (!(zipHeader.compressedSize === 0)) {
            _context10.next = 110;
            break;
          }
          nextHeaderIndex = -1;
        case 100:
          if (!(nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size)) {
            _context10.next = 108;
            break;
          }
          _context10.next = 103;
          return tokenizer.peekBuffer(buffer, {
            mayBeLess: true
          });
        case 103:
          nextHeaderIndex = buffer.indexOf('504B0304', 0, 'hex');
          // Move position to the next header if found, skip the whole buffer otherwise
          _context10.next = 106;
          return tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
        case 106:
          _context10.next = 100;
          break;
        case 108:
          _context10.next = 112;
          break;
        case 110:
          _context10.next = 112;
          return tokenizer.ignore(zipHeader.compressedSize);
        case 112:
          _context10.next = 62;
          break;
        case 114:
          _context10.next = 120;
          break;
        case 116:
          _context10.prev = 116;
          _context10.t2 = _context10["catch"](61);
          if (_context10.t2 instanceof strtok3.EndOfStreamError) {
            _context10.next = 120;
            break;
          }
          throw _context10.t2;
        case 120:
          return _context10.abrupt("return", {
            ext: 'zip',
            mime: 'application/zip'
          });
        case 121:
          if (!checkString('OggS')) {
            _context10.next = 140;
            break;
          }
          _context10.next = 124;
          return tokenizer.ignore(28);
        case 124:
          _type = Buffer.alloc(8);
          _context10.next = 127;
          return tokenizer.readBuffer(_type);
        case 127:
          if (!_check(_type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {
            _context10.next = 129;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'opus',
            mime: 'audio/opus'
          });
        case 129:
          if (!_check(_type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {
            _context10.next = 131;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ogv',
            mime: 'video/ogg'
          });
        case 131:
          if (!_check(_type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {
            _context10.next = 133;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ogm',
            mime: 'video/ogg'
          });
        case 133:
          if (!_check(_type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {
            _context10.next = 135;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'oga',
            mime: 'audio/ogg'
          });
        case 135:
          if (!_check(_type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {
            _context10.next = 137;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'spx',
            mime: 'audio/ogg'
          });
        case 137:
          if (!_check(_type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {
            _context10.next = 139;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ogg',
            mime: 'audio/ogg'
          });
        case 139:
          return _context10.abrupt("return", {
            ext: 'ogx',
            mime: 'application/ogg'
          });
        case 140:
          if (!(check([0x50, 0x4B]) && (buffer[2] === 0x3 || buffer[2] === 0x5 || buffer[2] === 0x7) && (buffer[3] === 0x4 || buffer[3] === 0x6 || buffer[3] === 0x8))) {
            _context10.next = 142;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'zip',
            mime: 'application/zip'
          });
        case 142:
          if (!(checkString('ftyp', {
            offset: 4
          }) && (buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
          )) {
            _context10.next = 167;
            break;
          }
          // They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
          // For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
          brandMajor = buffer.toString('binary', 8, 12).replace('\0', ' ').trim();
          _context10.t3 = brandMajor;
          _context10.next = _context10.t3 === 'avif' ? 147 : _context10.t3 === 'mif1' ? 148 : _context10.t3 === 'msf1' ? 149 : _context10.t3 === 'heic' ? 150 : _context10.t3 === 'heix' ? 150 : _context10.t3 === 'hevc' ? 151 : _context10.t3 === 'hevx' ? 151 : _context10.t3 === 'qt' ? 152 : _context10.t3 === 'M4V' ? 153 : _context10.t3 === 'M4VH' ? 153 : _context10.t3 === 'M4VP' ? 153 : _context10.t3 === 'M4P' ? 154 : _context10.t3 === 'M4B' ? 155 : _context10.t3 === 'M4A' ? 156 : _context10.t3 === 'F4V' ? 157 : _context10.t3 === 'F4P' ? 158 : _context10.t3 === 'F4A' ? 159 : _context10.t3 === 'F4B' ? 160 : _context10.t3 === 'crx' ? 161 : 162;
          break;
        case 147:
          return _context10.abrupt("return", {
            ext: 'avif',
            mime: 'image/avif'
          });
        case 148:
          return _context10.abrupt("return", {
            ext: 'heic',
            mime: 'image/heif'
          });
        case 149:
          return _context10.abrupt("return", {
            ext: 'heic',
            mime: 'image/heif-sequence'
          });
        case 150:
          return _context10.abrupt("return", {
            ext: 'heic',
            mime: 'image/heic'
          });
        case 151:
          return _context10.abrupt("return", {
            ext: 'heic',
            mime: 'image/heic-sequence'
          });
        case 152:
          return _context10.abrupt("return", {
            ext: 'mov',
            mime: 'video/quicktime'
          });
        case 153:
          return _context10.abrupt("return", {
            ext: 'm4v',
            mime: 'video/x-m4v'
          });
        case 154:
          return _context10.abrupt("return", {
            ext: 'm4p',
            mime: 'video/mp4'
          });
        case 155:
          return _context10.abrupt("return", {
            ext: 'm4b',
            mime: 'audio/mp4'
          });
        case 156:
          return _context10.abrupt("return", {
            ext: 'm4a',
            mime: 'audio/x-m4a'
          });
        case 157:
          return _context10.abrupt("return", {
            ext: 'f4v',
            mime: 'video/mp4'
          });
        case 158:
          return _context10.abrupt("return", {
            ext: 'f4p',
            mime: 'video/mp4'
          });
        case 159:
          return _context10.abrupt("return", {
            ext: 'f4a',
            mime: 'audio/mp4'
          });
        case 160:
          return _context10.abrupt("return", {
            ext: 'f4b',
            mime: 'audio/mp4'
          });
        case 161:
          return _context10.abrupt("return", {
            ext: 'cr3',
            mime: 'image/x-canon-cr3'
          });
        case 162:
          if (!brandMajor.startsWith('3g')) {
            _context10.next = 166;
            break;
          }
          if (!brandMajor.startsWith('3g2')) {
            _context10.next = 165;
            break;
          }
          return _context10.abrupt("return", {
            ext: '3g2',
            mime: 'video/3gpp2'
          });
        case 165:
          return _context10.abrupt("return", {
            ext: '3gp',
            mime: 'video/3gpp'
          });
        case 166:
          return _context10.abrupt("return", {
            ext: 'mp4',
            mime: 'video/mp4'
          });
        case 167:
          if (!checkString('MThd')) {
            _context10.next = 169;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mid',
            mime: 'audio/midi'
          });
        case 169:
          if (!(checkString('wOFF') && (check([0x00, 0x01, 0x00, 0x00], {
            offset: 4
          }) || checkString('OTTO', {
            offset: 4
          })))) {
            _context10.next = 171;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'woff',
            mime: 'font/woff'
          });
        case 171:
          if (!(checkString('wOF2') && (check([0x00, 0x01, 0x00, 0x00], {
            offset: 4
          }) || checkString('OTTO', {
            offset: 4
          })))) {
            _context10.next = 173;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'woff2',
            mime: 'font/woff2'
          });
        case 173:
          if (!(check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4]))) {
            _context10.next = 175;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'pcap',
            mime: 'application/vnd.tcpdump.pcap'
          });
        case 175:
          if (!checkString('DSD ')) {
            _context10.next = 177;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'dsf',
            mime: 'audio/x-dsf' // Non-standard
          });
        case 177:
          if (!checkString('LZIP')) {
            _context10.next = 179;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'lz',
            mime: 'application/x-lzip'
          });
        case 179:
          if (!checkString('fLaC')) {
            _context10.next = 181;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'flac',
            mime: 'audio/x-flac'
          });
        case 181:
          if (!check([0x42, 0x50, 0x47, 0xFB])) {
            _context10.next = 183;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'bpg',
            mime: 'image/bpg'
          });
        case 183:
          if (!checkString('wvpk')) {
            _context10.next = 185;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'wv',
            mime: 'audio/wavpack'
          });
        case 185:
          if (!checkString('%PDF')) {
            _context10.next = 195;
            break;
          }
          _context10.next = 188;
          return tokenizer.ignore(1350);
        case 188:
          maxBufferSize = 10 * 1024 * 1024;
          _buffer = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
          _context10.next = 192;
          return tokenizer.readBuffer(_buffer, {
            mayBeLess: true
          });
        case 192:
          if (!_buffer.includes(Buffer.from('AIPrivateData'))) {
            _context10.next = 194;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ai',
            mime: 'application/postscript'
          });
        case 194:
          return _context10.abrupt("return", {
            ext: 'pdf',
            mime: 'application/pdf'
          });
        case 195:
          if (!check([0x00, 0x61, 0x73, 0x6D])) {
            _context10.next = 197;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'wasm',
            mime: 'application/wasm'
          });
        case 197:
          if (!check([0x49, 0x49, 0x2A, 0x0])) {
            _context10.next = 210;
            break;
          }
          if (!checkString('CR', {
            offset: 8
          })) {
            _context10.next = 200;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'cr2',
            mime: 'image/x-canon-cr2'
          });
        case 200:
          if (!(check([0x1C, 0x00, 0xFE, 0x00], {
            offset: 8
          }) || check([0x1F, 0x00, 0x0B, 0x00], {
            offset: 8
          }))) {
            _context10.next = 202;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'nef',
            mime: 'image/x-nikon-nef'
          });
        case 202:
          if (!(check([0x08, 0x00, 0x00, 0x00], {
            offset: 4
          }) && (check([0x2D, 0x00, 0xFE, 0x00], {
            offset: 8
          }) || check([0x27, 0x00, 0xFE, 0x00], {
            offset: 8
          })))) {
            _context10.next = 204;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'dng',
            mime: 'image/x-adobe-dng'
          });
        case 204:
          buffer = Buffer.alloc(24);
          _context10.next = 207;
          return tokenizer.peekBuffer(buffer);
        case 207:
          if (!((check([0x10, 0xFB, 0x86, 0x01], {
            offset: 4
          }) || check([0x08, 0x00, 0x00, 0x00], {
            offset: 4
          })) &&
          // This pattern differentiates ARW from other TIFF-ish file types:
          check([0x00, 0xFE, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01], {
            offset: 9
          }))) {
            _context10.next = 209;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'arw',
            mime: 'image/x-sony-arw'
          });
        case 209:
          return _context10.abrupt("return", {
            ext: 'tif',
            mime: 'image/tiff'
          });
        case 210:
          if (!check([0x4D, 0x4D, 0x0, 0x2A])) {
            _context10.next = 212;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'tif',
            mime: 'image/tiff'
          });
        case 212:
          if (!checkString('MAC ')) {
            _context10.next = 214;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ape',
            mime: 'audio/ape'
          });
        case 214:
          if (!check([0x1A, 0x45, 0xDF, 0xA3])) {
            _context10.next = 230;
            break;
          }
          // Root element: EBML
          readField = /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
              var msb, mask, ic, id;
              return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return tokenizer.peekNumber(Token.UINT8);
                  case 2:
                    msb = _context5.sent;
                    mask = 0x80;
                    ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D
                    while ((msb & mask) === 0 && mask !== 0) {
                      ++ic;
                      mask >>= 1;
                    }
                    id = Buffer.alloc(ic + 1);
                    _context5.next = 9;
                    return tokenizer.readBuffer(id);
                  case 9:
                    return _context5.abrupt("return", id);
                  case 10:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5);
            }));
            return function readField() {
              return _ref2.apply(this, arguments);
            };
          }();
          readElement = /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
              var id, lenField, nrLen;
              return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return readField();
                  case 2:
                    id = _context6.sent;
                    _context6.next = 5;
                    return readField();
                  case 5:
                    lenField = _context6.sent;
                    lenField[0] ^= 0x80 >> lenField.length - 1;
                    nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer
                    return _context6.abrupt("return", {
                      id: id.readUIntBE(0, id.length),
                      len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
                    });
                  case 9:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6);
            }));
            return function readElement() {
              return _ref3.apply(this, arguments);
            };
          }();
          readChildren = /*#__PURE__*/function () {
            var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(level, children) {
              var e;
              return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                while (1) switch (_context7.prev = _context7.next) {
                  case 0:
                    if (!(children > 0)) {
                      _context7.next = 11;
                      break;
                    }
                    _context7.next = 3;
                    return readElement();
                  case 3:
                    e = _context7.sent;
                    if (!(e.id === 0x4282)) {
                      _context7.next = 6;
                      break;
                    }
                    return _context7.abrupt("return", tokenizer.readToken(new Token.StringType(e.len, 'utf-8')));
                  case 6:
                    _context7.next = 8;
                    return tokenizer.ignore(e.len);
                  case 8:
                    // ignore payload
                    --children;
                    _context7.next = 0;
                    break;
                  case 11:
                  case "end":
                    return _context7.stop();
                }
              }, _callee7);
            }));
            return function readChildren(_x5, _x6) {
              return _ref4.apply(this, arguments);
            };
          }();
          _context10.next = 220;
          return readElement();
        case 220:
          re = _context10.sent;
          _context10.next = 223;
          return readChildren(1, re.len);
        case 223:
          docType = _context10.sent;
          _context10.t4 = docType;
          _context10.next = _context10.t4 === 'webm' ? 227 : _context10.t4 === 'matroska' ? 228 : 229;
          break;
        case 227:
          return _context10.abrupt("return", {
            ext: 'webm',
            mime: 'video/webm'
          });
        case 228:
          return _context10.abrupt("return", {
            ext: 'mkv',
            mime: 'video/x-matroska'
          });
        case 229:
          return _context10.abrupt("return");
        case 230:
          if (!check([0x52, 0x49, 0x46, 0x46])) {
            _context10.next = 237;
            break;
          }
          if (!check([0x41, 0x56, 0x49], {
            offset: 8
          })) {
            _context10.next = 233;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'avi',
            mime: 'video/vnd.avi'
          });
        case 233:
          if (!check([0x57, 0x41, 0x56, 0x45], {
            offset: 8
          })) {
            _context10.next = 235;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'wav',
            mime: 'audio/vnd.wave'
          });
        case 235:
          if (!check([0x51, 0x4C, 0x43, 0x4D], {
            offset: 8
          })) {
            _context10.next = 237;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'qcp',
            mime: 'audio/qcelp'
          });
        case 237:
          if (!checkString('SQLi')) {
            _context10.next = 239;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'sqlite',
            mime: 'application/x-sqlite3'
          });
        case 239:
          if (!check([0x4E, 0x45, 0x53, 0x1A])) {
            _context10.next = 241;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'nes',
            mime: 'application/x-nintendo-nes-rom'
          });
        case 241:
          if (!checkString('Cr24')) {
            _context10.next = 243;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'crx',
            mime: 'application/x-google-chrome-extension'
          });
        case 243:
          if (!(checkString('MSCF') || checkString('ISc('))) {
            _context10.next = 245;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'cab',
            mime: 'application/vnd.ms-cab-compressed'
          });
        case 245:
          if (!check([0xED, 0xAB, 0xEE, 0xDB])) {
            _context10.next = 247;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'rpm',
            mime: 'application/x-rpm'
          });
        case 247:
          if (!check([0xC5, 0xD0, 0xD3, 0xC6])) {
            _context10.next = 249;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'eps',
            mime: 'application/eps'
          });
        case 249:
          if (!check([0x28, 0xB5, 0x2F, 0xFD])) {
            _context10.next = 251;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'zst',
            mime: 'application/zstd'
          });
        case 251:
          if (!check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
            _context10.next = 253;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'otf',
            mime: 'font/otf'
          });
        case 253:
          if (!checkString('#!AMR')) {
            _context10.next = 255;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'amr',
            mime: 'audio/amr'
          });
        case 255:
          if (!checkString('{\\rtf')) {
            _context10.next = 257;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'rtf',
            mime: 'application/rtf'
          });
        case 257:
          if (!check([0x46, 0x4C, 0x56, 0x01])) {
            _context10.next = 259;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'flv',
            mime: 'video/x-flv'
          });
        case 259:
          if (!checkString('IMPM')) {
            _context10.next = 261;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'it',
            mime: 'audio/x-it'
          });
        case 261:
          if (!(checkString('-lh0-', {
            offset: 2
          }) || checkString('-lh1-', {
            offset: 2
          }) || checkString('-lh2-', {
            offset: 2
          }) || checkString('-lh3-', {
            offset: 2
          }) || checkString('-lh4-', {
            offset: 2
          }) || checkString('-lh5-', {
            offset: 2
          }) || checkString('-lh6-', {
            offset: 2
          }) || checkString('-lh7-', {
            offset: 2
          }) || checkString('-lzs-', {
            offset: 2
          }) || checkString('-lz4-', {
            offset: 2
          }) || checkString('-lz5-', {
            offset: 2
          }) || checkString('-lhd-', {
            offset: 2
          }))) {
            _context10.next = 263;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'lzh',
            mime: 'application/x-lzh-compressed'
          });
        case 263:
          if (!check([0x00, 0x00, 0x01, 0xBA])) {
            _context10.next = 268;
            break;
          }
          if (!check([0x21], {
            offset: 4,
            mask: [0xF1]
          })) {
            _context10.next = 266;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mpg',
            // May also be .ps, .mpeg
            mime: 'video/MP1S'
          });
        case 266:
          if (!check([0x44], {
            offset: 4,
            mask: [0xC4]
          })) {
            _context10.next = 268;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mpg',
            // May also be .mpg, .m2p, .vob or .sub
            mime: 'video/MP2P'
          });
        case 268:
          if (!checkString('ITSF')) {
            _context10.next = 270;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'chm',
            mime: 'application/vnd.ms-htmlhelp'
          });
        case 270:
          if (!check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
            _context10.next = 272;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'xz',
            mime: 'application/x-xz'
          });
        case 272:
          if (!checkString('<?xml ')) {
            _context10.next = 274;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'xml',
            mime: 'application/xml'
          });
        case 274:
          if (!check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
            _context10.next = 276;
            break;
          }
          return _context10.abrupt("return", {
            ext: '7z',
            mime: 'application/x-7z-compressed'
          });
        case 276:
          if (!(check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) && (buffer[6] === 0x0 || buffer[6] === 0x1))) {
            _context10.next = 278;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'rar',
            mime: 'application/x-rar-compressed'
          });
        case 278:
          if (!checkString('solid ')) {
            _context10.next = 280;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'stl',
            mime: 'model/stl'
          });
        case 280:
          if (!checkString('BLENDER')) {
            _context10.next = 282;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'blend',
            mime: 'application/x-blender'
          });
        case 282:
          if (!checkString('!<arch>')) {
            _context10.next = 291;
            break;
          }
          _context10.next = 285;
          return tokenizer.ignore(8);
        case 285:
          _context10.next = 287;
          return tokenizer.readToken(new Token.StringType(13, 'ascii'));
        case 287:
          str = _context10.sent;
          if (!(str === 'debian-binary')) {
            _context10.next = 290;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'deb',
            mime: 'application/x-deb'
          });
        case 290:
          return _context10.abrupt("return", {
            ext: 'ar',
            mime: 'application/x-unix-archive'
          });
        case 291:
          if (!check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
            _context10.next = 309;
            break;
          }
          // ignore PNG signature
          readChunkHeader = /*#__PURE__*/function () {
            var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
              return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                while (1) switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return tokenizer.readToken(Token.INT32_BE);
                  case 2:
                    _context8.t0 = _context8.sent;
                    _context8.next = 5;
                    return tokenizer.readToken(new Token.StringType(4, 'binary'));
                  case 5:
                    _context8.t1 = _context8.sent;
                    return _context8.abrupt("return", {
                      length: _context8.t0,
                      type: _context8.t1
                    });
                  case 7:
                  case "end":
                    return _context8.stop();
                }
              }, _callee8);
            }));
            return function readChunkHeader() {
              return _ref5.apply(this, arguments);
            };
          }();
          _context10.next = 295;
          return tokenizer.ignore(8);
        case 295:
          _context10.next = 297;
          return readChunkHeader();
        case 297:
          chunk = _context10.sent;
          if (!(chunk.length < 0)) {
            _context10.next = 300;
            break;
          }
          return _context10.abrupt("return");
        case 300:
          _context10.t5 = chunk.type;
          _context10.next = _context10.t5 === 'IDAT' ? 303 : _context10.t5 === 'acTL' ? 304 : 305;
          break;
        case 303:
          return _context10.abrupt("return", {
            ext: 'png',
            mime: 'image/png'
          });
        case 304:
          return _context10.abrupt("return", {
            ext: 'apng',
            mime: 'image/apng'
          });
        case 305:
          _context10.next = 307;
          return tokenizer.ignore(chunk.length + 4);
        case 307:
          if (tokenizer.position + 8 < tokenizer.fileInfo.size) {
            _context10.next = 295;
            break;
          }
        case 308:
          return _context10.abrupt("return", {
            ext: 'png',
            mime: 'image/png'
          });
        case 309:
          if (!check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {
            _context10.next = 311;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'arrow',
            mime: 'application/x-apache-arrow'
          });
        case 311:
          if (!check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
            _context10.next = 313;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'glb',
            mime: 'model/gltf-binary'
          });
        case 313:
          if (!(check([0x66, 0x72, 0x65, 0x65], {
            offset: 4
          }) ||
          // `free`
          check([0x6D, 0x64, 0x61, 0x74], {
            offset: 4
          }) ||
          // `mdat` MJPEG
          check([0x6D, 0x6F, 0x6F, 0x76], {
            offset: 4
          }) ||
          // `moov`
          check([0x77, 0x69, 0x64, 0x65], {
            offset: 4
          }) // `wide`
          )) {
            _context10.next = 315;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mov',
            mime: 'video/quicktime'
          });
        case 315:
          if (!check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {
            _context10.next = 317;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'orf',
            mime: 'image/x-olympus-orf'
          });
        case 317:
          if (!checkString('gimp xcf ')) {
            _context10.next = 319;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'xcf',
            mime: 'image/x-xcf'
          });
        case 319:
          if (!check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {
            _context10.next = 321;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'rw2',
            mime: 'image/x-panasonic-rw2'
          });
        case 321:
          if (!check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
            _context10.next = 346;
            break;
          }
          readHeader = /*#__PURE__*/function () {
            var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
              var guid;
              return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    guid = Buffer.alloc(16);
                    _context9.next = 3;
                    return tokenizer.readBuffer(guid);
                  case 3:
                    _context9.t0 = guid;
                    _context9.t1 = Number;
                    _context9.next = 7;
                    return tokenizer.readToken(Token.UINT64_LE);
                  case 7:
                    _context9.t2 = _context9.sent;
                    _context9.t3 = (0, _context9.t1)(_context9.t2);
                    return _context9.abrupt("return", {
                      id: _context9.t0,
                      size: _context9.t3
                    });
                  case 10:
                  case "end":
                    return _context9.stop();
                }
              }, _callee9);
            }));
            return function readHeader() {
              return _ref6.apply(this, arguments);
            };
          }();
          _context10.next = 325;
          return tokenizer.ignore(30);
        case 325:
          if (!(tokenizer.position + 24 < tokenizer.fileInfo.size)) {
            _context10.next = 345;
            break;
          }
          _context10.next = 328;
          return readHeader();
        case 328:
          header = _context10.sent;
          payload = header.size - 24;
          if (!_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {
            _context10.next = 341;
            break;
          }
          // Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
          typeId = Buffer.alloc(16);
          _context10.t6 = payload;
          _context10.next = 335;
          return tokenizer.readBuffer(typeId);
        case 335:
          payload = _context10.t6 -= _context10.sent;
          if (!_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
            _context10.next = 338;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'asf',
            mime: 'audio/x-ms-asf'
          });
        case 338:
          if (!_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
            _context10.next = 340;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'asf',
            mime: 'video/x-ms-asf'
          });
        case 340:
          return _context10.abrupt("break", 345);
        case 341:
          _context10.next = 343;
          return tokenizer.ignore(payload);
        case 343:
          _context10.next = 325;
          break;
        case 345:
          return _context10.abrupt("return", {
            ext: 'asf',
            mime: 'application/vnd.ms-asf'
          });
        case 346:
          if (!check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
            _context10.next = 348;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ktx',
            mime: 'image/ktx'
          });
        case 348:
          if (!((check([0x7E, 0x10, 0x04]) || check([0x7E, 0x18, 0x04])) && check([0x30, 0x4D, 0x49, 0x45], {
            offset: 4
          }))) {
            _context10.next = 350;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mie',
            mime: 'application/x-mie'
          });
        case 350:
          if (!check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {
            offset: 2
          })) {
            _context10.next = 352;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'shp',
            mime: 'application/x-esri-shape'
          });
        case 352:
          if (!check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
            _context10.next = 366;
            break;
          }
          _context10.next = 355;
          return tokenizer.ignore(20);
        case 355:
          _context10.next = 357;
          return tokenizer.readToken(new Token.StringType(4, 'ascii'));
        case 357:
          _type2 = _context10.sent;
          _context10.t7 = _type2;
          _context10.next = _context10.t7 === 'jp2 ' ? 361 : _context10.t7 === 'jpx ' ? 362 : _context10.t7 === 'jpm ' ? 363 : _context10.t7 === 'mjp2' ? 364 : 365;
          break;
        case 361:
          return _context10.abrupt("return", {
            ext: 'jp2',
            mime: 'image/jp2'
          });
        case 362:
          return _context10.abrupt("return", {
            ext: 'jpx',
            mime: 'image/jpx'
          });
        case 363:
          return _context10.abrupt("return", {
            ext: 'jpm',
            mime: 'image/jpm'
          });
        case 364:
          return _context10.abrupt("return", {
            ext: 'mj2',
            mime: 'image/mj2'
          });
        case 365:
          return _context10.abrupt("return");
        case 366:
          if (!(check([0xFF, 0x0A]) || check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A]))) {
            _context10.next = 368;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'jxl',
            mime: 'image/jxl'
          });
        case 368:
          if (!(check([0x0, 0x0, 0x1, 0xBA]) || check([0x0, 0x0, 0x1, 0xB3]))) {
            _context10.next = 370;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mpg',
            mime: 'video/mpeg'
          });
        case 370:
          if (!check([0x00, 0x01, 0x00, 0x00, 0x00])) {
            _context10.next = 372;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ttf',
            mime: 'font/ttf'
          });
        case 372:
          if (!check([0x00, 0x00, 0x01, 0x00])) {
            _context10.next = 374;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ico',
            mime: 'image/x-icon'
          });
        case 374:
          if (!check([0x00, 0x00, 0x02, 0x00])) {
            _context10.next = 376;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'cur',
            mime: 'image/x-icon'
          });
        case 376:
          if (!check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
            _context10.next = 378;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'cfb',
            mime: 'application/x-cfb'
          });
        case 378:
          _context10.next = 380;
          return tokenizer.peekBuffer(buffer, {
            length: Math.min(256, tokenizer.fileInfo.size),
            mayBeLess: true
          });
        case 380:
          if (!checkString('BEGIN:')) {
            _context10.next = 385;
            break;
          }
          if (!checkString('VCARD', {
            offset: 6
          })) {
            _context10.next = 383;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'vcf',
            mime: 'text/vcard'
          });
        case 383:
          if (!checkString('VCALENDAR', {
            offset: 6
          })) {
            _context10.next = 385;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'ics',
            mime: 'text/calendar'
          });
        case 385:
          if (!checkString('FUJIFILMCCD-RAW')) {
            _context10.next = 387;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'raf',
            mime: 'image/x-fujifilm-raf'
          });
        case 387:
          if (!checkString('Extended Module:')) {
            _context10.next = 389;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'xm',
            mime: 'audio/x-xm'
          });
        case 389:
          if (!checkString('Creative Voice File')) {
            _context10.next = 391;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'voc',
            mime: 'audio/x-voc'
          });
        case 391:
          if (!(check([0x04, 0x00, 0x00, 0x00]) && buffer.length >= 16)) {
            _context10.next = 403;
            break;
          }
          // Rough & quick check Pickle/ASAR
          jsonSize = buffer.readUInt32LE(12);
          if (!(jsonSize > 12 && buffer.length >= jsonSize + 16)) {
            _context10.next = 403;
            break;
          }
          _context10.prev = 394;
          _header = buffer.slice(16, jsonSize + 16).toString();
          json = JSON.parse(_header); // Check if Pickle is ASAR
          if (!json.files) {
            _context10.next = 399;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'asar',
            mime: 'application/x-asar'
          });
        case 399:
          _context10.next = 403;
          break;
        case 401:
          _context10.prev = 401;
          _context10.t8 = _context10["catch"](394);
        case 403:
          if (!check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
            _context10.next = 405;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mxf',
            mime: 'application/mxf'
          });
        case 405:
          if (!checkString('SCRM', {
            offset: 44
          })) {
            _context10.next = 407;
            break;
          }
          return _context10.abrupt("return", {
            ext: 's3m',
            mime: 'audio/x-s3m'
          });
        case 407:
          if (!(check([0x47], {
            offset: 4
          }) && (check([0x47], {
            offset: 192
          }) || check([0x47], {
            offset: 196
          })))) {
            _context10.next = 409;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mts',
            mime: 'video/mp2t'
          });
        case 409:
          if (!check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {
            offset: 60
          })) {
            _context10.next = 411;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mobi',
            mime: 'application/x-mobipocket-ebook'
          });
        case 411:
          if (!check([0x44, 0x49, 0x43, 0x4D], {
            offset: 128
          })) {
            _context10.next = 413;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'dcm',
            mime: 'application/dicom'
          });
        case 413:
          if (!check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {
            _context10.next = 415;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'lnk',
            mime: 'application/x.ms.shortcut' // Invented by us
          });
        case 415:
          if (!check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {
            _context10.next = 417;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'alias',
            mime: 'application/x.apple.alias' // Invented by us
          });
        case 417:
          if (!(check([0x4C, 0x50], {
            offset: 34
          }) && (check([0x00, 0x00, 0x01], {
            offset: 8
          }) || check([0x01, 0x00, 0x02], {
            offset: 8
          }) || check([0x02, 0x00, 0x02], {
            offset: 8
          })))) {
            _context10.next = 419;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'eot',
            mime: 'application/vnd.ms-fontobject'
          });
        case 419:
          if (!check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {
            _context10.next = 421;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'indd',
            mime: 'application/x-indesign'
          });
        case 421:
          _context10.next = 423;
          return tokenizer.peekBuffer(buffer, {
            length: Math.min(512, tokenizer.fileInfo.size),
            mayBeLess: true
          });
        case 423:
          if (!tarHeaderChecksumMatches(buffer)) {
            _context10.next = 425;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'tar',
            mime: 'application/x-tar'
          });
        case 425:
          if (!check([0xFF, 0xFE, 0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00])) {
            _context10.next = 427;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'skp',
            mime: 'application/vnd.sketchup.skp'
          });
        case 427:
          if (!checkString('-----BEGIN PGP MESSAGE-----')) {
            _context10.next = 429;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'pgp',
            mime: 'application/pgp-encrypted'
          });
        case 429:
          if (!(buffer.length >= 2 && check([0xFF, 0xE0], {
            offset: 0,
            mask: [0xFF, 0xE0]
          }))) {
            _context10.next = 440;
            break;
          }
          if (!check([0x10], {
            offset: 1,
            mask: [0x16]
          })) {
            _context10.next = 434;
            break;
          }
          if (!check([0x08], {
            offset: 1,
            mask: [0x08]
          })) {
            _context10.next = 433;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'aac',
            mime: 'audio/aac'
          });
        case 433:
          return _context10.abrupt("return", {
            ext: 'aac',
            mime: 'audio/aac'
          });
        case 434:
          if (!check([0x02], {
            offset: 1,
            mask: [0x06]
          })) {
            _context10.next = 436;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mp3',
            mime: 'audio/mpeg'
          });
        case 436:
          if (!check([0x04], {
            offset: 1,
            mask: [0x06]
          })) {
            _context10.next = 438;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mp2',
            mime: 'audio/mpeg'
          });
        case 438:
          if (!check([0x06], {
            offset: 1,
            mask: [0x06]
          })) {
            _context10.next = 440;
            break;
          }
          return _context10.abrupt("return", {
            ext: 'mp1',
            mime: 'audio/mpeg'
          });
        case 440:
        case "end":
          return _context10.stop();
      }
    }, _callee10, null, [[61, 116], [394, 401]]);
  }));
  return _fromTokenizer3.apply(this, arguments);
}
var stream = function stream(readableStream) {
  return new Promise(function (resolve, reject) {
    // Using `eval` to work around issues when bundling with Webpack
    var stream = eval('require')('stream'); // eslint-disable-line no-eval

    readableStream.on('error', reject);
    readableStream.once('readable', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var pass, outputStream, chunk, _fileType;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            // Set up output stream
            pass = new stream.PassThrough();
            if (stream.pipeline) {
              outputStream = stream.pipeline(readableStream, pass, function () {});
            } else {
              outputStream = readableStream.pipe(pass);
            }

            // Read the input stream and detect the filetype
            chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
            _context.prev = 3;
            _context.next = 6;
            return fromBuffer(chunk);
          case 6:
            _fileType = _context.sent;
            pass.fileType = _fileType;
            _context.next = 13;
            break;
          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](3);
            reject(_context.t0);
          case 13:
            resolve(outputStream);
          case 14:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[3, 10]]);
    })));
  });
};
var fileType = {
  fromStream: fromStream,
  fromTokenizer: fromTokenizer,
  fromBuffer: fromBuffer,
  stream: stream
};
Object.defineProperty(fileType, 'extensions', {
  get: function get() {
    return new Set(supported.extensions);
  }
});
Object.defineProperty(fileType, 'mimeTypes', {
  get: function get() {
    return new Set(supported.mimeTypes);
  }
});
module.exports = fileType;
},{"token-types":"node_modules/token-types/lib/index.js","strtok3/lib/core":"node_modules/strtok3/lib/core.js","./util":"node_modules/file-type/util.js","./supported":"node_modules/file-type/supported.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/content-type/index.js":[function(require,module,exports) {
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g; // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/; // eslint-disable-line no-control-regex
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */
var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g; // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */
var QUOTE_REGEXP = /([\\"])/g;

/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

/**
 * Module exports.
 * @public
 */

exports.format = format;
exports.parse = parse;

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required');
  }
  var parameters = obj.parameters;
  var type = obj.type;
  if (!type || !TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid type');
  }
  var string = type;

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param = params[i];
      if (!TOKEN_REGEXP.test(param)) {
        throw new TypeError('invalid parameter name');
      }
      string += '; ' + param + '=' + qstring(parameters[param]);
    }
  }
  return string;
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */

function parse(string) {
  if (!string) {
    throw new TypeError('argument string is required');
  }

  // support req/res-like objects as argument
  var header = typeof string === 'object' ? getcontenttype(string) : string;
  if (typeof header !== 'string') {
    throw new TypeError('argument string is required to be a string');
  }
  var index = header.indexOf(';');
  var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
  if (!TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid media type');
  }
  var obj = new ContentType(type.toLowerCase());

  // parse parameters
  if (index !== -1) {
    var key;
    var match;
    var value;
    PARAM_REGEXP.lastIndex = index;
    while (match = PARAM_REGEXP.exec(header)) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format');
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value.charCodeAt(0) === 0x22 /* " */) {
        // remove quotes
        value = value.slice(1, -1);

        // remove escapes
        if (value.indexOf('\\') !== -1) {
          value = value.replace(QESC_REGEXP, '$1');
        }
      }
      obj.parameters[key] = value;
    }
    if (index !== header.length) {
      throw new TypeError('invalid parameter format');
    }
  }
  return obj;
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */

function getcontenttype(obj) {
  var header;
  if (typeof obj.getHeader === 'function') {
    // res-like
    header = obj.getHeader('content-type');
  } else if (typeof obj.headers === 'object') {
    // req-like
    header = obj.headers && obj.headers['content-type'];
  }
  if (typeof header !== 'string') {
    throw new TypeError('content-type header is missing from object');
  }
  return header;
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring(val) {
  var str = String(val);

  // no need to quote tokens
  if (TOKEN_REGEXP.test(str)) {
    return str;
  }
  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
    throw new TypeError('invalid parameter value');
  }
  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
}

/**
 * Class to represent a content type.
 * @private
 */
function ContentType(type) {
  this.parameters = Object.create(null);
  this.type = type;
}
},{}],"node_modules/media-typer/index.js":[function(require,module,exports) {
/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */
var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

/**
 * Module exports.
 */

exports.format = format;
exports.parse = parse;
exports.test = test;

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required');
  }
  var subtype = obj.subtype;
  var suffix = obj.suffix;
  var type = obj.type;
  if (!type || !TYPE_NAME_REGEXP.test(type)) {
    throw new TypeError('invalid type');
  }
  if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
    throw new TypeError('invalid subtype');
  }

  // format as type/subtype
  var string = type + '/' + subtype;

  // append +suffix
  if (suffix) {
    if (!TYPE_NAME_REGEXP.test(suffix)) {
      throw new TypeError('invalid suffix');
    }
    string += '+' + suffix;
  }
  return string;
}

/**
 * Test media type.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function test(string) {
  if (!string) {
    throw new TypeError('argument string is required');
  }
  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string');
  }
  return TYPE_REGEXP.test(string.toLowerCase());
}

/**
 * Parse media type to object.
 *
 * @param {string} string
 * @return {object}
 * @public
 */

function parse(string) {
  if (!string) {
    throw new TypeError('argument string is required');
  }
  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string');
  }
  var match = TYPE_REGEXP.exec(string.toLowerCase());
  if (!match) {
    throw new TypeError('invalid media type');
  }
  var type = match[1];
  var subtype = match[2];
  var suffix;

  // suffix after last +
  var index = subtype.lastIndexOf('+');
  if (index !== -1) {
    suffix = subtype.substr(index + 1);
    subtype = subtype.substr(0, index);
  }
  return new MediaType(type, subtype, suffix);
}

/**
 * Class for MediaType object.
 * @public
 */

function MediaType(type, subtype, suffix) {
  this.type = type;
  this.subtype = subtype;
  this.suffix = suffix;
}
},{}],"node_modules/music-metadata/lib/matroska/types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrackType = exports.TargetType = exports.DataType = void 0;
var DataType;
(function (DataType) {
  DataType[DataType["string"] = 0] = "string";
  DataType[DataType["uint"] = 1] = "uint";
  DataType[DataType["uid"] = 2] = "uid";
  DataType[DataType["bool"] = 3] = "bool";
  DataType[DataType["binary"] = 4] = "binary";
  DataType[DataType["float"] = 5] = "float";
})(DataType = exports.DataType || (exports.DataType = {}));
var TargetType;
(function (TargetType) {
  TargetType[TargetType["shot"] = 10] = "shot";
  TargetType[TargetType["scene"] = 20] = "scene";
  TargetType[TargetType["track"] = 30] = "track";
  TargetType[TargetType["part"] = 40] = "part";
  TargetType[TargetType["album"] = 50] = "album";
  TargetType[TargetType["edition"] = 60] = "edition";
  TargetType[TargetType["collection"] = 70] = "collection";
})(TargetType = exports.TargetType || (exports.TargetType = {}));
var TrackType;
(function (TrackType) {
  TrackType[TrackType["video"] = 1] = "video";
  TrackType[TrackType["audio"] = 2] = "audio";
  TrackType[TrackType["complex"] = 3] = "complex";
  TrackType[TrackType["logo"] = 4] = "logo";
  TrackType[TrackType["subtitle"] = 17] = "subtitle";
  TrackType[TrackType["button"] = 18] = "button";
  TrackType[TrackType["control"] = 32] = "control";
})(TrackType = exports.TrackType || (exports.TrackType = {}));
},{}],"node_modules/music-metadata/lib/type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TrackType = void 0;
var types_1 = require("./matroska/types");
Object.defineProperty(exports, "TrackType", {
  enumerable: true,
  get: function get() {
    return types_1.TrackType;
  }
});
},{"./matroska/types":"node_modules/music-metadata/lib/matroska/types.js"}],"node_modules/music-metadata/lib/common/GenericTagTypes.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUnique = exports.isSingleton = exports.commonTags = void 0;
exports.commonTags = {
  year: {
    multiple: false
  },
  track: {
    multiple: false
  },
  disk: {
    multiple: false
  },
  title: {
    multiple: false
  },
  artist: {
    multiple: false
  },
  artists: {
    multiple: true,
    unique: true
  },
  albumartist: {
    multiple: false
  },
  album: {
    multiple: false
  },
  date: {
    multiple: false
  },
  originaldate: {
    multiple: false
  },
  originalyear: {
    multiple: false
  },
  comment: {
    multiple: true,
    unique: false
  },
  genre: {
    multiple: true,
    unique: true
  },
  picture: {
    multiple: true,
    unique: true
  },
  composer: {
    multiple: true,
    unique: true
  },
  lyrics: {
    multiple: true,
    unique: false
  },
  albumsort: {
    multiple: false,
    unique: true
  },
  titlesort: {
    multiple: false,
    unique: true
  },
  work: {
    multiple: false,
    unique: true
  },
  artistsort: {
    multiple: false,
    unique: true
  },
  albumartistsort: {
    multiple: false,
    unique: true
  },
  composersort: {
    multiple: false,
    unique: true
  },
  lyricist: {
    multiple: true,
    unique: true
  },
  writer: {
    multiple: true,
    unique: true
  },
  conductor: {
    multiple: true,
    unique: true
  },
  remixer: {
    multiple: true,
    unique: true
  },
  arranger: {
    multiple: true,
    unique: true
  },
  engineer: {
    multiple: true,
    unique: true
  },
  producer: {
    multiple: true,
    unique: true
  },
  technician: {
    multiple: true,
    unique: true
  },
  djmixer: {
    multiple: true,
    unique: true
  },
  mixer: {
    multiple: true,
    unique: true
  },
  label: {
    multiple: true,
    unique: true
  },
  grouping: {
    multiple: false
  },
  subtitle: {
    multiple: true
  },
  discsubtitle: {
    multiple: false
  },
  totaltracks: {
    multiple: false
  },
  totaldiscs: {
    multiple: false
  },
  compilation: {
    multiple: false
  },
  rating: {
    multiple: true
  },
  bpm: {
    multiple: false
  },
  mood: {
    multiple: false
  },
  media: {
    multiple: false
  },
  catalognumber: {
    multiple: true,
    unique: true
  },
  tvShow: {
    multiple: false
  },
  tvShowSort: {
    multiple: false
  },
  tvSeason: {
    multiple: false
  },
  tvEpisode: {
    multiple: false
  },
  tvEpisodeId: {
    multiple: false
  },
  tvNetwork: {
    multiple: false
  },
  podcast: {
    multiple: false
  },
  podcasturl: {
    multiple: false
  },
  releasestatus: {
    multiple: false
  },
  releasetype: {
    multiple: true
  },
  releasecountry: {
    multiple: false
  },
  script: {
    multiple: false
  },
  language: {
    multiple: false
  },
  copyright: {
    multiple: false
  },
  license: {
    multiple: false
  },
  encodedby: {
    multiple: false
  },
  encodersettings: {
    multiple: false
  },
  gapless: {
    multiple: false
  },
  barcode: {
    multiple: false
  },
  isrc: {
    multiple: true
  },
  asin: {
    multiple: false
  },
  musicbrainz_recordingid: {
    multiple: false
  },
  musicbrainz_trackid: {
    multiple: false
  },
  musicbrainz_albumid: {
    multiple: false
  },
  musicbrainz_artistid: {
    multiple: true
  },
  musicbrainz_albumartistid: {
    multiple: true
  },
  musicbrainz_releasegroupid: {
    multiple: false
  },
  musicbrainz_workid: {
    multiple: false
  },
  musicbrainz_trmid: {
    multiple: false
  },
  musicbrainz_discid: {
    multiple: false
  },
  acoustid_id: {
    multiple: false
  },
  acoustid_fingerprint: {
    multiple: false
  },
  musicip_puid: {
    multiple: false
  },
  musicip_fingerprint: {
    multiple: false
  },
  website: {
    multiple: false
  },
  'performer:instrument': {
    multiple: true,
    unique: true
  },
  averageLevel: {
    multiple: false
  },
  peakLevel: {
    multiple: false
  },
  notes: {
    multiple: true,
    unique: false
  },
  key: {
    multiple: false
  },
  originalalbum: {
    multiple: false
  },
  originalartist: {
    multiple: false
  },
  discogs_artist_id: {
    multiple: true,
    unique: true
  },
  discogs_release_id: {
    multiple: false
  },
  discogs_label_id: {
    multiple: false
  },
  discogs_master_release_id: {
    multiple: false
  },
  discogs_votes: {
    multiple: false
  },
  discogs_rating: {
    multiple: false
  },
  replaygain_track_peak: {
    multiple: false
  },
  replaygain_track_gain: {
    multiple: false
  },
  replaygain_album_peak: {
    multiple: false
  },
  replaygain_album_gain: {
    multiple: false
  },
  replaygain_track_minmax: {
    multiple: false
  },
  replaygain_album_minmax: {
    multiple: false
  },
  replaygain_undo: {
    multiple: false
  },
  description: {
    multiple: true
  },
  longDescription: {
    multiple: false
  },
  category: {
    multiple: true
  },
  hdVideo: {
    multiple: false
  },
  keywords: {
    multiple: true
  },
  movement: {
    multiple: false
  },
  movementIndex: {
    multiple: false
  },
  movementTotal: {
    multiple: false
  },
  podcastId: {
    multiple: false
  },
  showMovement: {
    multiple: false
  },
  stik: {
    multiple: false
  }
};
/**
 * @param alias Name of common tag
 * @returns {boolean|*} true if given alias is mapped as a singleton', otherwise false
 */
function isSingleton(alias) {
  return exports.commonTags.hasOwnProperty(alias) && !exports.commonTags[alias].multiple;
}
exports.isSingleton = isSingleton;
/**
 * @param alias Common (generic) tag
 * @returns {boolean|*} true if given alias is a singleton or explicitly marked as unique
 */
function isUnique(alias) {
  return !exports.commonTags[alias].multiple || exports.commonTags[alias].unique;
}
exports.isUnique = isUnique;
},{}],"node_modules/music-metadata/lib/common/GenericTagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CommonTagMapper = void 0;
var CommonTagMapper = /*#__PURE__*/function () {
  function CommonTagMapper(tagTypes, tagMap) {
    _classCallCheck(this, CommonTagMapper);
    this.tagTypes = tagTypes;
    this.tagMap = tagMap;
  }
  /**
   * Process and set common tags
   * write common tags to
   * @param tag Native tag
   * @param warnings Register warnings
   * @return common name
   */
  _createClass(CommonTagMapper, [{
    key: "mapGenericTag",
    value: function mapGenericTag(tag, warnings) {
      tag = {
        id: tag.id,
        value: tag.value
      }; // clone object
      this.postMap(tag, warnings);
      // Convert native tag event to generic 'alias' tag
      var id = this.getCommonName(tag.id);
      return id ? {
        id: id,
        value: tag.value
      } : null;
    }
    /**
     * Convert native tag key to common tag key
     * @tag  Native header tag
     * @return common tag name (alias)
     */
  }, {
    key: "getCommonName",
    value: function getCommonName(tag) {
      return this.tagMap[tag];
    }
    /**
     * Handle post mapping exceptions / correction
     * @param tag Tag e.g. {"©alb", "Buena Vista Social Club")
     * @param warnings Used to register warnings
     */
  }, {
    key: "postMap",
    value: function postMap(tag, warnings) {
      return;
    }
  }], [{
    key: "toIntOrNull",
    value: function toIntOrNull(str) {
      var cleaned = parseInt(str, 10);
      return isNaN(cleaned) ? null : cleaned;
    }
    // TODO: a string of 1of1 would fail to be converted
    // converts 1/10 to no : 1, of : 10
    // or 1 to no : 1, of : 0
  }, {
    key: "normalizeTrack",
    value: function normalizeTrack(origVal) {
      var split = origVal.toString().split('/');
      return {
        no: parseInt(split[0], 10) || null,
        of: parseInt(split[1], 10) || null
      };
    }
  }]);
  return CommonTagMapper;
}();
CommonTagMapper.maxRatingScore = 1;
exports.CommonTagMapper = CommonTagMapper;
},{}],"node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ID3v1TagMapper = void 0;
var GenericTagMapper_1 = require("../common/GenericTagMapper");
/**
 * ID3v1 tag mappings
 */
var id3v1TagMap = {
  title: 'title',
  artist: 'artist',
  album: 'album',
  year: 'year',
  comment: 'comment',
  track: 'track',
  genre: 'genre'
};
var ID3v1TagMapper = /*#__PURE__*/function (_GenericTagMapper_1$C) {
  _inherits(ID3v1TagMapper, _GenericTagMapper_1$C);
  var _super = _createSuper(ID3v1TagMapper);
  function ID3v1TagMapper() {
    _classCallCheck(this, ID3v1TagMapper);
    return _super.call(this, ['ID3v1'], id3v1TagMap);
  }
  return _createClass(ID3v1TagMapper);
}(GenericTagMapper_1.CommonTagMapper);
exports.ID3v1TagMapper = ID3v1TagMapper;
},{"../common/GenericTagMapper":"node_modules/music-metadata/lib/common/GenericTagMapper.js"}],"node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CaseInsensitiveTagMap = void 0;
var GenericTagMapper_1 = require("./GenericTagMapper");
var CaseInsensitiveTagMap = /*#__PURE__*/function (_GenericTagMapper_1$C) {
  _inherits(CaseInsensitiveTagMap, _GenericTagMapper_1$C);
  var _super = _createSuper(CaseInsensitiveTagMap);
  function CaseInsensitiveTagMap(tagTypes, tagMap) {
    _classCallCheck(this, CaseInsensitiveTagMap);
    var upperCaseMap = {};
    for (var _i = 0, _Object$keys = Object.keys(tagMap); _i < _Object$keys.length; _i++) {
      var tag = _Object$keys[_i];
      upperCaseMap[tag.toUpperCase()] = tagMap[tag];
    }
    return _super.call(this, tagTypes, upperCaseMap);
  }
  /**
   * @tag  Native header tag
   * @return common tag name (alias)
   */
  _createClass(CaseInsensitiveTagMap, [{
    key: "getCommonName",
    value: function getCommonName(tag) {
      return this.tagMap[tag.toUpperCase()];
    }
  }]);
  return CaseInsensitiveTagMap;
}(GenericTagMapper_1.CommonTagMapper);
exports.CaseInsensitiveTagMap = CaseInsensitiveTagMap;
},{"./GenericTagMapper":"node_modules/music-metadata/lib/common/GenericTagMapper.js"}],"node_modules/music-metadata/lib/common/Util.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toRatio = exports.dbToRatio = exports.ratioToDb = exports.a2hex = exports.isBitSet = exports.getBitAllignedNumber = exports.stripNulls = exports.decodeString = exports.trimRightNull = exports.findZero = exports.getBit = void 0;
function getBit(buf, off, bit) {
  return (buf[off] & 1 << bit) !== 0;
}
exports.getBit = getBit;
/**
 * Found delimiting zero in uint8Array
 * @param uint8Array Uint8Array to find the zero delimiter in
 * @param start Offset in uint8Array
 * @param end Last position to parse in uint8Array
 * @param encoding The string encoding used
 * @return Absolute position on uint8Array where zero found
 */
function findZero(uint8Array, start, end, encoding) {
  var i = start;
  if (encoding === 'utf16le') {
    while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {
      if (i >= end) return end;
      i += 2;
    }
    return i;
  } else {
    while (uint8Array[i] !== 0) {
      if (i >= end) return end;
      i++;
    }
    return i;
  }
}
exports.findZero = findZero;
function trimRightNull(x) {
  var pos0 = x.indexOf('\0');
  return pos0 === -1 ? x : x.substr(0, pos0);
}
exports.trimRightNull = trimRightNull;
function swapBytes(uint8Array) {
  var l = uint8Array.length;
  if ((l & 1) !== 0) throw new Error('Buffer length must be even');
  for (var i = 0; i < l; i += 2) {
    var a = uint8Array[i];
    uint8Array[i] = uint8Array[i + 1];
    uint8Array[i + 1] = a;
  }
  return uint8Array;
}
/**
 * Decode string
 */
function decodeString(uint8Array, encoding) {
  // annoying workaround for a double BOM issue
  // https://github.com/leetreveil/musicmetadata/issues/84
  if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) {
    // little endian
    return decodeString(uint8Array.subarray(2), encoding);
  } else if (encoding === 'utf16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {
    // BOM, indicating big endian decoding
    if ((uint8Array.length & 1) !== 0) throw new Error('Expected even number of octets for 16-bit unicode string');
    return decodeString(swapBytes(uint8Array), encoding);
  }
  return Buffer.from(uint8Array).toString(encoding);
}
exports.decodeString = decodeString;
function stripNulls(str) {
  str = str.replace(/^\x00+/g, '');
  str = str.replace(/\x00+$/g, '');
  return str;
}
exports.stripNulls = stripNulls;
/**
 * Read bit-aligned number start from buffer
 * Total offset in bits = byteOffset * 8 + bitOffset
 * @param source Byte buffer
 * @param byteOffset Starting offset in bytes
 * @param bitOffset Starting offset in bits: 0 = lsb
 * @param len Length of number in bits
 * @return Decoded bit aligned number
 */
function getBitAllignedNumber(source, byteOffset, bitOffset, len) {
  var byteOff = byteOffset + ~~(bitOffset / 8);
  var bitOff = bitOffset % 8;
  var value = source[byteOff];
  value &= 0xff >> bitOff;
  var bitsRead = 8 - bitOff;
  var bitsLeft = len - bitsRead;
  if (bitsLeft < 0) {
    value >>= 8 - bitOff - len;
  } else if (bitsLeft > 0) {
    value <<= bitsLeft;
    value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);
  }
  return value;
}
exports.getBitAllignedNumber = getBitAllignedNumber;
/**
 * Read bit-aligned number start from buffer
 * Total offset in bits = byteOffset * 8 + bitOffset
 * @param source Byte Uint8Array
 * @param byteOffset Starting offset in bytes
 * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit
 * @return True if bit is set
 */
function isBitSet(source, byteOffset, bitOffset) {
  return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;
}
exports.isBitSet = isBitSet;
function a2hex(str) {
  var arr = [];
  for (var i = 0, l = str.length; i < l; i++) {
    var hex = Number(str.charCodeAt(i)).toString(16);
    arr.push(hex.length === 1 ? '0' + hex : hex);
  }
  return arr.join(' ');
}
exports.a2hex = a2hex;
/**
 * Convert power ratio to DB
 * ratio: [0..1]
 */
function ratioToDb(ratio) {
  return 10 * Math.log10(ratio);
}
exports.ratioToDb = ratioToDb;
/**
 * Convert dB to ratio
 * db Decibels
 */
function dbToRatio(dB) {
  return Math.pow(10, dB / 10);
}
exports.dbToRatio = dbToRatio;
/**
 * Convert replay gain to ratio and Decibel
 * @param value string holding a ratio like '0.034' or '-7.54 dB'
 */
function toRatio(value) {
  var ps = value.split(' ').map(function (p) {
    return p.trim().toLowerCase();
  });
  // @ts-ignore
  if (ps.length >= 1) {
    var v = parseFloat(ps[0]);
    return ps.length === 2 && ps[1] === 'db' ? {
      dB: v,
      ratio: dbToRatio(v)
    } : {
      dB: ratioToDb(v),
      ratio: v
    };
  }
}
exports.toRatio = toRatio;
},{"buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ID3v24TagMapper = void 0;
var GenericTagMapper_1 = require("../common/GenericTagMapper");
var CaseInsensitiveTagMap_1 = require("../common/CaseInsensitiveTagMap");
var util = require("../common/Util");
/**
 * ID3v2.3/ID3v2.4 tag mappings
 */
var id3v24TagMap = {
  // id3v2.3
  TIT2: 'title',
  TPE1: 'artist',
  'TXXX:Artists': 'artists',
  TPE2: 'albumartist',
  TALB: 'album',
  TDRV: 'date',
  /**
   * Original release year
   */
  TORY: 'originalyear',
  TPOS: 'disk',
  TCON: 'genre',
  APIC: 'picture',
  TCOM: 'composer',
  'USLT:description': 'lyrics',
  TSOA: 'albumsort',
  TSOT: 'titlesort',
  TOAL: 'originalalbum',
  TSOP: 'artistsort',
  TSO2: 'albumartistsort',
  TSOC: 'composersort',
  TEXT: 'lyricist',
  'TXXX:Writer': 'writer',
  TPE3: 'conductor',
  // 'IPLS:instrument': 'performer:instrument', // ToDo
  TPE4: 'remixer',
  'IPLS:arranger': 'arranger',
  'IPLS:engineer': 'engineer',
  'IPLS:producer': 'producer',
  'IPLS:DJ-mix': 'djmixer',
  'IPLS:mix': 'mixer',
  TPUB: 'label',
  TIT1: 'grouping',
  TIT3: 'subtitle',
  TRCK: 'track',
  TCMP: 'compilation',
  POPM: 'rating',
  TBPM: 'bpm',
  TMED: 'media',
  'TXXX:CATALOGNUMBER': 'catalognumber',
  'TXXX:MusicBrainz Album Status': 'releasestatus',
  'TXXX:MusicBrainz Album Type': 'releasetype',
  /**
   * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
   */
  'TXXX:MusicBrainz Album Release Country': 'releasecountry',
  /**
   * Release country as implemented // ToDo: report
   */
  'TXXX:RELEASECOUNTRY': 'releasecountry',
  'TXXX:SCRIPT': 'script',
  TLAN: 'language',
  TCOP: 'copyright',
  WCOP: 'license',
  TENC: 'encodedby',
  TSSE: 'encodersettings',
  'TXXX:BARCODE': 'barcode',
  'TXXX:ISRC': 'isrc',
  TSRC: 'isrc',
  'TXXX:ASIN': 'asin',
  'TXXX:originalyear': 'originalyear',
  'UFID:http://musicbrainz.org': 'musicbrainz_recordingid',
  'TXXX:MusicBrainz Release Track Id': 'musicbrainz_trackid',
  'TXXX:MusicBrainz Album Id': 'musicbrainz_albumid',
  'TXXX:MusicBrainz Artist Id': 'musicbrainz_artistid',
  'TXXX:MusicBrainz Album Artist Id': 'musicbrainz_albumartistid',
  'TXXX:MusicBrainz Release Group Id': 'musicbrainz_releasegroupid',
  'TXXX:MusicBrainz Work Id': 'musicbrainz_workid',
  'TXXX:MusicBrainz TRM Id': 'musicbrainz_trmid',
  'TXXX:MusicBrainz Disc Id': 'musicbrainz_discid',
  'TXXX:ACOUSTID_ID': 'acoustid_id',
  'TXXX:Acoustid Id': 'acoustid_id',
  'TXXX:Acoustid Fingerprint': 'acoustid_fingerprint',
  'TXXX:MusicIP PUID': 'musicip_puid',
  'TXXX:MusicMagic Fingerprint': 'musicip_fingerprint',
  WOAR: 'website',
  // id3v2.4
  // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
  TDRC: 'date',
  TYER: 'year',
  TDOR: 'originaldate',
  // 'TMCL:instrument': 'performer:instrument',
  'TIPL:arranger': 'arranger',
  'TIPL:engineer': 'engineer',
  'TIPL:producer': 'producer',
  'TIPL:DJ-mix': 'djmixer',
  'TIPL:mix': 'mixer',
  TMOO: 'mood',
  // additional mappings:
  SYLT: 'lyrics',
  TSST: 'discsubtitle',
  TKEY: 'key',
  COMM: 'comment',
  TOPE: 'originalartist',
  // Windows Media Player
  'PRIV:AverageLevel': 'averageLevel',
  'PRIV:PeakLevel': 'peakLevel',
  // Discogs
  'TXXX:DISCOGS_ARTIST_ID': 'discogs_artist_id',
  'TXXX:DISCOGS_ARTISTS': 'artists',
  'TXXX:DISCOGS_ARTIST_NAME': 'artists',
  'TXXX:DISCOGS_ALBUM_ARTISTS': 'albumartist',
  'TXXX:DISCOGS_CATALOG': 'catalognumber',
  'TXXX:DISCOGS_COUNTRY': 'releasecountry',
  'TXXX:DISCOGS_DATE': 'originaldate',
  'TXXX:DISCOGS_LABEL': 'label',
  'TXXX:DISCOGS_LABEL_ID': 'discogs_label_id',
  'TXXX:DISCOGS_MASTER_RELEASE_ID': 'discogs_master_release_id',
  'TXXX:DISCOGS_RATING': 'discogs_rating',
  'TXXX:DISCOGS_RELEASED': 'date',
  'TXXX:DISCOGS_RELEASE_ID': 'discogs_release_id',
  'TXXX:DISCOGS_VOTES': 'discogs_votes',
  'TXXX:CATALOGID': 'catalognumber',
  'TXXX:STYLE': 'genre',
  'TXXX:REPLAYGAIN_TRACK_PEAK': 'replaygain_track_peak',
  'TXXX:REPLAYGAIN_TRACK_GAIN': 'replaygain_track_gain',
  'TXXX:REPLAYGAIN_ALBUM_PEAK': 'replaygain_album_peak',
  'TXXX:REPLAYGAIN_ALBUM_GAIN': 'replaygain_album_gain',
  'TXXX:MP3GAIN_MINMAX': 'replaygain_track_minmax',
  'TXXX:MP3GAIN_ALBUM_MINMAX': 'replaygain_album_minmax',
  'TXXX:MP3GAIN_UNDO': 'replaygain_undo',
  MVNM: 'movement',
  MVIN: 'movementIndex',
  PCST: 'podcast',
  TCAT: 'category',
  TDES: 'description',
  TDRL: 'date',
  TGID: 'podcastId',
  TKWD: 'keywords',
  WFED: 'podcasturl'
};
var ID3v24TagMapper = /*#__PURE__*/function (_CaseInsensitiveTagMa) {
  _inherits(ID3v24TagMapper, _CaseInsensitiveTagMa);
  var _super = _createSuper(ID3v24TagMapper);
  function ID3v24TagMapper() {
    _classCallCheck(this, ID3v24TagMapper);
    return _super.call(this, ['ID3v2.3', 'ID3v2.4'], id3v24TagMap);
  }
  /**
   * Handle post mapping exceptions / correction
   * @param tag to post map
   * @param warnings Wil be used to register (collect) warnings
   * @return Common value e.g. "Buena Vista Social Club"
   */
  _createClass(ID3v24TagMapper, [{
    key: "postMap",
    value: function postMap(tag, warnings) {
      switch (tag.id) {
        case 'UFID':
          // decode MusicBrainz Recording Id
          if (tag.value.owner_identifier === 'http://musicbrainz.org') {
            tag.id += ':' + tag.value.owner_identifier;
            tag.value = util.decodeString(tag.value.identifier, 'latin1'); // latin1 == iso-8859-1
          }

          break;
        case 'PRIV':
          switch (tag.value.owner_identifier) {
            // decode Windows Media Player
            case 'AverageLevel':
            case 'PeakValue':
              tag.id += ':' + tag.value.owner_identifier;
              tag.value = tag.value.data.length === 4 ? tag.value.data.readUInt32LE(0) : null;
              if (tag.value === null) {
                warnings.addWarning("Failed to parse PRIV:PeakValue");
              }
              break;
            default:
              warnings.addWarning("Unknown PRIV owner-identifier: ".concat(tag.value.owner_identifier));
          }
          break;
        case 'COMM':
          tag.value = tag.value ? tag.value.text : null;
          break;
        case 'POPM':
          tag.value = ID3v24TagMapper.toRating(tag.value);
          break;
        default:
          break;
      }
    }
  }], [{
    key: "toRating",
    value: function toRating(popm) {
      return {
        source: popm.email,
        rating: popm.rating > 0 ? (popm.rating - 1) / 254 * GenericTagMapper_1.CommonTagMapper.maxRatingScore : undefined
      };
    }
  }]);
  return ID3v24TagMapper;
}(CaseInsensitiveTagMap_1.CaseInsensitiveTagMap);
exports.ID3v24TagMapper = ID3v24TagMapper;
},{"../common/GenericTagMapper":"node_modules/music-metadata/lib/common/GenericTagMapper.js","../common/CaseInsensitiveTagMap":"node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js"}],"node_modules/music-metadata/lib/asf/AsfTagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsfTagMapper = void 0;
var GenericTagMapper_1 = require("../common/GenericTagMapper");
/**
 * ASF Metadata tag mappings.
 * See http://msdn.microsoft.com/en-us/library/ms867702.aspx
 */
var asfTagMap = {
  Title: 'title',
  Author: 'artist',
  'WM/AlbumArtist': 'albumartist',
  'WM/AlbumTitle': 'album',
  'WM/Year': 'date',
  'WM/OriginalReleaseTime': 'originaldate',
  'WM/OriginalReleaseYear': 'originalyear',
  Description: 'comment',
  'WM/TrackNumber': 'track',
  'WM/PartOfSet': 'disk',
  'WM/Genre': 'genre',
  'WM/Composer': 'composer',
  'WM/Lyrics': 'lyrics',
  'WM/AlbumSortOrder': 'albumsort',
  'WM/TitleSortOrder': 'titlesort',
  'WM/ArtistSortOrder': 'artistsort',
  'WM/AlbumArtistSortOrder': 'albumartistsort',
  'WM/ComposerSortOrder': 'composersort',
  'WM/Writer': 'lyricist',
  'WM/Conductor': 'conductor',
  'WM/ModifiedBy': 'remixer',
  'WM/Engineer': 'engineer',
  'WM/Producer': 'producer',
  'WM/DJMixer': 'djmixer',
  'WM/Mixer': 'mixer',
  'WM/Publisher': 'label',
  'WM/ContentGroupDescription': 'grouping',
  'WM/SubTitle': 'subtitle',
  'WM/SetSubTitle': 'discsubtitle',
  // 'WM/PartOfSet': 'totaldiscs',
  'WM/IsCompilation': 'compilation',
  'WM/SharedUserRating': 'rating',
  'WM/BeatsPerMinute': 'bpm',
  'WM/Mood': 'mood',
  'WM/Media': 'media',
  'WM/CatalogNo': 'catalognumber',
  'MusicBrainz/Album Status': 'releasestatus',
  'MusicBrainz/Album Type': 'releasetype',
  'MusicBrainz/Album Release Country': 'releasecountry',
  'WM/Script': 'script',
  'WM/Language': 'language',
  Copyright: 'copyright',
  LICENSE: 'license',
  'WM/EncodedBy': 'encodedby',
  'WM/EncodingSettings': 'encodersettings',
  'WM/Barcode': 'barcode',
  'WM/ISRC': 'isrc',
  'MusicBrainz/Track Id': 'musicbrainz_recordingid',
  'MusicBrainz/Release Track Id': 'musicbrainz_trackid',
  'MusicBrainz/Album Id': 'musicbrainz_albumid',
  'MusicBrainz/Artist Id': 'musicbrainz_artistid',
  'MusicBrainz/Album Artist Id': 'musicbrainz_albumartistid',
  'MusicBrainz/Release Group Id': 'musicbrainz_releasegroupid',
  'MusicBrainz/Work Id': 'musicbrainz_workid',
  'MusicBrainz/TRM Id': 'musicbrainz_trmid',
  'MusicBrainz/Disc Id': 'musicbrainz_discid',
  'Acoustid/Id': 'acoustid_id',
  'Acoustid/Fingerprint': 'acoustid_fingerprint',
  'MusicIP/PUID': 'musicip_puid',
  'WM/ARTISTS': 'artists',
  'WM/InitialKey': 'key',
  ASIN: 'asin',
  'WM/Work': 'work',
  'WM/AuthorURL': 'website',
  'WM/Picture': 'picture'
};
var AsfTagMapper = /*#__PURE__*/function (_GenericTagMapper_1$C) {
  _inherits(AsfTagMapper, _GenericTagMapper_1$C);
  var _super = _createSuper(AsfTagMapper);
  function AsfTagMapper() {
    _classCallCheck(this, AsfTagMapper);
    return _super.call(this, ['asf'], asfTagMap);
  }
  _createClass(AsfTagMapper, [{
    key: "postMap",
    value: function postMap(tag) {
      switch (tag.id) {
        case 'WM/SharedUserRating':
          var keys = tag.id.split(':');
          tag.value = AsfTagMapper.toRating(tag.value);
          tag.id = keys[0];
          break;
      }
    }
  }], [{
    key: "toRating",
    value: function toRating(rating) {
      return {
        rating: parseFloat(rating + 1) / 5
      };
    }
  }]);
  return AsfTagMapper;
}(GenericTagMapper_1.CommonTagMapper);
exports.AsfTagMapper = AsfTagMapper;
},{"../common/GenericTagMapper":"node_modules/music-metadata/lib/common/GenericTagMapper.js"}],"node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ID3v22TagMapper = exports.id3v22TagMap = void 0;
var CaseInsensitiveTagMap_1 = require("../common/CaseInsensitiveTagMap");
/**
 * ID3v2.2 tag mappings
 */
exports.id3v22TagMap = {
  TT2: 'title',
  TP1: 'artist',
  TP2: 'albumartist',
  TAL: 'album',
  TYE: 'year',
  COM: 'comment',
  TRK: 'track',
  TPA: 'disk',
  TCO: 'genre',
  PIC: 'picture',
  TCM: 'composer',
  TOR: 'originaldate',
  TOT: 'originalalbum',
  TXT: 'lyricist',
  TP3: 'conductor',
  TPB: 'label',
  TT1: 'grouping',
  TT3: 'subtitle',
  TLA: 'language',
  TCR: 'copyright',
  WCP: 'license',
  TEN: 'encodedby',
  TSS: 'encodersettings',
  WAR: 'website',
  'COM:iTunPGAP': 'gapless'
  /* ToDo: iTunes tags:
  'COM:iTunNORM': ,
  'COM:iTunSMPB': 'encoder delay',
  'COM:iTunes_CDDB_IDs'
  */,
  PCS: 'podcast',
  TCP: "compilation",
  TDR: 'date',
  TS2: 'albumartistsort',
  TSA: 'albumsort',
  TSC: 'composersort',
  TSP: 'artistsort',
  TST: 'titlesort',
  WFD: 'podcasturl',
  TBP: 'bpm'
};
var ID3v22TagMapper = /*#__PURE__*/function (_CaseInsensitiveTagMa) {
  _inherits(ID3v22TagMapper, _CaseInsensitiveTagMa);
  var _super = _createSuper(ID3v22TagMapper);
  function ID3v22TagMapper() {
    _classCallCheck(this, ID3v22TagMapper);
    return _super.call(this, ['ID3v2.2'], exports.id3v22TagMap);
  }
  return _createClass(ID3v22TagMapper);
}(CaseInsensitiveTagMap_1.CaseInsensitiveTagMap);
exports.ID3v22TagMapper = ID3v22TagMapper;
},{"../common/CaseInsensitiveTagMap":"node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js"}],"node_modules/music-metadata/lib/apev2/APEv2TagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APEv2TagMapper = void 0;
var CaseInsensitiveTagMap_1 = require("../common/CaseInsensitiveTagMap");
/**
 * ID3v2.2 tag mappings
 */
var apev2TagMap = {
  Title: 'title',
  Artist: 'artist',
  Artists: 'artists',
  'Album Artist': 'albumartist',
  Album: 'album',
  Year: 'date',
  Originalyear: 'originalyear',
  Originaldate: 'originaldate',
  Comment: 'comment',
  Track: 'track',
  Disc: 'disk',
  DISCNUMBER: 'disk',
  Genre: 'genre',
  'Cover Art (Front)': 'picture',
  'Cover Art (Back)': 'picture',
  Composer: 'composer',
  Lyrics: 'lyrics',
  ALBUMSORT: 'albumsort',
  TITLESORT: 'titlesort',
  WORK: 'work',
  ARTISTSORT: 'artistsort',
  ALBUMARTISTSORT: 'albumartistsort',
  COMPOSERSORT: 'composersort',
  Lyricist: 'lyricist',
  Writer: 'writer',
  Conductor: 'conductor',
  // 'Performer=artist (instrument)': 'performer:instrument',
  MixArtist: 'remixer',
  Arranger: 'arranger',
  Engineer: 'engineer',
  Producer: 'producer',
  DJMixer: 'djmixer',
  Mixer: 'mixer',
  Label: 'label',
  Grouping: 'grouping',
  Subtitle: 'subtitle',
  DiscSubtitle: 'discsubtitle',
  Compilation: 'compilation',
  BPM: 'bpm',
  Mood: 'mood',
  Media: 'media',
  CatalogNumber: 'catalognumber',
  MUSICBRAINZ_ALBUMSTATUS: 'releasestatus',
  MUSICBRAINZ_ALBUMTYPE: 'releasetype',
  RELEASECOUNTRY: 'releasecountry',
  Script: 'script',
  Language: 'language',
  Copyright: 'copyright',
  LICENSE: 'license',
  EncodedBy: 'encodedby',
  EncoderSettings: 'encodersettings',
  Barcode: 'barcode',
  ISRC: 'isrc',
  ASIN: 'asin',
  musicbrainz_trackid: 'musicbrainz_recordingid',
  musicbrainz_releasetrackid: 'musicbrainz_trackid',
  MUSICBRAINZ_ALBUMID: 'musicbrainz_albumid',
  MUSICBRAINZ_ARTISTID: 'musicbrainz_artistid',
  MUSICBRAINZ_ALBUMARTISTID: 'musicbrainz_albumartistid',
  MUSICBRAINZ_RELEASEGROUPID: 'musicbrainz_releasegroupid',
  MUSICBRAINZ_WORKID: 'musicbrainz_workid',
  MUSICBRAINZ_TRMID: 'musicbrainz_trmid',
  MUSICBRAINZ_DISCID: 'musicbrainz_discid',
  Acoustid_Id: 'acoustid_id',
  ACOUSTID_FINGERPRINT: 'acoustid_fingerprint',
  MUSICIP_PUID: 'musicip_puid',
  Weblink: 'website',
  REPLAYGAIN_TRACK_GAIN: 'replaygain_track_gain',
  REPLAYGAIN_TRACK_PEAK: 'replaygain_track_peak',
  MP3GAIN_MINMAX: 'replaygain_track_minmax',
  MP3GAIN_UNDO: 'replaygain_undo'
};
var APEv2TagMapper = /*#__PURE__*/function (_CaseInsensitiveTagMa) {
  _inherits(APEv2TagMapper, _CaseInsensitiveTagMa);
  var _super = _createSuper(APEv2TagMapper);
  function APEv2TagMapper() {
    _classCallCheck(this, APEv2TagMapper);
    return _super.call(this, ['APEv2'], apev2TagMap);
  }
  return _createClass(APEv2TagMapper);
}(CaseInsensitiveTagMap_1.CaseInsensitiveTagMap);
exports.APEv2TagMapper = APEv2TagMapper;
},{"../common/CaseInsensitiveTagMap":"node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js"}],"node_modules/music-metadata/lib/mp4/MP4TagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MP4TagMapper = exports.tagType = void 0;
var CaseInsensitiveTagMap_1 = require("../common/CaseInsensitiveTagMap");
/**
 * Ref: https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata
 */
var mp4TagMap = {
  '©nam': 'title',
  '©ART': 'artist',
  aART: 'albumartist',
  /**
   * ToDo: Album artist seems to be stored here while Picard documentation says: aART
   */
  '----:com.apple.iTunes:Band': 'albumartist',
  '©alb': 'album',
  '©day': 'date',
  '©cmt': 'comment',
  '©com': 'comment',
  trkn: 'track',
  disk: 'disk',
  '©gen': 'genre',
  covr: 'picture',
  '©wrt': 'composer',
  '©lyr': 'lyrics',
  soal: 'albumsort',
  sonm: 'titlesort',
  soar: 'artistsort',
  soaa: 'albumartistsort',
  soco: 'composersort',
  '----:com.apple.iTunes:LYRICIST': 'lyricist',
  '----:com.apple.iTunes:CONDUCTOR': 'conductor',
  '----:com.apple.iTunes:REMIXER': 'remixer',
  '----:com.apple.iTunes:ENGINEER': 'engineer',
  '----:com.apple.iTunes:PRODUCER': 'producer',
  '----:com.apple.iTunes:DJMIXER': 'djmixer',
  '----:com.apple.iTunes:MIXER': 'mixer',
  '----:com.apple.iTunes:LABEL': 'label',
  '©grp': 'grouping',
  '----:com.apple.iTunes:SUBTITLE': 'subtitle',
  '----:com.apple.iTunes:DISCSUBTITLE': 'discsubtitle',
  cpil: 'compilation',
  tmpo: 'bpm',
  '----:com.apple.iTunes:MOOD': 'mood',
  '----:com.apple.iTunes:MEDIA': 'media',
  '----:com.apple.iTunes:CATALOGNUMBER': 'catalognumber',
  tvsh: 'tvShow',
  tvsn: 'tvSeason',
  tves: 'tvEpisode',
  sosn: 'tvShowSort',
  tven: 'tvEpisodeId',
  tvnn: 'tvNetwork',
  pcst: 'podcast',
  purl: 'podcasturl',
  '----:com.apple.iTunes:MusicBrainz Album Status': 'releasestatus',
  '----:com.apple.iTunes:MusicBrainz Album Type': 'releasetype',
  '----:com.apple.iTunes:MusicBrainz Album Release Country': 'releasecountry',
  '----:com.apple.iTunes:SCRIPT': 'script',
  '----:com.apple.iTunes:LANGUAGE': 'language',
  cprt: 'copyright',
  '©cpy': 'copyright',
  '----:com.apple.iTunes:LICENSE': 'license',
  '©too': 'encodedby',
  pgap: 'gapless',
  '----:com.apple.iTunes:BARCODE': 'barcode',
  '----:com.apple.iTunes:ISRC': 'isrc',
  '----:com.apple.iTunes:ASIN': 'asin',
  '----:com.apple.iTunes:NOTES': 'comment',
  '----:com.apple.iTunes:MusicBrainz Track Id': 'musicbrainz_recordingid',
  '----:com.apple.iTunes:MusicBrainz Release Track Id': 'musicbrainz_trackid',
  '----:com.apple.iTunes:MusicBrainz Album Id': 'musicbrainz_albumid',
  '----:com.apple.iTunes:MusicBrainz Artist Id': 'musicbrainz_artistid',
  '----:com.apple.iTunes:MusicBrainz Album Artist Id': 'musicbrainz_albumartistid',
  '----:com.apple.iTunes:MusicBrainz Release Group Id': 'musicbrainz_releasegroupid',
  '----:com.apple.iTunes:MusicBrainz Work Id': 'musicbrainz_workid',
  '----:com.apple.iTunes:MusicBrainz TRM Id': 'musicbrainz_trmid',
  '----:com.apple.iTunes:MusicBrainz Disc Id': 'musicbrainz_discid',
  '----:com.apple.iTunes:Acoustid Id': 'acoustid_id',
  '----:com.apple.iTunes:Acoustid Fingerprint': 'acoustid_fingerprint',
  '----:com.apple.iTunes:MusicIP PUID': 'musicip_puid',
  '----:com.apple.iTunes:fingerprint': 'musicip_fingerprint',
  '----:com.apple.iTunes:replaygain_track_gain': 'replaygain_track_gain',
  '----:com.apple.iTunes:replaygain_track_peak': 'replaygain_track_peak',
  '----:com.apple.iTunes:replaygain_album_gain': 'replaygain_album_gain',
  '----:com.apple.iTunes:replaygain_album_peak': 'replaygain_album_peak',
  '----:com.apple.iTunes:replaygain_track_minmax': 'replaygain_track_minmax',
  '----:com.apple.iTunes:replaygain_album_minmax': 'replaygain_album_minmax',
  '----:com.apple.iTunes:replaygain_undo': 'replaygain_undo',
  // Additional mappings:
  gnre: 'genre',
  '----:com.apple.iTunes:ALBUMARTISTSORT': 'albumartistsort',
  '----:com.apple.iTunes:ARTISTS': 'artists',
  '----:com.apple.iTunes:ORIGINALDATE': 'originaldate',
  '----:com.apple.iTunes:ORIGINALYEAR': 'originalyear',
  // '----:com.apple.iTunes:PERFORMER': 'performer'
  desc: 'description',
  ldes: 'longDescription',
  '©mvn': 'movement',
  '©mvi': 'movementIndex',
  '©mvc': 'movementTotal',
  '©wrk': 'work',
  catg: 'category',
  egid: 'podcastId',
  hdvd: 'hdVideo',
  keyw: 'keywords',
  shwm: 'showMovement',
  stik: 'stik'
};
exports.tagType = 'iTunes';
var MP4TagMapper = /*#__PURE__*/function (_CaseInsensitiveTagMa) {
  _inherits(MP4TagMapper, _CaseInsensitiveTagMa);
  var _super = _createSuper(MP4TagMapper);
  function MP4TagMapper() {
    _classCallCheck(this, MP4TagMapper);
    return _super.call(this, [exports.tagType], mp4TagMap);
  }
  return _createClass(MP4TagMapper);
}(CaseInsensitiveTagMap_1.CaseInsensitiveTagMap);
exports.MP4TagMapper = MP4TagMapper;
},{"../common/CaseInsensitiveTagMap":"node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js"}],"node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VorbisTagMapper = void 0;
var GenericTagMapper_1 = require("../../common/GenericTagMapper");
/**
 * Vorbis tag mappings
 *
 * Mapping from native header format to one or possibly more 'common' entries
 * The common entries aim to read the same information from different media files
 * independent of the underlying format
 */
var vorbisTagMap = {
  TITLE: 'title',
  ARTIST: 'artist',
  ARTISTS: 'artists',
  ALBUMARTIST: 'albumartist',
  'ALBUM ARTIST': 'albumartist',
  ALBUM: 'album',
  DATE: 'date',
  ORIGINALDATE: 'originaldate',
  ORIGINALYEAR: 'originalyear',
  COMMENT: 'comment',
  TRACKNUMBER: 'track',
  DISCNUMBER: 'disk',
  GENRE: 'genre',
  METADATA_BLOCK_PICTURE: 'picture',
  COMPOSER: 'composer',
  LYRICS: 'lyrics',
  ALBUMSORT: 'albumsort',
  TITLESORT: 'titlesort',
  WORK: 'work',
  ARTISTSORT: 'artistsort',
  ALBUMARTISTSORT: 'albumartistsort',
  COMPOSERSORT: 'composersort',
  LYRICIST: 'lyricist',
  WRITER: 'writer',
  CONDUCTOR: 'conductor',
  // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo
  REMIXER: 'remixer',
  ARRANGER: 'arranger',
  ENGINEER: 'engineer',
  PRODUCER: 'producer',
  DJMIXER: 'djmixer',
  MIXER: 'mixer',
  LABEL: 'label',
  GROUPING: 'grouping',
  SUBTITLE: 'subtitle',
  DISCSUBTITLE: 'discsubtitle',
  TRACKTOTAL: 'totaltracks',
  DISCTOTAL: 'totaldiscs',
  COMPILATION: 'compilation',
  RATING: 'rating',
  BPM: 'bpm',
  KEY: 'key',
  MOOD: 'mood',
  MEDIA: 'media',
  CATALOGNUMBER: 'catalognumber',
  RELEASESTATUS: 'releasestatus',
  RELEASETYPE: 'releasetype',
  RELEASECOUNTRY: 'releasecountry',
  SCRIPT: 'script',
  LANGUAGE: 'language',
  COPYRIGHT: 'copyright',
  LICENSE: 'license',
  ENCODEDBY: 'encodedby',
  ENCODERSETTINGS: 'encodersettings',
  BARCODE: 'barcode',
  ISRC: 'isrc',
  ASIN: 'asin',
  MUSICBRAINZ_TRACKID: 'musicbrainz_recordingid',
  MUSICBRAINZ_RELEASETRACKID: 'musicbrainz_trackid',
  MUSICBRAINZ_ALBUMID: 'musicbrainz_albumid',
  MUSICBRAINZ_ARTISTID: 'musicbrainz_artistid',
  MUSICBRAINZ_ALBUMARTISTID: 'musicbrainz_albumartistid',
  MUSICBRAINZ_RELEASEGROUPID: 'musicbrainz_releasegroupid',
  MUSICBRAINZ_WORKID: 'musicbrainz_workid',
  MUSICBRAINZ_TRMID: 'musicbrainz_trmid',
  MUSICBRAINZ_DISCID: 'musicbrainz_discid',
  ACOUSTID_ID: 'acoustid_id',
  ACOUSTID_ID_FINGERPRINT: 'acoustid_fingerprint',
  MUSICIP_PUID: 'musicip_puid',
  // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo
  WEBSITE: 'website',
  NOTES: 'notes',
  TOTALTRACKS: 'totaltracks',
  TOTALDISCS: 'totaldiscs',
  // Discogs
  DISCOGS_ARTIST_ID: 'discogs_artist_id',
  DISCOGS_ARTISTS: 'artists',
  DISCOGS_ARTIST_NAME: 'artists',
  DISCOGS_ALBUM_ARTISTS: 'albumartist',
  DISCOGS_CATALOG: 'catalognumber',
  DISCOGS_COUNTRY: 'releasecountry',
  DISCOGS_DATE: 'originaldate',
  DISCOGS_LABEL: 'label',
  DISCOGS_LABEL_ID: 'discogs_label_id',
  DISCOGS_MASTER_RELEASE_ID: 'discogs_master_release_id',
  DISCOGS_RATING: 'discogs_rating',
  DISCOGS_RELEASED: 'date',
  DISCOGS_RELEASE_ID: 'discogs_release_id',
  DISCOGS_VOTES: 'discogs_votes',
  CATALOGID: 'catalognumber',
  STYLE: 'genre',
  //
  REPLAYGAIN_TRACK_GAIN: 'replaygain_track_gain',
  REPLAYGAIN_TRACK_PEAK: 'replaygain_track_peak',
  REPLAYGAIN_ALBUM_GAIN: 'replaygain_album_gain',
  REPLAYGAIN_ALBUM_PEAK: 'replaygain_album_peak',
  // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
  REPLAYGAIN_MINMAX: 'replaygain_track_minmax',
  REPLAYGAIN_ALBUM_MINMAX: 'replaygain_album_minmax',
  REPLAYGAIN_UNDO: 'replaygain_undo'
};
var VorbisTagMapper = /*#__PURE__*/function (_GenericTagMapper_1$C) {
  _inherits(VorbisTagMapper, _GenericTagMapper_1$C);
  var _super = _createSuper(VorbisTagMapper);
  function VorbisTagMapper() {
    _classCallCheck(this, VorbisTagMapper);
    return _super.call(this, ['vorbis'], vorbisTagMap);
  }
  _createClass(VorbisTagMapper, [{
    key: "postMap",
    value: function postMap(tag) {
      if (tag.id.indexOf('RATING:') === 0) {
        var keys = tag.id.split(':');
        tag.value = VorbisTagMapper.toRating(keys[1], tag.value);
        tag.id = keys[0];
      }
    }
  }], [{
    key: "toRating",
    value: function toRating(email, rating) {
      return {
        source: email ? email.toLowerCase() : email,
        rating: parseFloat(rating) * GenericTagMapper_1.CommonTagMapper.maxRatingScore
      };
    }
  }]);
  return VorbisTagMapper;
}(GenericTagMapper_1.CommonTagMapper);
exports.VorbisTagMapper = VorbisTagMapper;
},{"../../common/GenericTagMapper":"node_modules/music-metadata/lib/common/GenericTagMapper.js"}],"node_modules/music-metadata/lib/riff/RiffInfoTagMap.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RiffInfoTagMapper = exports.riffInfoTagMap = void 0;
var GenericTagMapper_1 = require("../common/GenericTagMapper");
/**
 * RIFF Info Tags; part of the EXIF 2.3
 * Ref: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/RIFF.html#Info
 */
exports.riffInfoTagMap = {
  IART: 'artist',
  ICRD: 'date',
  INAM: 'title',
  TITL: 'title',
  IPRD: 'album',
  ITRK: 'track',
  IPRT: 'track',
  COMM: 'comment',
  ICMT: 'comment',
  ICNT: 'releasecountry',
  GNRE: 'genre',
  IWRI: 'writer',
  RATE: 'rating',
  YEAR: 'year',
  ISFT: 'encodedby',
  CODE: 'encodedby',
  TURL: 'website',
  IGNR: 'genre',
  IENG: 'engineer',
  ITCH: 'technician',
  IMED: 'media',
  IRPD: 'album' // Product, where the file was intended for
};
var RiffInfoTagMapper = /*#__PURE__*/function (_GenericTagMapper_1$C) {
  _inherits(RiffInfoTagMapper, _GenericTagMapper_1$C);
  var _super = _createSuper(RiffInfoTagMapper);
  function RiffInfoTagMapper() {
    _classCallCheck(this, RiffInfoTagMapper);
    return _super.call(this, ['exif'], exports.riffInfoTagMap);
  }
  return _createClass(RiffInfoTagMapper);
}(GenericTagMapper_1.CommonTagMapper);
exports.RiffInfoTagMapper = RiffInfoTagMapper;
},{"../common/GenericTagMapper":"node_modules/music-metadata/lib/common/GenericTagMapper.js"}],"node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MatroskaTagMapper = void 0;
var CaseInsensitiveTagMap_1 = require("../common/CaseInsensitiveTagMap");
/**
 * EBML Tag map
 */
var ebmlTagMap = {
  'segment:title': 'title',
  'album:ARTIST': 'albumartist',
  'album:ARTISTSORT': 'albumartistsort',
  'album:TITLE': 'album',
  'album:DATE_RECORDED': 'originaldate',
  'album:PART_NUMBER': 'disk',
  'album:TOTAL_PARTS': 'totaltracks',
  'track:ARTIST': 'artist',
  'track:ARTISTSORT': 'artistsort',
  'track:TITLE': 'title',
  'track:PART_NUMBER': 'track',
  'track:MUSICBRAINZ_TRACKID': 'musicbrainz_recordingid',
  'track:MUSICBRAINZ_ALBUMID': 'musicbrainz_albumid',
  'track:MUSICBRAINZ_ARTISTID': 'musicbrainz_artistid',
  'track:PUBLISHER': 'label',
  'track:GENRE': 'genre',
  'track:ENCODER': 'encodedby',
  'track:ENCODER_OPTIONS': 'encodersettings',
  'edition:TOTAL_PARTS': 'totaldiscs',
  picture: 'picture'
};
var MatroskaTagMapper = /*#__PURE__*/function (_CaseInsensitiveTagMa) {
  _inherits(MatroskaTagMapper, _CaseInsensitiveTagMa);
  var _super = _createSuper(MatroskaTagMapper);
  function MatroskaTagMapper() {
    _classCallCheck(this, MatroskaTagMapper);
    return _super.call(this, ['matroska'], ebmlTagMap);
  }
  return _createClass(MatroskaTagMapper);
}(CaseInsensitiveTagMap_1.CaseInsensitiveTagMap);
exports.MatroskaTagMapper = MatroskaTagMapper;
},{"../common/CaseInsensitiveTagMap":"node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js"}],"node_modules/music-metadata/lib/aiff/AiffTagMap.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AiffTagMapper = void 0;
var GenericTagMapper_1 = require("../common/GenericTagMapper");
/**
 * ID3v1 tag mappings
 */
var tagMap = {
  NAME: 'title',
  AUTH: 'artist',
  '(c) ': 'copyright',
  ANNO: 'comment'
};
var AiffTagMapper = /*#__PURE__*/function (_GenericTagMapper_1$C) {
  _inherits(AiffTagMapper, _GenericTagMapper_1$C);
  var _super = _createSuper(AiffTagMapper);
  function AiffTagMapper() {
    _classCallCheck(this, AiffTagMapper);
    return _super.call(this, ['AIFF'], tagMap);
  }
  return _createClass(AiffTagMapper);
}(GenericTagMapper_1.CommonTagMapper);
exports.AiffTagMapper = AiffTagMapper;
},{"../common/GenericTagMapper":"node_modules/music-metadata/lib/common/GenericTagMapper.js"}],"node_modules/music-metadata/lib/common/CombinedTagMapper.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CombinedTagMapper = void 0;
var ID3v1TagMap_1 = require("../id3v1/ID3v1TagMap");
var ID3v24TagMapper_1 = require("../id3v2/ID3v24TagMapper");
var AsfTagMapper_1 = require("../asf/AsfTagMapper");
var ID3v22TagMapper_1 = require("../id3v2/ID3v22TagMapper");
var APEv2TagMapper_1 = require("../apev2/APEv2TagMapper");
var MP4TagMapper_1 = require("../mp4/MP4TagMapper");
var VorbisTagMapper_1 = require("../ogg/vorbis/VorbisTagMapper");
var RiffInfoTagMap_1 = require("../riff/RiffInfoTagMap");
var MatroskaTagMapper_1 = require("../matroska/MatroskaTagMapper");
var AiffTagMap_1 = require("../aiff/AiffTagMap");
var CombinedTagMapper = /*#__PURE__*/function () {
  function CombinedTagMapper() {
    var _this = this;
    _classCallCheck(this, CombinedTagMapper);
    this.tagMappers = {};
    [new ID3v1TagMap_1.ID3v1TagMapper(), new ID3v22TagMapper_1.ID3v22TagMapper(), new ID3v24TagMapper_1.ID3v24TagMapper(), new MP4TagMapper_1.MP4TagMapper(), new MP4TagMapper_1.MP4TagMapper(), new VorbisTagMapper_1.VorbisTagMapper(), new APEv2TagMapper_1.APEv2TagMapper(), new AsfTagMapper_1.AsfTagMapper(), new RiffInfoTagMap_1.RiffInfoTagMapper(), new MatroskaTagMapper_1.MatroskaTagMapper(), new AiffTagMap_1.AiffTagMapper()].forEach(function (mapper) {
      _this.registerTagMapper(mapper);
    });
  }
  /**
   * Convert native to generic (common) tags
   * @param tagType Originating tag format
   * @param tag     Native tag to map to a generic tag id
   * @param warnings
   * @return Generic tag result (output of this function)
   */
  _createClass(CombinedTagMapper, [{
    key: "mapTag",
    value: function mapTag(tagType, tag, warnings) {
      var tagMapper = this.tagMappers[tagType];
      if (tagMapper) {
        return this.tagMappers[tagType].mapGenericTag(tag, warnings);
      }
      throw new Error('No generic tag mapper defined for tag-format: ' + tagType);
    }
  }, {
    key: "registerTagMapper",
    value: function registerTagMapper(genericTagMapper) {
      var _iterator = _createForOfIteratorHelper(genericTagMapper.tagTypes),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tagType = _step.value;
          this.tagMappers[tagType] = genericTagMapper;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);
  return CombinedTagMapper;
}();
exports.CombinedTagMapper = CombinedTagMapper;
},{"../id3v1/ID3v1TagMap":"node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js","../id3v2/ID3v24TagMapper":"node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js","../asf/AsfTagMapper":"node_modules/music-metadata/lib/asf/AsfTagMapper.js","../id3v2/ID3v22TagMapper":"node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js","../apev2/APEv2TagMapper":"node_modules/music-metadata/lib/apev2/APEv2TagMapper.js","../mp4/MP4TagMapper":"node_modules/music-metadata/lib/mp4/MP4TagMapper.js","../ogg/vorbis/VorbisTagMapper":"node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js","../riff/RiffInfoTagMap":"node_modules/music-metadata/lib/riff/RiffInfoTagMap.js","../matroska/MatroskaTagMapper":"node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js","../aiff/AiffTagMap":"node_modules/music-metadata/lib/aiff/AiffTagMap.js"}],"node_modules/music-metadata/lib/common/MetadataCollector.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.joinArtists = exports.MetadataCollector = void 0;
var type_1 = require("../type");
var debug_1 = require("debug");
var GenericTagTypes_1 = require("./GenericTagTypes");
var CombinedTagMapper_1 = require("./CombinedTagMapper");
var GenericTagMapper_1 = require("./GenericTagMapper");
var Util_1 = require("./Util");
var FileType = require("file-type/core");
var debug = (0, debug_1.default)('music-metadata:collector');
var TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'AIFF', 'ID3v1'];
/**
 * Provided to the parser to uodate the metadata result.
 * Responsible for triggering async updates
 */
var MetadataCollector = /*#__PURE__*/function () {
  function MetadataCollector(opts) {
    _classCallCheck(this, MetadataCollector);
    this.opts = opts;
    this.format = {
      tagTypes: [],
      trackInfo: []
    };
    this.native = {};
    this.common = {
      track: {
        no: null,
        of: null
      },
      disk: {
        no: null,
        of: null
      },
      movementIndex: {}
    };
    this.quality = {
      warnings: []
    };
    /**
     * Keeps track of origin priority for each mapped id
     */
    this.commonOrigin = {};
    /**
     * Maps a tag type to a priority
     */
    this.originPriority = {};
    this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();
    var priority = 1;
    var _iterator = _createForOfIteratorHelper(TagPriority),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var tagType = _step.value;
        this.originPriority[tagType] = priority++;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    this.originPriority.artificial = 500; // Filled using alternative tags
    this.originPriority.id3v1 = 600; // Consider as the worst because of the field length limit
  }
  /**
   * @returns {boolean} true if one or more tags have been found
   */
  _createClass(MetadataCollector, [{
    key: "hasAny",
    value: function hasAny() {
      return Object.keys(this.native).length > 0;
    }
  }, {
    key: "addStreamInfo",
    value: function addStreamInfo(streamInfo) {
      debug("streamInfo: type=".concat(type_1.TrackType[streamInfo.type], ", codec=").concat(streamInfo.codecName));
      this.format.trackInfo.push(streamInfo);
    }
  }, {
    key: "setFormat",
    value: function setFormat(key, value) {
      debug("format: ".concat(key, " = ").concat(value));
      this.format[key] = value; // as any to override readonly
      if (this.opts.observer) {
        this.opts.observer({
          metadata: this,
          tag: {
            type: 'format',
            id: key,
            value: value
          }
        });
      }
    }
  }, {
    key: "addTag",
    value: function addTag(tagType, tagId, value) {
      debug("tag ".concat(tagType, ".").concat(tagId, " = ").concat(value));
      if (!this.native[tagType]) {
        this.format.tagTypes.push(tagType);
        this.native[tagType] = [];
      }
      this.native[tagType].push({
        id: tagId,
        value: value
      });
      this.toCommon(tagType, tagId, value);
    }
  }, {
    key: "addWarning",
    value: function addWarning(warning) {
      this.quality.warnings.push({
        message: warning
      });
    }
  }, {
    key: "postMap",
    value: function postMap(tagType, tag) {
      var _this = this;
      // Common tag (alias) found
      // check if we need to do something special with common tag
      // if the event has been aliased then we need to clean it before
      // it is emitted to the user. e.g. genre (20) -> Electronic
      switch (tag.id) {
        case 'artist':
          if (this.commonOrigin.artist === this.originPriority[tagType]) {
            // Assume the artist field is used as artists
            return this.postMap('artificial', {
              id: 'artists',
              value: tag.value
            });
          }
          if (!this.common.artists) {
            // Fill artists using artist source
            this.setGenericTag('artificial', {
              id: 'artists',
              value: tag.value
            });
          }
          break;
        case 'artists':
          if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
            if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {
              // Fill artist using artists source
              var artists = (this.common.artists || []).concat([tag.value]);
              var value = joinArtists(artists);
              var artistTag = {
                id: 'artist',
                value: value
              };
              this.setGenericTag('artificial', artistTag);
            }
          }
          break;
        case 'picture':
          this.postFixPicture(tag.value).then(function (picture) {
            if (picture !== null) {
              tag.value = picture;
              _this.setGenericTag(tagType, tag);
            }
          });
          return;
        case 'totaltracks':
          this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
          return;
        case 'totaldiscs':
          this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
          return;
        case 'movementTotal':
          this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
          return;
        case 'track':
        case 'disk':
        case 'movementIndex':
          var of = this.common[tag.id].of; // store of value, maybe maybe overwritten
          this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);
          this.common[tag.id].of = of != null ? of : this.common[tag.id].of;
          return;
        case 'bpm':
        case 'year':
        case 'originalyear':
          tag.value = parseInt(tag.value, 10);
          break;
        case 'date':
          // ToDo: be more strict on 'YYYY...'
          var year = parseInt(tag.value.substr(0, 4), 10);
          if (!isNaN(year)) {
            this.common.year = year;
          }
          break;
        case 'discogs_label_id':
        case 'discogs_release_id':
        case 'discogs_master_release_id':
        case 'discogs_artist_id':
        case 'discogs_votes':
          tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;
          break;
        case 'replaygain_track_gain':
        case 'replaygain_track_peak':
        case 'replaygain_album_gain':
        case 'replaygain_album_peak':
          tag.value = (0, Util_1.toRatio)(tag.value);
          break;
        case 'replaygain_track_minmax':
          tag.value = tag.value.split(',').map(function (v) {
            return parseInt(v, 10);
          });
          break;
        case 'replaygain_undo':
          var minMix = tag.value.split(',').map(function (v) {
            return parseInt(v, 10);
          });
          tag.value = {
            leftChannel: minMix[0],
            rightChannel: minMix[1]
          };
          break;
        case 'gapless': // iTunes gap-less flag
        case 'compilation':
        case 'podcast':
        case 'showMovement':
          tag.value = tag.value === '1' || tag.value === 1; // boolean
          break;
        case 'isrc':
          // Only keep unique values
          if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1) return;
          break;
        default:
        // nothing to do
      }

      if (tag.value !== null) {
        this.setGenericTag(tagType, tag);
      }
    }
    /**
     * Convert native tags to common tags
     * @returns {IAudioMetadata} Native + common tags
     */
  }, {
    key: "toCommonMetadata",
    value: function toCommonMetadata() {
      return {
        format: this.format,
        native: this.native,
        quality: this.quality,
        common: this.common
      };
    }
    /**
     * Fix some common issues with picture object
     * @param picture Picture
     */
  }, {
    key: "postFixPicture",
    value: function () {
      var _postFixPicture = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(picture) {
        var fileType;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(picture.data && picture.data.length > 0)) {
                _context.next = 13;
                break;
              }
              if (picture.format) {
                _context.next = 10;
                break;
              }
              _context.next = 4;
              return FileType.fromBuffer(picture.data);
            case 4:
              fileType = _context.sent;
              if (!fileType) {
                _context.next = 9;
                break;
              }
              picture.format = fileType.mime;
              _context.next = 10;
              break;
            case 9:
              return _context.abrupt("return", null);
            case 10:
              picture.format = picture.format.toLocaleLowerCase();
              switch (picture.format) {
                case 'image/jpg':
                  picture.format = 'image/jpeg';
                // ToDo: register warning
              }
              return _context.abrupt("return", picture);
            case 13:
              this.addWarning("Empty picture tag found");
              return _context.abrupt("return", null);
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function postFixPicture(_x) {
        return _postFixPicture.apply(this, arguments);
      }
      return postFixPicture;
    }()
    /**
     * Convert native tag to common tags
     */
  }, {
    key: "toCommon",
    value: function toCommon(tagType, tagId, value) {
      var tag = {
        id: tagId,
        value: value
      };
      var genericTag = this.tagMapper.mapTag(tagType, tag, this);
      if (genericTag) {
        this.postMap(tagType, genericTag);
      }
    }
    /**
     * Set generic tag
     */
  }, {
    key: "setGenericTag",
    value: function setGenericTag(tagType, tag) {
      debug("common.".concat(tag.id, " = ").concat(tag.value));
      var prio0 = this.commonOrigin[tag.id] || 1000;
      var prio1 = this.originPriority[tagType];
      if ((0, GenericTagTypes_1.isSingleton)(tag.id)) {
        if (prio1 <= prio0) {
          this.common[tag.id] = tag.value;
          this.commonOrigin[tag.id] = prio1;
        } else {
          return debug("Ignore native tag (singleton): ".concat(tagType, ".").concat(tag.id, " = ").concat(tag.value));
        }
      } else {
        if (prio1 === prio0) {
          if (!(0, GenericTagTypes_1.isUnique)(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {
            this.common[tag.id].push(tag.value);
          } else {
            debug("Ignore duplicate value: ".concat(tagType, ".").concat(tag.id, " = ").concat(tag.value));
          }
          // no effect? this.commonOrigin[tag.id] = prio1;
        } else if (prio1 < prio0) {
          this.common[tag.id] = [tag.value];
          this.commonOrigin[tag.id] = prio1;
        } else {
          return debug("Ignore native tag (list): ".concat(tagType, ".").concat(tag.id, " = ").concat(tag.value));
        }
      }
      if (this.opts.observer) {
        this.opts.observer({
          metadata: this,
          tag: {
            type: 'common',
            id: tag.id,
            value: tag.value
          }
        });
      }
      // ToDo: trigger metadata event
    }
  }]);
  return MetadataCollector;
}();
exports.MetadataCollector = MetadataCollector;
function joinArtists(artists) {
  if (artists.length > 2) {
    return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];
  }
  return artists.join(' & ');
}
exports.joinArtists = joinArtists;
},{"../type":"node_modules/music-metadata/lib/type.js","debug":"node_modules/debug/src/browser.js","./GenericTagTypes":"node_modules/music-metadata/lib/common/GenericTagTypes.js","./CombinedTagMapper":"node_modules/music-metadata/lib/common/CombinedTagMapper.js","./GenericTagMapper":"node_modules/music-metadata/lib/common/GenericTagMapper.js","./Util":"node_modules/music-metadata/lib/common/Util.js","file-type/core":"node_modules/file-type/core.js"}],"node_modules/music-metadata/lib/id3v2/ID3v2Token.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextEncodingToken = exports.ExtendedHeader = exports.ID3v2Header = exports.UINT32SYNCSAFE = exports.AttachedPictureType = void 0;
var Token = require("token-types");
var util = require("../common/Util");
/**
 * The picture type according to the ID3v2 APIC frame
 * Ref: http://id3.org/id3v2.3.0#Attached_picture
 */
var AttachedPictureType;
(function (AttachedPictureType) {
  AttachedPictureType[AttachedPictureType["Other"] = 0] = "Other";
  AttachedPictureType[AttachedPictureType["32x32 pixels 'file icon' (PNG only)"] = 1] = "32x32 pixels 'file icon' (PNG only)";
  AttachedPictureType[AttachedPictureType["Other file icon"] = 2] = "Other file icon";
  AttachedPictureType[AttachedPictureType["Cover (front)"] = 3] = "Cover (front)";
  AttachedPictureType[AttachedPictureType["Cover (back)"] = 4] = "Cover (back)";
  AttachedPictureType[AttachedPictureType["Leaflet page"] = 5] = "Leaflet page";
  AttachedPictureType[AttachedPictureType["Media (e.g. label side of CD)"] = 6] = "Media (e.g. label side of CD)";
  AttachedPictureType[AttachedPictureType["Lead artist/lead performer/soloist"] = 7] = "Lead artist/lead performer/soloist";
  AttachedPictureType[AttachedPictureType["Artist/performer"] = 8] = "Artist/performer";
  AttachedPictureType[AttachedPictureType["Conductor"] = 9] = "Conductor";
  AttachedPictureType[AttachedPictureType["Band/Orchestra"] = 10] = "Band/Orchestra";
  AttachedPictureType[AttachedPictureType["Composer"] = 11] = "Composer";
  AttachedPictureType[AttachedPictureType["Lyricist/text writer"] = 12] = "Lyricist/text writer";
  AttachedPictureType[AttachedPictureType["Recording Location"] = 13] = "Recording Location";
  AttachedPictureType[AttachedPictureType["During recording"] = 14] = "During recording";
  AttachedPictureType[AttachedPictureType["During performance"] = 15] = "During performance";
  AttachedPictureType[AttachedPictureType["Movie/video screen capture"] = 16] = "Movie/video screen capture";
  AttachedPictureType[AttachedPictureType["A bright coloured fish"] = 17] = "A bright coloured fish";
  AttachedPictureType[AttachedPictureType["Illustration"] = 18] = "Illustration";
  AttachedPictureType[AttachedPictureType["Band/artist logotype"] = 19] = "Band/artist logotype";
  AttachedPictureType[AttachedPictureType["Publisher/Studio logotype"] = 20] = "Publisher/Studio logotype";
})(AttachedPictureType = exports.AttachedPictureType || (exports.AttachedPictureType = {}));
/**
 * 28 bits (representing up to 256MB) integer, the msb is 0 to avoid 'false syncsignals'.
 * 4 * %0xxxxxxx
 */
exports.UINT32SYNCSAFE = {
  get: function get(buf, off) {
    return buf[off + 3] & 0x7f | buf[off + 2] << 7 | buf[off + 1] << 14 | buf[off] << 21;
  },
  len: 4
};
/**
 * ID3v2 header
 * Ref: http://id3.org/id3v2.3.0#ID3v2_header
 * ToDo
 */
exports.ID3v2Header = {
  len: 10,
  get: function get(buf, off) {
    return {
      // ID3v2/file identifier   "ID3"
      fileIdentifier: new Token.StringType(3, 'ascii').get(buf, off),
      // ID3v2 versionIndex
      version: {
        major: Token.INT8.get(buf, off + 3),
        revision: Token.INT8.get(buf, off + 4)
      },
      // ID3v2 flags
      flags: {
        // Unsynchronisation
        unsynchronisation: util.getBit(buf, off + 5, 7),
        // Extended header
        isExtendedHeader: util.getBit(buf, off + 5, 6),
        // Experimental indicator
        expIndicator: util.getBit(buf, off + 5, 5),
        footer: util.getBit(buf, off + 5, 4)
      },
      size: exports.UINT32SYNCSAFE.get(buf, off + 6)
    };
  }
};
exports.ExtendedHeader = {
  len: 10,
  get: function get(buf, off) {
    return {
      // Extended header size
      size: Token.UINT32_BE.get(buf, off),
      // Extended Flags
      extendedFlags: Token.UINT16_BE.get(buf, off + 4),
      // Size of padding
      sizeOfPadding: Token.UINT32_BE.get(buf, off + 6),
      // CRC data present
      crcDataPresent: util.getBit(buf, off + 4, 31)
    };
  }
};
exports.TextEncodingToken = {
  len: 1,
  get: function get(uint8Array, off) {
    switch (uint8Array[off]) {
      case 0x00:
        return {
          encoding: 'latin1'
        };
      // binary
      case 0x01:
        return {
          encoding: 'utf16le',
          bom: true
        };
      case 0x02:
        return {
          encoding: 'utf16le',
          bom: false
        };
      case 0x03:
        return {
          encoding: 'utf8',
          bom: false
        };
      default:
        return {
          encoding: 'utf8',
          bom: false
        };
    }
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js"}],"node_modules/music-metadata/lib/common/BasicParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BasicParser = void 0;
var BasicParser = /*#__PURE__*/function () {
  function BasicParser() {
    _classCallCheck(this, BasicParser);
  }
  _createClass(BasicParser, [{
    key: "init",
    value:
    /**
     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
     * @param {INativeMetadataCollector} metadata Output
     * @param {ITokenizer} tokenizer Input
     * @param {IOptions} options Parsing options
     */
    function init(metadata, tokenizer, options) {
      this.metadata = metadata;
      this.tokenizer = tokenizer;
      this.options = options;
      return this;
    }
  }]);
  return BasicParser;
}();
exports.BasicParser = BasicParser;
},{}],"node_modules/music-metadata/lib/common/FourCC.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FourCcToken = void 0;
var util = require("./Util");
var validFourCC = /^[\x21-\x7e©][\x20-\x7e\x00()]{3}/;
/**
 * Token for read FourCC
 * Ref: https://en.wikipedia.org/wiki/FourCC
 */
exports.FourCcToken = {
  len: 4,
  get: function get(buf, off) {
    var id = buf.toString('binary', off, off + exports.FourCcToken.len);
    if (!id.match(validFourCC)) {
      throw new Error("FourCC contains invalid characters: ".concat(util.a2hex(id), " \"").concat(id, "\""));
    }
    return id;
  },
  put: function put(buffer, offset, id) {
    var str = Buffer.from(id, 'binary');
    if (str.length !== 4) throw new Error('Invalid length');
    return str.copy(buffer, offset);
  }
};
},{"./Util":"node_modules/music-metadata/lib/common/Util.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/apev2/APEv2Token.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBitSet = exports.parseTagFlags = exports.TagField = exports.TagItemHeader = exports.TagFooter = exports.Header = exports.DescriptorParser = exports.DataType = void 0;
var Token = require("token-types");
var FourCC_1 = require("../common/FourCC");
var DataType;
(function (DataType) {
  DataType[DataType["text_utf8"] = 0] = "text_utf8";
  DataType[DataType["binary"] = 1] = "binary";
  DataType[DataType["external_info"] = 2] = "external_info";
  DataType[DataType["reserved"] = 3] = "reserved";
})(DataType = exports.DataType || (exports.DataType = {}));
/**
 * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum
 */
exports.DescriptorParser = {
  len: 52,
  get: function get(buf, off) {
    return {
      // should equal 'MAC '
      ID: FourCC_1.FourCcToken.get(buf, off),
      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
      version: Token.UINT32_LE.get(buf, off + 4) / 1000,
      // the number of descriptor bytes (allows later expansion of this header)
      descriptorBytes: Token.UINT32_LE.get(buf, off + 8),
      // the number of header APE_HEADER bytes
      headerBytes: Token.UINT32_LE.get(buf, off + 12),
      // the number of header APE_HEADER bytes
      seekTableBytes: Token.UINT32_LE.get(buf, off + 16),
      // the number of header data bytes (from original file)
      headerDataBytes: Token.UINT32_LE.get(buf, off + 20),
      // the number of bytes of APE frame data
      apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),
      // the high order number of APE frame data bytes
      apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),
      // the terminating data of the file (not including tag data)
      terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),
      // the MD5 hash of the file (see notes for usage... it's a little tricky)
      fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)
    };
  }
};
/**
 * APE_HEADER: describes all of the necessary information about the APE file
 */
exports.Header = {
  len: 24,
  get: function get(buf, off) {
    return {
      // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
      compressionLevel: Token.UINT16_LE.get(buf, off),
      // any format flags (for future use)
      formatFlags: Token.UINT16_LE.get(buf, off + 2),
      // the number of audio blocks in one frame
      blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),
      // the number of audio blocks in the final frame
      finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),
      // the total number of frames
      totalFrames: Token.UINT32_LE.get(buf, off + 12),
      // the bits per sample (typically 16)
      bitsPerSample: Token.UINT16_LE.get(buf, off + 16),
      // the number of channels (1 or 2)
      channel: Token.UINT16_LE.get(buf, off + 18),
      // the sample rate (typically 44100)
      sampleRate: Token.UINT32_LE.get(buf, off + 20)
    };
  }
};
/**
 * APE Tag Header/Footer Version 2.0
 * TAG: describes all the properties of the file [optional]
 */
exports.TagFooter = {
  len: 32,
  get: function get(buf, off) {
    return {
      // should equal 'APETAGEX'
      ID: new Token.StringType(8, 'ascii').get(buf, off),
      // equals CURRENT_APE_TAG_VERSION
      version: Token.UINT32_LE.get(buf, off + 8),
      // the complete size of the tag, including this footer (excludes header)
      size: Token.UINT32_LE.get(buf, off + 12),
      // the number of fields in the tag
      fields: Token.UINT32_LE.get(buf, off + 16),
      // reserved for later use (must be zero),
      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))
    };
  }
};
/**
 * APE Tag v2.0 Item Header
 */
exports.TagItemHeader = {
  len: 8,
  get: function get(buf, off) {
    return {
      // Length of assigned value in bytes
      size: Token.UINT32_LE.get(buf, off),
      // reserved for later use (must be zero),
      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))
    };
  }
};
var TagField = function TagField(footer) {
  return new Token.Uint8ArrayType(footer.size - exports.TagFooter.len);
};
exports.TagField = TagField;
function parseTagFlags(flags) {
  return {
    containsHeader: isBitSet(flags, 31),
    containsFooter: isBitSet(flags, 30),
    isHeader: isBitSet(flags, 31),
    readOnly: isBitSet(flags, 0),
    dataType: (flags & 6) >> 1
  };
}
exports.parseTagFlags = parseTagFlags;
/**
 * @param num {number}
 * @param bit 0 is least significant bit (LSB)
 * @return {boolean} true if bit is 1; otherwise false
 */
function isBitSet(num, bit) {
  return (num & 1 << bit) !== 0;
}
exports.isBitSet = isBitSet;
},{"token-types":"node_modules/token-types/lib/index.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js"}],"node_modules/music-metadata/lib/apev2/APEv2Parser.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APEv2Parser = void 0;
var debug_1 = require("debug");
var strtok3 = require("strtok3/lib/core");
var token_types_1 = require("token-types");
var util = require("../common/Util");
var BasicParser_1 = require("../common/BasicParser");
var APEv2Token_1 = require("./APEv2Token");
var debug = (0, debug_1.default)('music-metadata:parser:APEv2');
var tagFormat = 'APEv2';
var preamble = 'APETAGEX';
var APEv2Parser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(APEv2Parser, _BasicParser_1$BasicP);
  var _super = _createSuper(APEv2Parser);
  function APEv2Parser() {
    var _this;
    _classCallCheck(this, APEv2Parser);
    _this = _super.apply(this, arguments);
    _this.ape = {};
    return _this;
  }
  _createClass(APEv2Parser, [{
    key: "tryParseApeHeader",
    value:
    /**
     * Parse APEv1 / APEv2 header if header signature found
     */
    function () {
      var _tryParseApeHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var footer, remaining, buffer;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len)) {
                _context.next = 3;
                break;
              }
              debug("No APEv2 header found, end-of-file reached");
              return _context.abrupt("return");
            case 3:
              _context.next = 5;
              return this.tokenizer.peekToken(APEv2Token_1.TagFooter);
            case 5:
              footer = _context.sent;
              if (!(footer.ID === preamble)) {
                _context.next = 12;
                break;
              }
              _context.next = 9;
              return this.tokenizer.ignore(APEv2Token_1.TagFooter.len);
            case 9:
              return _context.abrupt("return", this.parseTags(footer));
            case 12:
              debug("APEv2 header not found at offset=".concat(this.tokenizer.position));
              if (!this.tokenizer.fileInfo.size) {
                _context.next = 19;
                break;
              }
              // Try to read the APEv2 header using just the footer-header
              remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account
              buffer = Buffer.alloc(remaining);
              _context.next = 18;
              return this.tokenizer.readBuffer(buffer);
            case 18:
              return _context.abrupt("return", APEv2Parser.parseTagFooter(this.metadata, buffer, this.options));
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function tryParseApeHeader() {
        return _tryParseApeHeader.apply(this, arguments);
      }
      return tryParseApeHeader;
    }()
  }, {
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var descriptor, lenExp, header;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.tokenizer.readToken(APEv2Token_1.DescriptorParser);
            case 2:
              descriptor = _context2.sent;
              if (!(descriptor.ID !== 'MAC ')) {
                _context2.next = 5;
                break;
              }
              throw new Error('Unexpected descriptor ID');
            case 5:
              this.ape.descriptor = descriptor;
              lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;
              _context2.next = 9;
              return lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader();
            case 9:
              header = _context2.sent;
              _context2.next = 12;
              return this.tokenizer.ignore(header.forwardBytes);
            case 12:
              return _context2.abrupt("return", this.tryParseApeHeader());
            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "parseTags",
    value: function () {
      var _parseTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(footer) {
        var keyBuffer, bytesRemaining, i, tagItemHeader, zero, key, value, values, _iterator, _step, val, picData, description, data;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              keyBuffer = Buffer.alloc(256); // maximum tag key length
              bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;
              debug("Parse APE tags at offset=".concat(this.tokenizer.position, ", size=").concat(bytesRemaining));
              i = 0;
            case 4:
              if (!(i < footer.fields)) {
                _context3.next = 56;
                break;
              }
              if (!(bytesRemaining < APEv2Token_1.TagItemHeader.len)) {
                _context3.next = 8;
                break;
              }
              this.metadata.addWarning("APEv2 Tag-header: ".concat(footer.fields - i, " items remaining, but no more tag data to read."));
              return _context3.abrupt("break", 56);
            case 8:
              _context3.next = 10;
              return this.tokenizer.readToken(APEv2Token_1.TagItemHeader);
            case 10:
              tagItemHeader = _context3.sent;
              bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;
              _context3.next = 14;
              return this.tokenizer.peekBuffer(keyBuffer, {
                length: Math.min(keyBuffer.length, bytesRemaining)
              });
            case 14:
              zero = util.findZero(keyBuffer, 0, keyBuffer.length);
              _context3.next = 17;
              return this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));
            case 17:
              key = _context3.sent;
              _context3.next = 20;
              return this.tokenizer.ignore(1);
            case 20:
              bytesRemaining -= key.length + 1;
              _context3.t0 = tagItemHeader.flags.dataType;
              _context3.next = _context3.t0 === APEv2Token_1.DataType.text_utf8 ? 24 : _context3.t0 === APEv2Token_1.DataType.binary ? 31 : _context3.t0 === APEv2Token_1.DataType.external_info ? 44 : _context3.t0 === APEv2Token_1.DataType.reserved ? 48 : 53;
              break;
            case 24:
              _context3.next = 26;
              return this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));
            case 26:
              value = _context3.sent;
              values = value.split(/\x00/g);
              _iterator = _createForOfIteratorHelper(values);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  val = _step.value;
                  this.metadata.addTag(tagFormat, key, val);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return _context3.abrupt("break", 53);
            case 31:
              if (!this.options.skipCovers) {
                _context3.next = 36;
                break;
              }
              _context3.next = 34;
              return this.tokenizer.ignore(tagItemHeader.size);
            case 34:
              _context3.next = 43;
              break;
            case 36:
              picData = Buffer.alloc(tagItemHeader.size);
              _context3.next = 39;
              return this.tokenizer.readBuffer(picData);
            case 39:
              zero = util.findZero(picData, 0, picData.length);
              description = picData.toString('utf8', 0, zero);
              data = Buffer.from(picData.slice(zero + 1));
              this.metadata.addTag(tagFormat, key, {
                description: description,
                data: data
              });
            case 43:
              return _context3.abrupt("break", 53);
            case 44:
              debug("Ignore external info ".concat(key));
              _context3.next = 47;
              return this.tokenizer.ignore(tagItemHeader.size);
            case 47:
              return _context3.abrupt("break", 53);
            case 48:
              debug("Ignore external info ".concat(key));
              this.metadata.addWarning("APEv2 header declares a reserved datatype for \"".concat(key, "\""));
              _context3.next = 52;
              return this.tokenizer.ignore(tagItemHeader.size);
            case 52:
              return _context3.abrupt("break", 53);
            case 53:
              i++;
              _context3.next = 4;
              break;
            case 56:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function parseTags(_x) {
        return _parseTags.apply(this, arguments);
      }
      return parseTags;
    }()
  }, {
    key: "parseDescriptorExpansion",
    value: function () {
      var _parseDescriptorExpansion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(lenExp) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.tokenizer.ignore(lenExp);
            case 2:
              return _context4.abrupt("return", this.parseHeader());
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function parseDescriptorExpansion(_x2) {
        return _parseDescriptorExpansion.apply(this, arguments);
      }
      return parseDescriptorExpansion;
    }()
  }, {
    key: "parseHeader",
    value: function () {
      var _parseHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var header;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.tokenizer.readToken(APEv2Token_1.Header);
            case 2:
              header = _context5.sent;
              // ToDo before
              this.metadata.setFormat('lossless', true);
              this.metadata.setFormat('container', 'Monkey\'s Audio');
              this.metadata.setFormat('bitsPerSample', header.bitsPerSample);
              this.metadata.setFormat('sampleRate', header.sampleRate);
              this.metadata.setFormat('numberOfChannels', header.channel);
              this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));
              return _context5.abrupt("return", {
                forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
              });
            case 10:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function parseHeader() {
        return _parseHeader.apply(this, arguments);
      }
      return parseHeader;
    }()
  }], [{
    key: "tryParseApeHeader",
    value: function tryParseApeHeader(metadata, tokenizer, options) {
      var apeParser = new APEv2Parser();
      apeParser.init(metadata, tokenizer, options);
      return apeParser.tryParseApeHeader();
    }
    /**
     * Calculate the media file duration
     * @param ah ApeHeader
     * @return {number} duration in seconds
     */
  }, {
    key: "calculateDuration",
    value: function calculateDuration(ah) {
      var duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
      duration += ah.finalFrameBlocks;
      return duration / ah.sampleRate;
    }
    /**
     * Calculates the APEv1 / APEv2 first field offset
     * @param reader
     * @param offset
     */
  }, {
    key: "findApeFooterOffset",
    value: function () {
      var _findApeFooterOffset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(reader, offset) {
        var apeBuf, tagFooter;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              // Search for APE footer header at the end of the file
              apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);
              _context6.next = 3;
              return reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);
            case 3:
              tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);
              if (!(tagFooter.ID === 'APETAGEX')) {
                _context6.next = 7;
                break;
              }
              debug("APE footer header at offset=".concat(offset));
              return _context6.abrupt("return", {
                footer: tagFooter,
                offset: offset - tagFooter.size
              });
            case 7:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      function findApeFooterOffset(_x3, _x4) {
        return _findApeFooterOffset.apply(this, arguments);
      }
      return findApeFooterOffset;
    }()
  }, {
    key: "parseTagFooter",
    value: function parseTagFooter(metadata, buffer, options) {
      var footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);
      if (footer.ID !== preamble) throw new Error('Unexpected APEv2 Footer ID preamble value.');
      strtok3.fromBuffer(buffer);
      var apeParser = new APEv2Parser();
      apeParser.init(metadata, strtok3.fromBuffer(buffer), options);
      return apeParser.parseTags(footer);
    }
  }]);
  return APEv2Parser;
}(BasicParser_1.BasicParser);
exports.APEv2Parser = APEv2Parser;
},{"debug":"node_modules/debug/src/browser.js","strtok3/lib/core":"node_modules/strtok3/lib/core.js","token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","./APEv2Token":"node_modules/music-metadata/lib/apev2/APEv2Token.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/id3v1/ID3v1Parser.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasID3v1Header = exports.ID3v1Parser = exports.Genres = void 0;
var debug_1 = require("debug");
var token_types_1 = require("token-types");
var util = require("../common/Util");
var BasicParser_1 = require("../common/BasicParser");
var APEv2Parser_1 = require("../apev2/APEv2Parser");
var debug = (0, debug_1.default)('music-metadata:parser:ID3v1');
/**
 * ID3v1 Genre mappings
 * Ref: https://de.wikipedia.org/wiki/Liste_der_ID3v1-Genres
 */
exports.Genres = ['Blues', 'Classic Rock', 'Country', 'Dance', 'Disco', 'Funk', 'Grunge', 'Hip-Hop', 'Jazz', 'Metal', 'New Age', 'Oldies', 'Other', 'Pop', 'R&B', 'Rap', 'Reggae', 'Rock', 'Techno', 'Industrial', 'Alternative', 'Ska', 'Death Metal', 'Pranks', 'Soundtrack', 'Euro-Techno', 'Ambient', 'Trip-Hop', 'Vocal', 'Jazz+Funk', 'Fusion', 'Trance', 'Classical', 'Instrumental', 'Acid', 'House', 'Game', 'Sound Clip', 'Gospel', 'Noise', 'Alt. Rock', 'Bass', 'Soul', 'Punk', 'Space', 'Meditative', 'Instrumental Pop', 'Instrumental Rock', 'Ethnic', 'Gothic', 'Darkwave', 'Techno-Industrial', 'Electronic', 'Pop-Folk', 'Eurodance', 'Dream', 'Southern Rock', 'Comedy', 'Cult', 'Gangsta Rap', 'Top 40', 'Christian Rap', 'Pop/Funk', 'Jungle', 'Native American', 'Cabaret', 'New Wave', 'Psychedelic', 'Rave', 'Showtunes', 'Trailer', 'Lo-Fi', 'Tribal', 'Acid Punk', 'Acid Jazz', 'Polka', 'Retro', 'Musical', 'Rock & Roll', 'Hard Rock', 'Folk', 'Folk/Rock', 'National Folk', 'Swing', 'Fast-Fusion', 'Bebob', 'Latin', 'Revival', 'Celtic', 'Bluegrass', 'Avantgarde', 'Gothic Rock', 'Progressive Rock', 'Psychedelic Rock', 'Symphonic Rock', 'Slow Rock', 'Big Band', 'Chorus', 'Easy Listening', 'Acoustic', 'Humour', 'Speech', 'Chanson', 'Opera', 'Chamber Music', 'Sonata', 'Symphony', 'Booty Bass', 'Primus', 'Porn Groove', 'Satire', 'Slow Jam', 'Club', 'Tango', 'Samba', 'Folklore', 'Ballad', 'Power Ballad', 'Rhythmic Soul', 'Freestyle', 'Duet', 'Punk Rock', 'Drum Solo', 'A Cappella', 'Euro-House', 'Dance Hall', 'Goa', 'Drum & Bass', 'Club-House', 'Hardcore', 'Terror', 'Indie', 'BritPop', 'Negerpunk', 'Polsk Punk', 'Beat', 'Christian Gangsta Rap', 'Heavy Metal', 'Black Metal', 'Crossover', 'Contemporary Christian', 'Christian Rock', 'Merengue', 'Salsa', 'Thrash Metal', 'Anime', 'JPop', 'Synthpop', 'Abstract', 'Art Rock', 'Baroque', 'Bhangra', 'Big Beat', 'Breakbeat', 'Chillout', 'Downtempo', 'Dub', 'EBM', 'Eclectic', 'Electro', 'Electroclash', 'Emo', 'Experimental', 'Garage', 'Global', 'IDM', 'Illbient', 'Industro-Goth', 'Jam Band', 'Krautrock', 'Leftfield', 'Lounge', 'Math Rock', 'New Romantic', 'Nu-Breakz', 'Post-Punk', 'Post-Rock', 'Psytrance', 'Shoegaze', 'Space Rock', 'Trop Rock', 'World Music', 'Neoclassical', 'Audiobook', 'Audio Theatre', 'Neue Deutsche Welle', 'Podcast', 'Indie Rock', 'G-Funk', 'Dubstep', 'Garage Rock', 'Psybient'];
/**
 * Spec: http://id3.org/ID3v1
 * Wiki: https://en.wikipedia.org/wiki/ID3
 */
var Iid3v1Token = {
  len: 128,
  /**
   * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
   * @param off Offset in buffer in bytes
   * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
   */
  get: function get(buf, off) {
    var header = new Id3v1StringType(3).get(buf, off);
    return header === 'TAG' ? {
      header: header,
      title: new Id3v1StringType(30).get(buf, off + 3),
      artist: new Id3v1StringType(30).get(buf, off + 33),
      album: new Id3v1StringType(30).get(buf, off + 63),
      year: new Id3v1StringType(4).get(buf, off + 93),
      comment: new Id3v1StringType(28).get(buf, off + 97),
      // ID3v1.1 separator for track
      zeroByte: token_types_1.UINT8.get(buf, off + 127),
      // track: ID3v1.1 field added by Michael Mutschler
      track: token_types_1.UINT8.get(buf, off + 126),
      genre: token_types_1.UINT8.get(buf, off + 127)
    } : null;
  }
};
var Id3v1StringType = /*#__PURE__*/function (_token_types_1$String) {
  _inherits(Id3v1StringType, _token_types_1$String);
  var _super = _createSuper(Id3v1StringType);
  function Id3v1StringType(len) {
    _classCallCheck(this, Id3v1StringType);
    return _super.call(this, len, 'binary');
  }
  _createClass(Id3v1StringType, [{
    key: "get",
    value: function get(buf, off) {
      var value = _get(_getPrototypeOf(Id3v1StringType.prototype), "get", this).call(this, buf, off);
      value = util.trimRightNull(value);
      value = value.trim();
      return value.length > 0 ? value : undefined;
    }
  }]);
  return Id3v1StringType;
}(token_types_1.StringType);
var ID3v1Parser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(ID3v1Parser, _BasicParser_1$BasicP);
  var _super2 = _createSuper(ID3v1Parser);
  function ID3v1Parser() {
    _classCallCheck(this, ID3v1Parser);
    return _super2.apply(this, arguments);
  }
  _createClass(ID3v1Parser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var apeParser, offset, header, _i, _arr, id, genre;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.tokenizer.fileInfo.size) {
                _context.next = 3;
                break;
              }
              debug('Skip checking for ID3v1 because the file-size is unknown');
              return _context.abrupt("return");
            case 3:
              if (!this.options.apeHeader) {
                _context.next = 9;
                break;
              }
              this.tokenizer.ignore(this.options.apeHeader.offset - this.tokenizer.position);
              apeParser = new APEv2Parser_1.APEv2Parser();
              apeParser.init(this.metadata, this.tokenizer, this.options);
              _context.next = 9;
              return apeParser.parseTags(this.options.apeHeader.footer);
            case 9:
              offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;
              if (!(this.tokenizer.position > offset)) {
                _context.next = 13;
                break;
              }
              debug('Already consumed the last 128 bytes');
              return _context.abrupt("return");
            case 13:
              _context.next = 15;
              return this.tokenizer.readToken(Iid3v1Token, offset);
            case 15:
              header = _context.sent;
              if (header) {
                debug('ID3v1 header found at: pos=%s', this.tokenizer.fileInfo.size - Iid3v1Token.len);
                for (_i = 0, _arr = ['title', 'artist', 'album', 'comment', 'track', 'year']; _i < _arr.length; _i++) {
                  id = _arr[_i];
                  if (header[id] && header[id] !== '') this.addTag(id, header[id]);
                }
                genre = ID3v1Parser.getGenre(header.genre);
                if (genre) this.addTag('genre', genre);
              } else {
                debug('ID3v1 header not found at: pos=%s', this.tokenizer.fileInfo.size - Iid3v1Token.len);
              }
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "addTag",
    value: function addTag(id, value) {
      this.metadata.addTag('ID3v1', id, value);
    }
  }], [{
    key: "getGenre",
    value: function getGenre(genreIndex) {
      if (genreIndex < exports.Genres.length) {
        return exports.Genres[genreIndex];
      }
      return undefined; // ToDO: generate warning
    }
  }]);
  return ID3v1Parser;
}(BasicParser_1.BasicParser);
exports.ID3v1Parser = ID3v1Parser;
function hasID3v1Header(_x) {
  return _hasID3v1Header.apply(this, arguments);
}
function _hasID3v1Header() {
  _hasID3v1Header = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(reader) {
    var tag;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(reader.fileSize >= 128)) {
            _context2.next = 5;
            break;
          }
          tag = Buffer.alloc(3);
          _context2.next = 4;
          return reader.randomRead(tag, 0, tag.length, reader.fileSize - 128);
        case 4:
          return _context2.abrupt("return", tag.toString('binary') === 'TAG');
        case 5:
          return _context2.abrupt("return", false);
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _hasID3v1Header.apply(this, arguments);
}
exports.hasID3v1Header = hasID3v1Header;
},{"debug":"node_modules/debug/src/browser.js","token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","../apev2/APEv2Parser":"node_modules/music-metadata/lib/apev2/APEv2Parser.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/id3v2/FrameParser.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FrameParser = exports.parseGenre = void 0;
var debug_1 = require("debug");
var Token = require("token-types");
var util = require("../common/Util");
var ID3v2Token_1 = require("./ID3v2Token");
var ID3v1Parser_1 = require("../id3v1/ID3v1Parser");
var debug = (0, debug_1.default)('music-metadata:id3v2:frame-parser');
var defaultEnc = 'latin1'; // latin1 == iso-8859-1;
function parseGenre(origVal) {
  // match everything inside parentheses
  var genres = [];
  var code;
  var word = '';
  var _iterator = _createForOfIteratorHelper(origVal),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var c = _step.value;
      if (typeof code === 'string') {
        if (c === '(' && code === '') {
          word += '(';
          code = undefined;
        } else if (c === ')') {
          if (word !== '') {
            genres.push(word);
            word = '';
          }
          var genre = parseGenreCode(code);
          if (genre) {
            genres.push(genre);
          }
          code = undefined;
        } else code += c;
      } else if (c === '(') {
        code = '';
      } else {
        word += c;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (word) {
    if (genres.length === 0 && word.match(/^\d*$/)) {
      word = ID3v1Parser_1.Genres[word];
    }
    genres.push(word);
  }
  return genres;
}
exports.parseGenre = parseGenre;
function parseGenreCode(code) {
  if (code === 'RX') return 'Remix';
  if (code === 'CR') return 'Cover';
  if (code.match(/^\d*$/)) {
    return ID3v1Parser_1.Genres[code];
  }
}
var FrameParser = /*#__PURE__*/function () {
  /**
   * Create id3v2 frame parser
   * @param major - Major version, e.g. (4) for  id3v2.4
   * @param warningCollector - Used to collect decode issue
   */
  function FrameParser(major, warningCollector) {
    _classCallCheck(this, FrameParser);
    this.major = major;
    this.warningCollector = warningCollector;
  }
  _createClass(FrameParser, [{
    key: "readData",
    value: function readData(uint8Array, type, includeCovers) {
      if (uint8Array.length === 0) {
        this.warningCollector.addWarning("id3v2.".concat(this.major, " header has empty tag type=").concat(type));
        return;
      }
      var _ID3v2Token_1$TextEnc = ID3v2Token_1.TextEncodingToken.get(uint8Array, 0),
        encoding = _ID3v2Token_1$TextEnc.encoding,
        bom = _ID3v2Token_1$TextEnc.bom;
      var length = uint8Array.length;
      var offset = 0;
      var output = []; // ToDo
      var nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
      var fzero;
      var out = {};
      debug("Parsing tag type=".concat(type, ", encoding=").concat(encoding, ", bom=").concat(bom));
      switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {
        case 'T*': // 4.2.1. Text information frames - details
        case 'IPLS': // v2.3: Involved people list
        case 'MVIN':
        case 'MVNM':
        case 'PCS':
        case 'PCST':
          var text;
          try {
            text = util.decodeString(uint8Array.slice(1), encoding).replace(/\x00+$/, '');
          } catch (error) {
            this.warningCollector.addWarning("id3v2.".concat(this.major, " type=").concat(type, " header has invalid string value: ").concat(error.message));
          }
          switch (type) {
            case 'TMCL': // Musician credits list
            case 'TIPL': // Involved people list
            case 'IPLS':
              // Involved people list
              output = this.splitValue(type, text);
              output = FrameParser.functionList(output);
              break;
            case 'TRK':
            case 'TRCK':
            case 'TPOS':
              output = text;
              break;
            case 'TCOM':
            case 'TEXT':
            case 'TOLY':
            case 'TOPE':
            case 'TPE1':
            case 'TSRC':
              // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
              output = this.splitValue(type, text);
              break;
            case 'TCO':
            case 'TCON':
              output = this.splitValue(type, text).map(function (v) {
                return parseGenre(v);
              }).reduce(function (acc, val) {
                return acc.concat(val);
              }, []);
              break;
            case 'PCS':
            case 'PCST':
              // TODO: Why `default` not results `1` but `''`?
              output = this.major >= 4 ? this.splitValue(type, text) : [text];
              output = Array.isArray(output) && output[0] === '' ? 1 : 0;
              break;
            default:
              output = this.major >= 4 ? this.splitValue(type, text) : [text];
          }
          break;
        case 'TXXX':
          output = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);
          output = {
            description: output.id,
            text: this.splitValue(type, util.decodeString(output.data, encoding).replace(/\x00+$/, ''))
          };
          break;
        case 'PIC':
        case 'APIC':
          if (includeCovers) {
            var pic = {};
            offset += 1;
            switch (this.major) {
              case 2:
                pic.format = util.decodeString(uint8Array.slice(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;
                offset += 3;
                break;
              case 3:
              case 4:
                fzero = util.findZero(uint8Array, offset, length, defaultEnc);
                pic.format = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
                offset = fzero + 1;
                break;
              default:
                throw new Error('Warning: unexpected major versionIndex: ' + this.major);
            }
            pic.format = FrameParser.fixPictureMimeType(pic.format);
            pic.type = ID3v2Token_1.AttachedPictureType[uint8Array[offset]];
            offset += 1;
            fzero = util.findZero(uint8Array, offset, length, encoding);
            pic.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);
            offset = fzero + nullTerminatorLength;
            pic.data = Buffer.from(uint8Array.slice(offset, length));
            output = pic;
          }
          break;
        case 'CNT':
        case 'PCNT':
          output = Token.UINT32_BE.get(uint8Array, 0);
          break;
        case 'SYLT':
          // skip text encoding (1 byte),
          //      language (3 bytes),
          //      time stamp format (1 byte),
          //      content tagTypes (1 byte),
          //      content descriptor (1 byte)
          offset += 7;
          output = [];
          while (offset < length) {
            var txt = uint8Array.slice(offset, offset = util.findZero(uint8Array, offset, length, encoding));
            offset += 5; // push offset forward one +  4 byte timestamp
            output.push(util.decodeString(txt, encoding));
          }
          break;
        case 'ULT':
        case 'USLT':
        case 'COM':
        case 'COMM':
          offset += 1;
          out.language = util.decodeString(uint8Array.slice(offset, offset + 3), defaultEnc);
          offset += 3;
          fzero = util.findZero(uint8Array, offset, length, encoding);
          out.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);
          offset = fzero + nullTerminatorLength;
          out.text = util.decodeString(uint8Array.slice(offset, length), encoding).replace(/\x00+$/, '');
          output = [out];
          break;
        case 'UFID':
          output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
          output = {
            owner_identifier: output.id,
            identifier: output.data
          };
          break;
        case 'PRIV':
          // private frame
          output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
          output = {
            owner_identifier: output.id,
            data: output.data
          };
          break;
        case 'POPM':
          // Popularimeter
          fzero = util.findZero(uint8Array, offset, length, defaultEnc);
          var email = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
          offset = fzero + 1;
          var dataLen = length - offset;
          output = {
            email: email,
            rating: Token.UINT8.get(uint8Array, offset),
            counter: dataLen >= 5 ? Token.UINT32_BE.get(uint8Array, offset + 1) : undefined
          };
          break;
        case 'GEOB':
          {
            // General encapsulated object
            fzero = util.findZero(uint8Array, offset + 1, length, encoding);
            var mimeType = util.decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);
            offset = fzero + 1;
            fzero = util.findZero(uint8Array, offset, length - offset, encoding);
            var filename = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            offset = fzero + 1;
            fzero = util.findZero(uint8Array, offset, length - offset, encoding);
            var description = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            output = {
              type: mimeType,
              filename: filename,
              description: description,
              data: uint8Array.slice(offset + 1, length)
            };
            break;
          }
        // W-Frames:
        case 'WCOM':
        case 'WCOP':
        case 'WOAF':
        case 'WOAR':
        case 'WOAS':
        case 'WORS':
        case 'WPAY':
        case 'WPUB':
          // Decode URL
          output = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
          break;
        case 'WXXX':
          {
            // Decode URL
            fzero = util.findZero(uint8Array, offset + 1, length, encoding);
            var _description = util.decodeString(uint8Array.slice(offset + 1, fzero), encoding);
            offset = fzero + (encoding === 'utf16le' ? 2 : 1);
            output = {
              description: _description,
              url: util.decodeString(uint8Array.slice(offset, length), defaultEnc)
            };
            break;
          }
        case 'WFD':
        case 'WFED':
          output = util.decodeString(uint8Array.slice(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);
          break;
        case 'MCDI':
          {
            // Music CD identifier
            output = uint8Array.slice(0, length);
            break;
          }
        default:
          debug('Warning: unsupported id3v2-tag-type: ' + type);
          break;
      }
      return output;
    }
  }, {
    key: "splitValue",
    value:
    /**
     * id3v2.4 defines that multiple T* values are separated by 0x00
     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
     * @param tag - Tag name
     * @param text - Concatenated tag value
     * @returns Split tag value
     */
    function splitValue(tag, text) {
      var values;
      if (this.major < 4) {
        values = text.split(/\x00/g);
        if (values.length > 1) {
          this.warningCollector.addWarning("ID3v2.".concat(this.major, " ").concat(tag, " uses non standard null-separator."));
        } else {
          values = text.split(/\//g);
        }
      } else {
        values = text.split(/\x00/g);
      }
      return FrameParser.trimArray(values);
    }
  }], [{
    key: "fixPictureMimeType",
    value: function fixPictureMimeType(pictureType) {
      pictureType = pictureType.toLocaleLowerCase();
      switch (pictureType) {
        case 'jpg':
          return 'image/jpeg';
        case 'png':
          return 'image/png';
      }
      return pictureType;
    }
    /**
     * Converts TMCL (Musician credits list) or TIPL (Involved people list)
     * @param entries
     */
  }, {
    key: "functionList",
    value: function functionList(entries) {
      var res = {};
      for (var i = 0; i + 1 < entries.length; i += 2) {
        var names = entries[i + 1].split(',');
        res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;
      }
      return res;
    }
  }, {
    key: "trimArray",
    value: function trimArray(values) {
      return values.map(function (value) {
        return value.replace(/\x00+$/, '').trim();
      });
    }
  }, {
    key: "readIdentifierAndData",
    value: function readIdentifierAndData(uint8Array, offset, length, encoding) {
      var fzero = util.findZero(uint8Array, offset, length, encoding);
      var id = util.decodeString(uint8Array.slice(offset, fzero), encoding);
      offset = fzero + FrameParser.getNullTerminatorLength(encoding);
      return {
        id: id,
        data: uint8Array.slice(offset, length)
      };
    }
  }, {
    key: "getNullTerminatorLength",
    value: function getNullTerminatorLength(enc) {
      return enc === 'utf16le' ? 2 : 1;
    }
  }]);
  return FrameParser;
}();
exports.FrameParser = FrameParser;
},{"debug":"node_modules/debug/src/browser.js","token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","./ID3v2Token":"node_modules/music-metadata/lib/id3v2/ID3v2Token.js","../id3v1/ID3v1Parser":"node_modules/music-metadata/lib/id3v1/ID3v1Parser.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/id3v2/ID3v2Parser.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ID3v2Parser = void 0;
var Token = require("token-types");
var util = require("../common/Util");
var FrameParser_1 = require("./FrameParser");
var ID3v2Token_1 = require("./ID3v2Token");
var ID3v2Parser = /*#__PURE__*/function () {
  function ID3v2Parser() {
    _classCallCheck(this, ID3v2Parser);
  }
  _createClass(ID3v2Parser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(metadata, tokenizer, options) {
        var id3Header;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.tokenizer = tokenizer;
              this.metadata = metadata;
              this.options = options;
              _context.next = 5;
              return this.tokenizer.readToken(ID3v2Token_1.ID3v2Header);
            case 5:
              id3Header = _context.sent;
              if (!(id3Header.fileIdentifier !== 'ID3')) {
                _context.next = 8;
                break;
              }
              throw new Error('expected ID3-header file-identifier \'ID3\' was not found');
            case 8:
              this.id3Header = id3Header;
              this.headerType = 'ID3v2.' + id3Header.version.major;
              return _context.abrupt("return", id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size));
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function parse(_x, _x2, _x3) {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "parseExtendedHeader",
    value: function () {
      var _parseExtendedHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var extendedHeader, dataRemaining;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.tokenizer.readToken(ID3v2Token_1.ExtendedHeader);
            case 2:
              extendedHeader = _context2.sent;
              dataRemaining = extendedHeader.size - ID3v2Token_1.ExtendedHeader.len;
              return _context2.abrupt("return", dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size));
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parseExtendedHeader() {
        return _parseExtendedHeader.apply(this, arguments);
      }
      return parseExtendedHeader;
    }()
  }, {
    key: "parseExtendedHeaderData",
    value: function () {
      var _parseExtendedHeaderData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataRemaining, extendedHeaderSize) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.tokenizer.ignore(dataRemaining);
            case 2:
              return _context3.abrupt("return", this.parseId3Data(this.id3Header.size - extendedHeaderSize));
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function parseExtendedHeaderData(_x4, _x5) {
        return _parseExtendedHeaderData.apply(this, arguments);
      }
      return parseExtendedHeaderData;
    }()
  }, {
    key: "parseId3Data",
    value: function () {
      var _parseId3Data = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(dataLen) {
        var uint8Array, _iterator, _step, tag, _iterator2, _step2, text, _iterator3, _step3, value, _iterator4, _step4, _value, _iterator5, _step5, _value2;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.tokenizer.readToken(new Token.Uint8ArrayType(dataLen));
            case 2:
              uint8Array = _context4.sent;
              _iterator = _createForOfIteratorHelper(this.parseMetadata(uint8Array));
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  tag = _step.value;
                  if (tag.id === 'TXXX') {
                    if (tag.value) {
                      _iterator2 = _createForOfIteratorHelper(tag.value.text);
                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                          text = _step2.value;
                          this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, tag.value.description), text);
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }
                    }
                  } else if (tag.id === 'COM') {
                    _iterator3 = _createForOfIteratorHelper(tag.value);
                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                        value = _step3.value;
                        this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value.text);
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }
                  } else if (tag.id === 'COMM') {
                    _iterator4 = _createForOfIteratorHelper(tag.value);
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                        _value = _step4.value;
                        this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, _value.description), _value);
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                  } else if (Array.isArray(tag.value)) {
                    _iterator5 = _createForOfIteratorHelper(tag.value);
                    try {
                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                        _value2 = _step5.value;
                        this.addTag(tag.id, _value2);
                      }
                    } catch (err) {
                      _iterator5.e(err);
                    } finally {
                      _iterator5.f();
                    }
                  } else {
                    this.addTag(tag.id, tag.value);
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function parseId3Data(_x6) {
        return _parseId3Data.apply(this, arguments);
      }
      return parseId3Data;
    }()
  }, {
    key: "addTag",
    value: function addTag(id, value) {
      this.metadata.addTag(this.headerType, id, value);
    }
  }, {
    key: "parseMetadata",
    value: function parseMetadata(data) {
      var offset = 0;
      var tags = [];
      while (true) {
        if (offset === data.length) break;
        var frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
        if (offset + frameHeaderLength > data.length) {
          this.metadata.addWarning('Illegal ID3v2 tag length');
          break;
        }
        var frameHeaderBytes = data.slice(offset, offset += frameHeaderLength);
        var frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);
        var frameDataBytes = data.slice(offset, offset += frameHeader.length);
        var values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
        if (values) {
          tags.push({
            id: frameHeader.id,
            value: values
          });
        }
      }
      return tags;
    }
  }, {
    key: "readFrameHeader",
    value: function readFrameHeader(uint8Array, majorVer) {
      var header;
      switch (majorVer) {
        case 2:
          header = {
            id: Buffer.from(uint8Array.slice(0, 3)).toString('ascii'),
            length: Token.UINT24_BE.get(uint8Array, 3)
          };
          if (!header.id.match(/[A-Z0-9]{3}/g)) {
            this.metadata.addWarning("Invalid ID3v2.".concat(this.id3Header.version.major, " frame-header-ID: ").concat(header.id));
          }
          break;
        case 3:
        case 4:
          header = {
            id: Buffer.from(uint8Array.slice(0, 4)).toString('ascii'),
            length: (majorVer === 4 ? ID3v2Token_1.UINT32SYNCSAFE : Token.UINT32_BE).get(uint8Array, 4),
            flags: ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))
          };
          if (!header.id.match(/[A-Z0-9]{4}/g)) {
            this.metadata.addWarning("Invalid ID3v2.".concat(this.id3Header.version.major, " frame-header-ID: ").concat(header.id));
          }
          break;
        default:
          throw new Error('Unexpected majorVer: ' + majorVer);
      }
      return header;
    }
  }], [{
    key: "removeUnsyncBytes",
    value: function removeUnsyncBytes(buffer) {
      var readI = 0;
      var writeI = 0;
      while (readI < buffer.length - 1) {
        if (readI !== writeI) {
          buffer[writeI] = buffer[readI];
        }
        readI += buffer[readI] === 0xFF && buffer[readI + 1] === 0 ? 2 : 1;
        writeI++;
      }
      if (readI < buffer.length) {
        buffer[writeI++] = buffer[readI];
      }
      return buffer.slice(0, writeI);
    }
  }, {
    key: "getFrameHeaderLength",
    value: function getFrameHeaderLength(majorVer) {
      switch (majorVer) {
        case 2:
          return 6;
        case 3:
        case 4:
          return 10;
        default:
          throw new Error('header versionIndex is incorrect');
      }
    }
  }, {
    key: "readFrameFlags",
    value: function readFrameFlags(b) {
      return {
        status: {
          tag_alter_preservation: util.getBit(b, 0, 6),
          file_alter_preservation: util.getBit(b, 0, 5),
          read_only: util.getBit(b, 0, 4)
        },
        format: {
          grouping_identity: util.getBit(b, 1, 7),
          compression: util.getBit(b, 1, 3),
          encryption: util.getBit(b, 1, 2),
          unsynchronisation: util.getBit(b, 1, 1),
          data_length_indicator: util.getBit(b, 1, 0)
        }
      };
    }
  }, {
    key: "readFrameData",
    value: function readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {
      var frameParser = new FrameParser_1.FrameParser(majorVer, warningCollector);
      switch (majorVer) {
        case 2:
          return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
        case 3:
        case 4:
          if (frameHeader.flags.format.unsynchronisation) {
            uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);
          }
          if (frameHeader.flags.format.data_length_indicator) {
            uint8Array = uint8Array.slice(4, uint8Array.length);
          }
          return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
        default:
          throw new Error('Unexpected majorVer: ' + majorVer);
      }
    }
    /**
     * Create a combined tag key, of tag & description
     * @param tag e.g.: COM
     * @param description e.g. iTunPGAP
     * @returns string e.g. COM:iTunPGAP
     */
  }, {
    key: "makeDescriptionTagName",
    value: function makeDescriptionTagName(tag, description) {
      return tag + (description ? ':' + description : '');
    }
  }]);
  return ID3v2Parser;
}();
exports.ID3v2Parser = ID3v2Parser;
},{"token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","./FrameParser":"node_modules/music-metadata/lib/id3v2/FrameParser.js","./ID3v2Token":"node_modules/music-metadata/lib/id3v2/ID3v2Token.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/aiff/AiffToken.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Common = void 0;
var Token = require("token-types");
var FourCC_1 = require("../common/FourCC");
var Common = /*#__PURE__*/function () {
  function Common(header, isAifc) {
    _classCallCheck(this, Common);
    this.isAifc = isAifc;
    var minimumChunkSize = isAifc ? 22 : 18;
    if (header.chunkSize < minimumChunkSize) throw new Error("COMMON CHUNK size should always be at least ".concat(minimumChunkSize));
    this.len = header.chunkSize;
  }
  _createClass(Common, [{
    key: "get",
    value: function get(buf, off) {
      // see: https://cycling74.com/forums/aiffs-80-bit-sample-rate-value
      var shift = buf.readUInt16BE(off + 8) - 16398;
      var baseSampleRate = buf.readUInt16BE(off + 8 + 2);
      var res = {
        numChannels: buf.readUInt16BE(off),
        numSampleFrames: buf.readUInt32BE(off + 2),
        sampleSize: buf.readUInt16BE(off + 6),
        sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
      };
      if (this.isAifc) {
        res.compressionType = FourCC_1.FourCcToken.get(buf, off + 18);
        if (this.len > 22) {
          var strLen = buf.readInt8(off + 22);
          if (strLen > 0) {
            var padding = (strLen + 1) % 2;
            if (23 + strLen + padding === this.len) {
              res.compressionName = new Token.StringType(strLen, 'binary').get(buf, off + 23);
            } else {
              throw new Error('Illegal pstring length');
            }
          } else {
            res.compressionName = undefined;
          }
        }
      } else {
        res.compressionName = 'PCM';
      }
      return res;
    }
  }]);
  return Common;
}();
exports.Common = Common;
},{"token-types":"node_modules/token-types/lib/index.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js"}],"node_modules/music-metadata/lib/iff/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Header = void 0;
var Token = require("token-types");
var FourCC_1 = require("../common/FourCC");
/**
 * Common AIFF chunk header
 */
exports.Header = {
  len: 8,
  get: function get(buf, off) {
    return {
      // Chunk type ID
      chunkID: FourCC_1.FourCcToken.get(buf, off),
      // Chunk size
      chunkSize: Number(BigInt(Token.UINT32_BE.get(buf, off + 4)))
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js"}],"node_modules/music-metadata/lib/aiff/AiffParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AIFFParser = void 0;
var Token = require("token-types");
var debug_1 = require("debug");
var strtok3 = require("strtok3/lib/core");
var ID3v2Parser_1 = require("../id3v2/ID3v2Parser");
var FourCC_1 = require("../common/FourCC");
var BasicParser_1 = require("../common/BasicParser");
var AiffToken = require("./AiffToken");
var iff = require("../iff");
var debug = (0, debug_1.default)('music-metadata:parser:aiff');
var compressionTypes = {
  NONE: 'not compressed	PCM	Apple Computer',
  sowt: 'PCM (byte swapped)',
  fl32: '32-bit floating point IEEE 32-bit float',
  fl64: '64-bit floating point IEEE 64-bit float	Apple Computer',
  alaw: 'ALaw 2:1	8-bit ITU-T G.711 A-law',
  ulaw: 'µLaw 2:1	8-bit ITU-T G.711 µ-law	Apple Computer',
  ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',
  ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',
  FL32: 'Float 32	IEEE 32-bit float '
};
/**
 * AIFF - Audio Interchange File Format
 *
 * Ref:
 * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html
 * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf
 */
var AIFFParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(AIFFParser, _BasicParser_1$BasicP);
  var _super = _createSuper(AIFFParser);
  function AIFFParser() {
    _classCallCheck(this, AIFFParser);
    return _super.apply(this, arguments);
  }
  _createClass(AIFFParser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var header, type, chunkHeader, nextChunk, bytesRead;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.readToken(iff.Header);
            case 2:
              header = _context.sent;
              if (!(header.chunkID !== 'FORM')) {
                _context.next = 5;
                break;
              }
              throw new Error('Invalid Chunk-ID, expected \'FORM\'');
            case 5:
              _context.next = 7;
              return this.tokenizer.readToken(FourCC_1.FourCcToken);
            case 7:
              type = _context.sent;
              _context.t0 = type;
              _context.next = _context.t0 === 'AIFF' ? 11 : _context.t0 === 'AIFC' ? 14 : 17;
              break;
            case 11:
              this.metadata.setFormat('container', type);
              this.isCompressed = false;
              return _context.abrupt("break", 18);
            case 14:
              this.metadata.setFormat('container', 'AIFF-C');
              this.isCompressed = true;
              return _context.abrupt("break", 18);
            case 17:
              throw Error('Unsupported AIFF type: ' + type);
            case 18:
              this.metadata.setFormat('lossless', !this.isCompressed);
              _context.prev = 19;
            case 20:
              if (!(!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len)) {
                _context.next = 33;
                break;
              }
              debug('Reading AIFF chunk at offset=' + this.tokenizer.position);
              _context.next = 24;
              return this.tokenizer.readToken(iff.Header);
            case 24:
              chunkHeader = _context.sent;
              nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);
              _context.next = 28;
              return this.readData(chunkHeader);
            case 28:
              bytesRead = _context.sent;
              _context.next = 31;
              return this.tokenizer.ignore(nextChunk - bytesRead);
            case 31:
              _context.next = 20;
              break;
            case 33:
              _context.next = 42;
              break;
            case 35:
              _context.prev = 35;
              _context.t1 = _context["catch"](19);
              if (!(_context.t1 instanceof strtok3.EndOfStreamError)) {
                _context.next = 41;
                break;
              }
              debug("End-of-stream");
              _context.next = 42;
              break;
            case 41:
              throw _context.t1;
            case 42:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[19, 35]]);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "readData",
    value: function () {
      var _readData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(header) {
        var _a, common, id3_data, rst;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.t0 = header.chunkID;
              _context2.next = _context2.t0 === 'COMM' ? 3 : _context2.t0 === 'ID3 ' ? 13 : _context2.t0 === 'SSND' ? 20 : _context2.t0 === 'NAME' ? 22 : _context2.t0 === 'AUTH' ? 22 : _context2.t0 === '(c) ' ? 22 : _context2.t0 === 'ANNO' ? 22 : 23;
              break;
            case 3:
              _context2.next = 5;
              return this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));
            case 5:
              common = _context2.sent;
              this.metadata.setFormat('bitsPerSample', common.sampleSize);
              this.metadata.setFormat('sampleRate', common.sampleRate);
              this.metadata.setFormat('numberOfChannels', common.numChannels);
              this.metadata.setFormat('numberOfSamples', common.numSampleFrames);
              this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);
              this.metadata.setFormat('codec', (_a = common.compressionName) !== null && _a !== void 0 ? _a : compressionTypes[common.compressionType]);
              return _context2.abrupt("return", header.chunkSize);
            case 13:
              _context2.next = 15;
              return this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));
            case 15:
              id3_data = _context2.sent;
              rst = strtok3.fromBuffer(id3_data);
              _context2.next = 19;
              return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
            case 19:
              return _context2.abrupt("return", header.chunkSize);
            case 20:
              // Sound Data Chunk
              if (this.metadata.format.duration) {
                this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);
              }
              return _context2.abrupt("return", 0);
            case 22:
              return _context2.abrupt("return", this.readTextChunk(header));
            case 23:
              debug("Ignore chunk id=".concat(header.chunkID, ", size=").concat(header.chunkSize));
              return _context2.abrupt("return", 0);
            case 25:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function readData(_x) {
        return _readData.apply(this, arguments);
      }
      return readData;
    }()
  }, {
    key: "readTextChunk",
    value: function () {
      var _readTextChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(header) {
        var _this = this;
        var value;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));
            case 2:
              value = _context3.sent;
              value.split('\0').map(function (v) {
                return v.trim();
              }).filter(function (v) {
                return v && v.length > 0;
              }).forEach(function (v) {
                _this.metadata.addTag('AIFF', header.chunkID, v.trim());
              });
              return _context3.abrupt("return", header.chunkSize);
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function readTextChunk(_x2) {
        return _readTextChunk.apply(this, arguments);
      }
      return readTextChunk;
    }()
  }]);
  return AIFFParser;
}(BasicParser_1.BasicParser);
exports.AIFFParser = AIFFParser;
},{"token-types":"node_modules/token-types/lib/index.js","debug":"node_modules/debug/src/browser.js","strtok3/lib/core":"node_modules/strtok3/lib/core.js","../id3v2/ID3v2Parser":"node_modules/music-metadata/lib/id3v2/ID3v2Parser.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","./AiffToken":"node_modules/music-metadata/lib/aiff/AiffToken.js","../iff":"node_modules/music-metadata/lib/iff/index.js"}],"node_modules/music-metadata/lib/asf/GUID.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Ref:
 * - https://tools.ietf.org/html/draft-fleischman-asf-01, Appendix A: ASF GUIDs
 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html
 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/index.html
 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html
 *
 * ASF File Structure:
 * - https://msdn.microsoft.com/en-us/library/windows/desktop/ee663575(v=vs.85).aspx
 *
 * ASF GUIDs:
 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html
 * - https://github.com/dji-sdk/FFmpeg/blob/master/libavformat/asf.c
 */
var GUID = /*#__PURE__*/function () {
  function GUID(str) {
    _classCallCheck(this, GUID);
    this.str = str;
  }
  _createClass(GUID, [{
    key: "equals",
    value: function equals(guid) {
      return this.str === guid.str;
    }
  }, {
    key: "toBin",
    value: function toBin() {
      return GUID.encode(this.str);
    }
  }], [{
    key: "fromBin",
    value: function fromBin(bin) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return new GUID(this.decode(bin, offset));
    }
    /**
     * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
     * @param objectId Binary GUID
     * @param offset Read offset in bytes, default 0
     * @returns GUID as dashed hexadecimal representation
     */
  }, {
    key: "decode",
    value: function decode(objectId) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var guid = objectId.readUInt32LE(offset).toString(16) + "-" + objectId.readUInt16LE(offset + 4).toString(16) + "-" + objectId.readUInt16LE(offset + 6).toString(16) + "-" + objectId.readUInt16BE(offset + 8).toString(16) + "-" + objectId.slice(offset + 10, offset + 16).toString('hex');
      return guid.toUpperCase();
    }
    /**
     * Decode stream type
     * @param mediaType Media type GUID
     * @returns Media type
     */
  }, {
    key: "decodeMediaType",
    value: function decodeMediaType(mediaType) {
      switch (mediaType.str) {
        case GUID.AudioMedia.str:
          return 'audio';
        case GUID.VideoMedia.str:
          return 'video';
        case GUID.CommandMedia.str:
          return 'command';
        case GUID.Degradable_JPEG_Media.str:
          return 'degradable-jpeg';
        case GUID.FileTransferMedia.str:
          return 'file-transfer';
        case GUID.BinaryMedia.str:
          return 'binary';
      }
    }
    /**
     * Encode GUID
     * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
     * @returns Encoded Binary GUID
     */
  }, {
    key: "encode",
    value: function encode(str) {
      var bin = Buffer.alloc(16);
      bin.writeUInt32LE(parseInt(str.slice(0, 8), 16), 0);
      bin.writeUInt16LE(parseInt(str.slice(9, 13), 16), 4);
      bin.writeUInt16LE(parseInt(str.slice(14, 18), 16), 6);
      Buffer.from(str.slice(19, 23), "hex").copy(bin, 8);
      Buffer.from(str.slice(24), "hex").copy(bin, 10);
      return bin;
    }
  }]);
  return GUID;
}(); // 10.1 Top-level ASF object GUIDs
GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
// 10.2 Header Object GUIDs
GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
// 10.3 Header Extension Object GUIDs
GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
// 10.4 Stream Properties Object Stream Type GUIDs
GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
exports.default = GUID;
},{"buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/asf/AsfUtil.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsfUtil = void 0;
var Token = require("token-types");
var util = require("../common/Util");
var AsfUtil = /*#__PURE__*/function () {
  function AsfUtil() {
    _classCallCheck(this, AsfUtil);
  }
  _createClass(AsfUtil, null, [{
    key: "getParserForAttr",
    value: function getParserForAttr(i) {
      return AsfUtil.attributeParsers[i];
    }
  }, {
    key: "parseUnicodeAttr",
    value: function parseUnicodeAttr(uint8Array) {
      return util.stripNulls(util.decodeString(uint8Array, 'utf16le'));
    }
  }, {
    key: "parseByteArrayAttr",
    value: function parseByteArrayAttr(buf) {
      return Buffer.from(buf);
    }
  }, {
    key: "parseBoolAttr",
    value: function parseBoolAttr(buf) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return AsfUtil.parseWordAttr(buf, offset) === 1;
    }
  }, {
    key: "parseDWordAttr",
    value: function parseDWordAttr(buf) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return buf.readUInt32LE(offset);
    }
  }, {
    key: "parseQWordAttr",
    value: function parseQWordAttr(buf) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return Token.UINT64_LE.get(buf, offset);
    }
  }, {
    key: "parseWordAttr",
    value: function parseWordAttr(buf) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return buf.readUInt16LE(offset);
    }
  }]);
  return AsfUtil;
}();
AsfUtil.attributeParsers = [AsfUtil.parseUnicodeAttr, AsfUtil.parseByteArrayAttr, AsfUtil.parseBoolAttr, AsfUtil.parseDWordAttr, AsfUtil.parseQWordAttr, AsfUtil.parseWordAttr, AsfUtil.parseByteArrayAttr];
exports.AsfUtil = AsfUtil;
},{"token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/asf/AsfObject.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

// ASF Objects
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WmPictureToken = exports.MetadataLibraryObjectState = exports.MetadataObjectState = exports.ExtendedStreamPropertiesObjectState = exports.ExtendedContentDescriptionObjectState = exports.ContentDescriptionObjectState = exports.readCodecEntries = exports.HeaderExtensionObject = exports.StreamPropertiesObject = exports.FilePropertiesObject = exports.IgnoreObjectState = exports.State = exports.HeaderObjectToken = exports.TopLevelHeaderObjectToken = exports.DataType = void 0;
var util = require("../common/Util");
var Token = require("token-types");
var GUID_1 = require("./GUID");
var AsfUtil_1 = require("./AsfUtil");
var ID3v2Token_1 = require("../id3v2/ID3v2Token");
/**
 * Data Type: Specifies the type of information being stored. The following values are recognized.
 */
var DataType;
(function (DataType) {
  /**
   * Unicode string. The data consists of a sequence of Unicode characters.
   */
  DataType[DataType["UnicodeString"] = 0] = "UnicodeString";
  /**
   * BYTE array. The type of data is implementation-specific.
   */
  DataType[DataType["ByteArray"] = 1] = "ByteArray";
  /**
   * BOOL. The data is 2 bytes long and should be interpreted as a 16-bit unsigned integer. Only 0x0000 or 0x0001 are permitted values.
   */
  DataType[DataType["Bool"] = 2] = "Bool";
  /**
   * DWORD. The data is 4 bytes long and should be interpreted as a 32-bit unsigned integer.
   */
  DataType[DataType["DWord"] = 3] = "DWord";
  /**
   * QWORD. The data is 8 bytes long and should be interpreted as a 64-bit unsigned integer.
   */
  DataType[DataType["QWord"] = 4] = "QWord";
  /**
   * WORD. The data is 2 bytes long and should be interpreted as a 16-bit unsigned integer.
   */
  DataType[DataType["Word"] = 5] = "Word";
})(DataType = exports.DataType || (exports.DataType = {}));
/**
 * Token for: 3. ASF top-level Header Object
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3
 */
exports.TopLevelHeaderObjectToken = {
  len: 30,
  get: function get(buf, off) {
    return {
      objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),
      objectSize: Number(Token.UINT64_LE.get(buf, off + 16)),
      numberOfHeaderObjects: Token.UINT32_LE.get(buf, off + 24)
      // Reserved: 2 bytes
    };
  }
};
/**
 * Token for: 3.1 Header Object (mandatory, one only)
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_1
 */
exports.HeaderObjectToken = {
  len: 24,
  get: function get(buf, off) {
    return {
      objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),
      objectSize: Number(Token.UINT64_LE.get(buf, off + 16))
    };
  }
};
var State = /*#__PURE__*/function () {
  function State(header) {
    _classCallCheck(this, State);
    this.len = Number(header.objectSize) - exports.HeaderObjectToken.len;
  }
  _createClass(State, [{
    key: "postProcessTag",
    value: function postProcessTag(tags, name, valueType, data) {
      if (name === 'WM/Picture') {
        tags.push({
          id: name,
          value: WmPictureToken.fromBuffer(data)
        });
      } else {
        var parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(valueType);
        if (!parseAttr) {
          throw new Error('unexpected value headerType: ' + valueType);
        }
        tags.push({
          id: name,
          value: parseAttr(data)
        });
      }
    }
  }]);
  return State;
}();
exports.State = State;
// ToDo: use ignore type
var IgnoreObjectState = /*#__PURE__*/function (_State) {
  _inherits(IgnoreObjectState, _State);
  var _super = _createSuper(IgnoreObjectState);
  function IgnoreObjectState(header) {
    _classCallCheck(this, IgnoreObjectState);
    return _super.call(this, header);
  }
  _createClass(IgnoreObjectState, [{
    key: "get",
    value: function get(buf, off) {
      return null;
    }
  }]);
  return IgnoreObjectState;
}(State);
exports.IgnoreObjectState = IgnoreObjectState;
/**
 * Token for: 3.2: File Properties Object (mandatory, one only)
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_2
 */
var FilePropertiesObject = /*#__PURE__*/function (_State2) {
  _inherits(FilePropertiesObject, _State2);
  var _super2 = _createSuper(FilePropertiesObject);
  function FilePropertiesObject(header) {
    _classCallCheck(this, FilePropertiesObject);
    return _super2.call(this, header);
  }
  _createClass(FilePropertiesObject, [{
    key: "get",
    value: function get(buf, off) {
      return {
        fileId: GUID_1.default.fromBin(buf, off),
        fileSize: Token.UINT64_LE.get(buf, off + 16),
        creationDate: Token.UINT64_LE.get(buf, off + 24),
        dataPacketsCount: Token.UINT64_LE.get(buf, off + 32),
        playDuration: Token.UINT64_LE.get(buf, off + 40),
        sendDuration: Token.UINT64_LE.get(buf, off + 48),
        preroll: Token.UINT64_LE.get(buf, off + 56),
        flags: {
          broadcast: util.getBit(buf, off + 64, 24),
          seekable: util.getBit(buf, off + 64, 25)
        },
        // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
        minimumDataPacketSize: Token.UINT32_LE.get(buf, off + 68),
        maximumDataPacketSize: Token.UINT32_LE.get(buf, off + 72),
        maximumBitrate: Token.UINT32_LE.get(buf, off + 76)
      };
    }
  }]);
  return FilePropertiesObject;
}(State);
FilePropertiesObject.guid = GUID_1.default.FilePropertiesObject;
exports.FilePropertiesObject = FilePropertiesObject;
/**
 * Token for: 3.3 Stream Properties Object (mandatory, one per stream)
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_3
 */
var StreamPropertiesObject = /*#__PURE__*/function (_State3) {
  _inherits(StreamPropertiesObject, _State3);
  var _super3 = _createSuper(StreamPropertiesObject);
  function StreamPropertiesObject(header) {
    _classCallCheck(this, StreamPropertiesObject);
    return _super3.call(this, header);
  }
  _createClass(StreamPropertiesObject, [{
    key: "get",
    value: function get(buf, off) {
      return {
        streamType: GUID_1.default.decodeMediaType(GUID_1.default.fromBin(buf, off)),
        errorCorrectionType: GUID_1.default.fromBin(buf, off + 8)
        // ToDo
      };
    }
  }]);
  return StreamPropertiesObject;
}(State);
StreamPropertiesObject.guid = GUID_1.default.StreamPropertiesObject;
exports.StreamPropertiesObject = StreamPropertiesObject;
/**
 * 3.4: Header Extension Object (mandatory, one only)
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_4
 */
var HeaderExtensionObject = /*#__PURE__*/function () {
  function HeaderExtensionObject() {
    _classCallCheck(this, HeaderExtensionObject);
    this.len = 22;
  }
  _createClass(HeaderExtensionObject, [{
    key: "get",
    value: function get(buf, off) {
      return {
        reserved1: GUID_1.default.fromBin(buf, off),
        reserved2: buf.readUInt16LE(off + 16),
        extensionDataSize: buf.readUInt32LE(off + 18)
      };
    }
  }]);
  return HeaderExtensionObject;
}();
HeaderExtensionObject.guid = GUID_1.default.HeaderExtensionObject;
exports.HeaderExtensionObject = HeaderExtensionObject;
/**
 * 3.5: The Codec List Object provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5
 */
var CodecListObjectHeader = {
  len: 20,
  get: function get(buf, off) {
    return {
      entryCount: buf.readUInt16LE(off + 16)
    };
  }
};
function readString(_x) {
  return _readString.apply(this, arguments);
}
/**
 * 3.5: Read the Codec-List-Object, which provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5
 */
function _readString() {
  _readString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenizer) {
    var length;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return tokenizer.readNumber(Token.UINT16_LE);
        case 2:
          length = _context.sent;
          _context.next = 5;
          return tokenizer.readToken(new Token.StringType(length * 2, 'utf16le'));
        case 5:
          return _context.abrupt("return", _context.sent.replace('\0', ''));
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _readString.apply(this, arguments);
}
function readCodecEntries(_x2) {
  return _readCodecEntries.apply(this, arguments);
}
function _readCodecEntries() {
  _readCodecEntries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tokenizer) {
    var codecHeader, entries, i;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return tokenizer.readToken(CodecListObjectHeader);
        case 2:
          codecHeader = _context2.sent;
          entries = [];
          i = 0;
        case 5:
          if (!(i < codecHeader.entryCount)) {
            _context2.next = 14;
            break;
          }
          _context2.t0 = entries;
          _context2.next = 9;
          return readCodecEntry(tokenizer);
        case 9:
          _context2.t1 = _context2.sent;
          _context2.t0.push.call(_context2.t0, _context2.t1);
        case 11:
          ++i;
          _context2.next = 5;
          break;
        case 14:
          return _context2.abrupt("return", entries);
        case 15:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _readCodecEntries.apply(this, arguments);
}
exports.readCodecEntries = readCodecEntries;
function readInformation(_x3) {
  return _readInformation.apply(this, arguments);
}
/**
 * Read Codec-Entries
 * @param tokenizer
 */
function _readInformation() {
  _readInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tokenizer) {
    var length, buf;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return tokenizer.readNumber(Token.UINT16_LE);
        case 2:
          length = _context3.sent;
          buf = Buffer.alloc(length);
          _context3.next = 6;
          return tokenizer.readBuffer(buf);
        case 6:
          return _context3.abrupt("return", buf);
        case 7:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _readInformation.apply(this, arguments);
}
function readCodecEntry(_x4) {
  return _readCodecEntry.apply(this, arguments);
}
/**
 * 3.10 Content Description Object (optional, one only)
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_10
 */
function _readCodecEntry() {
  _readCodecEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tokenizer) {
    var type;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return tokenizer.readNumber(Token.UINT16_LE);
        case 2:
          type = _context4.sent;
          _context4.t0 = {
            videoCodec: (type & 0x0001) === 0x0001,
            audioCodec: (type & 0x0002) === 0x0002
          };
          _context4.next = 6;
          return readString(tokenizer);
        case 6:
          _context4.t1 = _context4.sent;
          _context4.next = 9;
          return readString(tokenizer);
        case 9:
          _context4.t2 = _context4.sent;
          _context4.next = 12;
          return readInformation(tokenizer);
        case 12:
          _context4.t3 = _context4.sent;
          return _context4.abrupt("return", {
            type: _context4.t0,
            codecName: _context4.t1,
            description: _context4.t2,
            information: _context4.t3
          });
        case 14:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _readCodecEntry.apply(this, arguments);
}
var ContentDescriptionObjectState = /*#__PURE__*/function (_State4) {
  _inherits(ContentDescriptionObjectState, _State4);
  var _super4 = _createSuper(ContentDescriptionObjectState);
  function ContentDescriptionObjectState(header) {
    _classCallCheck(this, ContentDescriptionObjectState);
    return _super4.call(this, header);
  }
  _createClass(ContentDescriptionObjectState, [{
    key: "get",
    value: function get(buf, off) {
      var tags = [];
      var pos = off + 10;
      for (var i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {
        var length = buf.readUInt16LE(off + i * 2);
        if (length > 0) {
          var tagName = ContentDescriptionObjectState.contentDescTags[i];
          var end = pos + length;
          tags.push({
            id: tagName,
            value: AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, end))
          });
          pos = end;
        }
      }
      return tags;
    }
  }]);
  return ContentDescriptionObjectState;
}(State);
ContentDescriptionObjectState.guid = GUID_1.default.ContentDescriptionObject;
ContentDescriptionObjectState.contentDescTags = ['Title', 'Author', 'Copyright', 'Description', 'Rating'];
exports.ContentDescriptionObjectState = ContentDescriptionObjectState;
/**
 * 3.11 Extended Content Description Object (optional, one only)
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_11
 */
var ExtendedContentDescriptionObjectState = /*#__PURE__*/function (_State5) {
  _inherits(ExtendedContentDescriptionObjectState, _State5);
  var _super5 = _createSuper(ExtendedContentDescriptionObjectState);
  function ExtendedContentDescriptionObjectState(header) {
    _classCallCheck(this, ExtendedContentDescriptionObjectState);
    return _super5.call(this, header);
  }
  _createClass(ExtendedContentDescriptionObjectState, [{
    key: "get",
    value: function get(buf, off) {
      var tags = [];
      var attrCount = buf.readUInt16LE(off);
      var pos = off + 2;
      for (var i = 0; i < attrCount; i += 1) {
        var nameLen = buf.readUInt16LE(pos);
        pos += 2;
        var name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));
        pos += nameLen;
        var valueType = buf.readUInt16LE(pos);
        pos += 2;
        var valueLen = buf.readUInt16LE(pos);
        pos += 2;
        var value = buf.slice(pos, pos + valueLen);
        pos += valueLen;
        this.postProcessTag(tags, name, valueType, value);
      }
      return tags;
    }
  }]);
  return ExtendedContentDescriptionObjectState;
}(State);
ExtendedContentDescriptionObjectState.guid = GUID_1.default.ExtendedContentDescriptionObject;
exports.ExtendedContentDescriptionObjectState = ExtendedContentDescriptionObjectState;
/**
 * 4.1 Extended Stream Properties Object (optional, 1 per media stream)
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_1
 */
var ExtendedStreamPropertiesObjectState = /*#__PURE__*/function (_State6) {
  _inherits(ExtendedStreamPropertiesObjectState, _State6);
  var _super6 = _createSuper(ExtendedStreamPropertiesObjectState);
  function ExtendedStreamPropertiesObjectState(header) {
    _classCallCheck(this, ExtendedStreamPropertiesObjectState);
    return _super6.call(this, header);
  }
  _createClass(ExtendedStreamPropertiesObjectState, [{
    key: "get",
    value: function get(buf, off) {
      return {
        startTime: Token.UINT64_LE.get(buf, off),
        endTime: Token.UINT64_LE.get(buf, off + 8),
        dataBitrate: buf.readInt32LE(off + 12),
        bufferSize: buf.readInt32LE(off + 16),
        initialBufferFullness: buf.readInt32LE(off + 20),
        alternateDataBitrate: buf.readInt32LE(off + 24),
        alternateBufferSize: buf.readInt32LE(off + 28),
        alternateInitialBufferFullness: buf.readInt32LE(off + 32),
        maximumObjectSize: buf.readInt32LE(off + 36),
        flags: {
          reliableFlag: util.getBit(buf, off + 40, 0),
          seekableFlag: util.getBit(buf, off + 40, 1),
          resendLiveCleanpointsFlag: util.getBit(buf, off + 40, 2)
        },
        // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
        streamNumber: buf.readInt16LE(off + 42),
        streamLanguageId: buf.readInt16LE(off + 44),
        averageTimePerFrame: buf.readInt32LE(off + 52),
        streamNameCount: buf.readInt32LE(off + 54),
        payloadExtensionSystems: buf.readInt32LE(off + 56),
        streamNames: [],
        streamPropertiesObject: null
      };
    }
  }]);
  return ExtendedStreamPropertiesObjectState;
}(State);
ExtendedStreamPropertiesObjectState.guid = GUID_1.default.ExtendedStreamPropertiesObject;
exports.ExtendedStreamPropertiesObjectState = ExtendedStreamPropertiesObjectState;
/**
 * 4.7  Metadata Object (optional, 0 or 1)
 * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_7
 */
var MetadataObjectState = /*#__PURE__*/function (_State7) {
  _inherits(MetadataObjectState, _State7);
  var _super7 = _createSuper(MetadataObjectState);
  function MetadataObjectState(header) {
    _classCallCheck(this, MetadataObjectState);
    return _super7.call(this, header);
  }
  _createClass(MetadataObjectState, [{
    key: "get",
    value: function get(uint8Array, off) {
      var tags = [];
      var buf = Buffer.from(uint8Array);
      var descriptionRecordsCount = buf.readUInt16LE(off);
      var pos = off + 2;
      for (var i = 0; i < descriptionRecordsCount; i += 1) {
        pos += 4;
        var nameLen = buf.readUInt16LE(pos);
        pos += 2;
        var dataType = buf.readUInt16LE(pos);
        pos += 2;
        var dataLen = buf.readUInt32LE(pos);
        pos += 4;
        var name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));
        pos += nameLen;
        var data = buf.slice(pos, pos + dataLen);
        pos += dataLen;
        this.postProcessTag(tags, name, dataType, data);
      }
      return tags;
    }
  }]);
  return MetadataObjectState;
}(State);
MetadataObjectState.guid = GUID_1.default.MetadataObject;
exports.MetadataObjectState = MetadataObjectState;
// 4.8	Metadata Library Object (optional, 0 or 1)
var MetadataLibraryObjectState = /*#__PURE__*/function (_MetadataObjectState) {
  _inherits(MetadataLibraryObjectState, _MetadataObjectState);
  var _super8 = _createSuper(MetadataLibraryObjectState);
  function MetadataLibraryObjectState(header) {
    _classCallCheck(this, MetadataLibraryObjectState);
    return _super8.call(this, header);
  }
  return _createClass(MetadataLibraryObjectState);
}(MetadataObjectState);
MetadataLibraryObjectState.guid = GUID_1.default.MetadataLibraryObject;
exports.MetadataLibraryObjectState = MetadataLibraryObjectState;
/**
 * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd757977(v=vs.85).aspx
 */
var WmPictureToken = /*#__PURE__*/function () {
  function WmPictureToken(len) {
    _classCallCheck(this, WmPictureToken);
    this.len = len;
  }
  _createClass(WmPictureToken, [{
    key: "get",
    value: function get(buffer, offset) {
      var typeId = buffer.readUInt8(offset++);
      var size = buffer.readInt32LE(offset);
      var index = 5;
      while (buffer.readUInt16BE(index) !== 0) {
        index += 2;
      }
      var format = buffer.slice(5, index).toString('utf16le');
      while (buffer.readUInt16BE(index) !== 0) {
        index += 2;
      }
      var description = buffer.slice(5, index).toString('utf16le');
      return {
        type: ID3v2Token_1.AttachedPictureType[typeId],
        format: format,
        description: description,
        size: size,
        data: buffer.slice(index + 4)
      };
    }
  }], [{
    key: "fromBase64",
    value: function fromBase64(base64str) {
      return this.fromBuffer(Buffer.from(base64str, 'base64'));
    }
  }, {
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      var pic = new WmPictureToken(buffer.length);
      return pic.get(buffer, 0);
    }
  }]);
  return WmPictureToken;
}();
exports.WmPictureToken = WmPictureToken;
},{"../common/Util":"node_modules/music-metadata/lib/common/Util.js","token-types":"node_modules/token-types/lib/index.js","./GUID":"node_modules/music-metadata/lib/asf/GUID.js","./AsfUtil":"node_modules/music-metadata/lib/asf/AsfUtil.js","../id3v2/ID3v2Token":"node_modules/music-metadata/lib/id3v2/ID3v2Token.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/asf/AsfParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AsfParser = void 0;
var debug_1 = require("debug");
var type_1 = require("../type");
var GUID_1 = require("./GUID");
var AsfObject = require("./AsfObject");
var BasicParser_1 = require("../common/BasicParser");
var debug = (0, debug_1.default)('music-metadata:parser:ASF');
var headerType = 'asf';
/**
 * Windows Media Metadata Usage Guidelines
 * - Ref: https://msdn.microsoft.com/en-us/library/ms867702.aspx
 *
 * Ref:
 * - https://tools.ietf.org/html/draft-fleischman-asf-01
 * - https://hwiegman.home.xs4all.nl/fileformats/asf/ASF_Specification.pdf
 * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/index.html
 * - https://msdn.microsoft.com/en-us/library/windows/desktop/ee663575(v=vs.85).aspx
 */
var AsfParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(AsfParser, _BasicParser_1$BasicP);
  var _super = _createSuper(AsfParser);
  function AsfParser() {
    _classCallCheck(this, AsfParser);
    return _super.apply(this, arguments);
  }
  _createClass(AsfParser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var header;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.readToken(AsfObject.TopLevelHeaderObjectToken);
            case 2:
              header = _context.sent;
              if (header.objectId.equals(GUID_1.default.HeaderObject)) {
                _context.next = 5;
                break;
              }
              throw new Error('expected asf header; but was not found; got: ' + header.objectId.str);
            case 5:
              _context.prev = 5;
              _context.next = 8;
              return this.parseObjectHeader(header.numberOfHeaderObjects);
            case 8:
              _context.next = 13;
              break;
            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](5);
              debug('Error while parsing ASF: %s', _context.t0);
            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[5, 10]]);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "parseObjectHeader",
    value: function () {
      var _parseObjectHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(numberOfObjectHeaders) {
        var _this = this;
        var tags, header, fpo, spo, extHeader, codecs, audioCodecs;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.tokenizer.readToken(AsfObject.HeaderObjectToken);
            case 2:
              header = _context2.sent;
              // Parse data part of the ASF Object
              debug('header GUID=%s', header.objectId.str);
              _context2.t0 = header.objectId.str;
              _context2.next = _context2.t0 === AsfObject.FilePropertiesObject.guid.str ? 7 : _context2.t0 === AsfObject.StreamPropertiesObject.guid.str ? 13 : _context2.t0 === AsfObject.HeaderExtensionObject.guid.str ? 18 : _context2.t0 === AsfObject.ContentDescriptionObjectState.guid.str ? 24 : _context2.t0 === AsfObject.ExtendedContentDescriptionObjectState.guid.str ? 29 : _context2.t0 === GUID_1.default.CodecListObject.str ? 34 : _context2.t0 === GUID_1.default.StreamBitratePropertiesObject.str ? 41 : _context2.t0 === GUID_1.default.PaddingObject.str ? 44 : 48;
              break;
            case 7:
              _context2.next = 9;
              return this.tokenizer.readToken(new AsfObject.FilePropertiesObject(header));
            case 9:
              fpo = _context2.sent;
              this.metadata.setFormat('duration', Number(fpo.playDuration / BigInt(1000)) / 10000 - Number(fpo.preroll) / 1000);
              this.metadata.setFormat('bitrate', fpo.maximumBitrate);
              return _context2.abrupt("break", 52);
            case 13:
              _context2.next = 15;
              return this.tokenizer.readToken(new AsfObject.StreamPropertiesObject(header));
            case 15:
              spo = _context2.sent;
              this.metadata.setFormat('container', 'ASF/' + spo.streamType);
              return _context2.abrupt("break", 52);
            case 18:
              _context2.next = 20;
              return this.tokenizer.readToken(new AsfObject.HeaderExtensionObject());
            case 20:
              extHeader = _context2.sent;
              _context2.next = 23;
              return this.parseExtensionObject(extHeader.extensionDataSize);
            case 23:
              return _context2.abrupt("break", 52);
            case 24:
              _context2.next = 26;
              return this.tokenizer.readToken(new AsfObject.ContentDescriptionObjectState(header));
            case 26:
              tags = _context2.sent;
              this.addTags(tags);
              return _context2.abrupt("break", 52);
            case 29:
              _context2.next = 31;
              return this.tokenizer.readToken(new AsfObject.ExtendedContentDescriptionObjectState(header));
            case 31:
              tags = _context2.sent;
              this.addTags(tags);
              return _context2.abrupt("break", 52);
            case 34:
              _context2.next = 36;
              return AsfObject.readCodecEntries(this.tokenizer);
            case 36:
              codecs = _context2.sent;
              codecs.forEach(function (codec) {
                _this.metadata.addStreamInfo({
                  type: codec.type.videoCodec ? type_1.TrackType.video : type_1.TrackType.audio,
                  codecName: codec.codecName
                });
              });
              audioCodecs = codecs.filter(function (codec) {
                return codec.type.audioCodec;
              }).map(function (codec) {
                return codec.codecName;
              }).join('/');
              this.metadata.setFormat('codec', audioCodecs);
              return _context2.abrupt("break", 52);
            case 41:
              _context2.next = 43;
              return this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
            case 43:
              return _context2.abrupt("break", 52);
            case 44:
              // ToDo: register bytes pad
              debug('Padding: %s bytes', header.objectSize - AsfObject.HeaderObjectToken.len);
              _context2.next = 47;
              return this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
            case 47:
              return _context2.abrupt("break", 52);
            case 48:
              this.metadata.addWarning('Ignore ASF-Object-GUID: ' + header.objectId.str);
              debug('Ignore ASF-Object-GUID: %s', header.objectId.str);
              _context2.next = 52;
              return this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));
            case 52:
              if (--numberOfObjectHeaders) {
                _context2.next = 0;
                break;
              }
            case 53:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parseObjectHeader(_x) {
        return _parseObjectHeader.apply(this, arguments);
      }
      return parseObjectHeader;
    }()
  }, {
    key: "addTags",
    value: function addTags(tags) {
      var _this2 = this;
      tags.forEach(function (tag) {
        _this2.metadata.addTag(headerType, tag.id, tag.value);
      });
    }
  }, {
    key: "parseExtensionObject",
    value: function () {
      var _parseExtensionObject = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(extensionSize) {
        var header, remaining, moTags, mlTags;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.tokenizer.readToken(AsfObject.HeaderObjectToken);
            case 2:
              header = _context3.sent;
              remaining = header.objectSize - AsfObject.HeaderObjectToken.len; // Parse data part of the ASF Object
              _context3.t0 = header.objectId.str;
              _context3.next = _context3.t0 === AsfObject.ExtendedStreamPropertiesObjectState.guid.str ? 7 : _context3.t0 === AsfObject.MetadataObjectState.guid.str ? 10 : _context3.t0 === AsfObject.MetadataLibraryObjectState.guid.str ? 15 : _context3.t0 === GUID_1.default.PaddingObject.str ? 20 : _context3.t0 === GUID_1.default.CompatibilityObject.str ? 23 : _context3.t0 === GUID_1.default.ASF_Index_Placeholder_Object.str ? 25 : 28;
              break;
            case 7:
              _context3.next = 9;
              return this.tokenizer.readToken(new AsfObject.ExtendedStreamPropertiesObjectState(header));
            case 9:
              return _context3.abrupt("break", 32);
            case 10:
              _context3.next = 12;
              return this.tokenizer.readToken(new AsfObject.MetadataObjectState(header));
            case 12:
              moTags = _context3.sent;
              this.addTags(moTags);
              return _context3.abrupt("break", 32);
            case 15:
              _context3.next = 17;
              return this.tokenizer.readToken(new AsfObject.MetadataLibraryObjectState(header));
            case 17:
              mlTags = _context3.sent;
              this.addTags(mlTags);
              return _context3.abrupt("break", 32);
            case 20:
              _context3.next = 22;
              return this.tokenizer.ignore(remaining);
            case 22:
              return _context3.abrupt("break", 32);
            case 23:
              this.tokenizer.ignore(remaining);
              return _context3.abrupt("break", 32);
            case 25:
              _context3.next = 27;
              return this.tokenizer.ignore(remaining);
            case 27:
              return _context3.abrupt("break", 32);
            case 28:
              this.metadata.addWarning('Ignore ASF-Object-GUID: ' + header.objectId.str);
              // console.log("Ignore ASF-Object-GUID: %s", header.objectId.str);
              _context3.next = 31;
              return this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));
            case 31:
              return _context3.abrupt("break", 32);
            case 32:
              extensionSize -= header.objectSize;
            case 33:
              if (extensionSize > 0) {
                _context3.next = 0;
                break;
              }
            case 34:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function parseExtensionObject(_x2) {
        return _parseExtensionObject.apply(this, arguments);
      }
      return parseExtensionObject;
    }()
  }]);
  return AsfParser;
}(BasicParser_1.BasicParser);
exports.AsfParser = AsfParser;
},{"debug":"node_modules/debug/src/browser.js","../type":"node_modules/music-metadata/lib/type.js","./GUID":"node_modules/music-metadata/lib/asf/GUID.js","./AsfObject":"node_modules/music-metadata/lib/asf/AsfObject.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js"}],"node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdentificationHeader = exports.CommonHeader = exports.VorbisPictureToken = void 0;
var Token = require("token-types");
var ID3v2Token_1 = require("../../id3v2/ID3v2Token");
/**
 * Parse the METADATA_BLOCK_PICTURE
 * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE
 * Ref: https://xiph.org/flac/format.html#metadata_block_picture
 * // ToDo: move to ID3 / APIC?
 */
var VorbisPictureToken = /*#__PURE__*/function () {
  function VorbisPictureToken(len) {
    _classCallCheck(this, VorbisPictureToken);
    this.len = len;
  }
  _createClass(VorbisPictureToken, [{
    key: "get",
    value: function get(buffer, offset) {
      var type = ID3v2Token_1.AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];
      var mimeLen = Token.UINT32_BE.get(buffer, offset += 4);
      var format = buffer.toString('utf-8', offset += 4, offset + mimeLen);
      var descLen = Token.UINT32_BE.get(buffer, offset += mimeLen);
      var description = buffer.toString('utf-8', offset += 4, offset + descLen);
      var width = Token.UINT32_BE.get(buffer, offset += descLen);
      var height = Token.UINT32_BE.get(buffer, offset += 4);
      var colour_depth = Token.UINT32_BE.get(buffer, offset += 4);
      var indexed_color = Token.UINT32_BE.get(buffer, offset += 4);
      var picDataLen = Token.UINT32_BE.get(buffer, offset += 4);
      var data = Buffer.from(buffer.slice(offset += 4, offset + picDataLen));
      return {
        type: type,
        format: format,
        description: description,
        width: width,
        height: height,
        colour_depth: colour_depth,
        indexed_color: indexed_color,
        data: data
      };
    }
  }], [{
    key: "fromBase64",
    value: function fromBase64(base64str) {
      return this.fromBuffer(Buffer.from(base64str, 'base64'));
    }
  }, {
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      var pic = new VorbisPictureToken(buffer.length);
      return pic.get(buffer, 0);
    }
  }]);
  return VorbisPictureToken;
}();
exports.VorbisPictureToken = VorbisPictureToken;
/**
 * Comment header decoder
 * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1
 */
exports.CommonHeader = {
  len: 7,
  get: function get(buf, off) {
    return {
      packetType: buf.readUInt8(off),
      vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)
    };
  }
};
/**
 * Identification header decoder
 * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2
 */
exports.IdentificationHeader = {
  len: 23,
  get: function get(uint8Array, off) {
    var dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset);
    return {
      version: dataView.getUint32(off + 0, true),
      channelMode: dataView.getUint8(off + 4),
      sampleRate: dataView.getUint32(off + 5, true),
      bitrateMax: dataView.getUint32(off + 9, true),
      bitrateNominal: dataView.getUint32(off + 13, true),
      bitrateMin: dataView.getUint32(off + 17, true)
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../../id3v2/ID3v2Token":"node_modules/music-metadata/lib/id3v2/ID3v2Token.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractID3Parser = void 0;
var core_1 = require("strtok3/lib/core");
var debug_1 = require("debug");
var ID3v2Token_1 = require("./ID3v2Token");
var ID3v2Parser_1 = require("./ID3v2Parser");
var ID3v1Parser_1 = require("../id3v1/ID3v1Parser");
var BasicParser_1 = require("../common/BasicParser");
var debug = (0, debug_1.default)('music-metadata:parser:ID3');
/**
 * Abstract parser which tries take ID3v2 and ID3v1 headers.
 */
var AbstractID3Parser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(AbstractID3Parser, _BasicParser_1$BasicP);
  var _super = _createSuper(AbstractID3Parser);
  function AbstractID3Parser() {
    var _this;
    _classCallCheck(this, AbstractID3Parser);
    _this = _super.apply(this, arguments);
    _this.id3parser = new ID3v2Parser_1.ID3v2Parser();
    return _this;
  }
  _createClass(AbstractID3Parser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.parseID3v2();
            case 3:
              _context.next = 12;
              break;
            case 5:
              _context.prev = 5;
              _context.t0 = _context["catch"](0);
              if (!(_context.t0 instanceof core_1.EndOfStreamError)) {
                _context.next = 11;
                break;
              }
              debug("End-of-stream");
              _context.next = 12;
              break;
            case 11:
              throw _context.t0;
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 5]]);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "finalize",
    value: function finalize() {
      return;
    }
  }, {
    key: "parseID3v2",
    value: function () {
      var _parseID3v = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var id3v1parser;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.tryReadId3v2Headers();
            case 2:
              debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);
              _context2.next = 5;
              return this.postId3v2Parse();
            case 5:
              if (!(this.options.skipPostHeaders && this.metadata.hasAny())) {
                _context2.next = 9;
                break;
              }
              this.finalize();
              _context2.next = 13;
              break;
            case 9:
              id3v1parser = new ID3v1Parser_1.ID3v1Parser();
              _context2.next = 12;
              return id3v1parser.init(this.metadata, this.tokenizer, this.options).parse();
            case 12:
              this.finalize();
            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parseID3v2() {
        return _parseID3v.apply(this, arguments);
      }
      return parseID3v2;
    }()
  }, {
    key: "tryReadId3v2Headers",
    value: function () {
      var _tryReadId3v2Headers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var id3Header;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.tokenizer.peekToken(ID3v2Token_1.ID3v2Header);
            case 2:
              id3Header = _context3.sent;
              if (!(id3Header.fileIdentifier === 'ID3')) {
                _context3.next = 8;
                break;
              }
              debug('Found ID3v2 header, pos=%s', this.tokenizer.position);
              _context3.next = 7;
              return this.id3parser.parse(this.metadata, this.tokenizer, this.options);
            case 7:
              return _context3.abrupt("return", this.tryReadId3v2Headers());
            case 8:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function tryReadId3v2Headers() {
        return _tryReadId3v2Headers.apply(this, arguments);
      }
      return tryReadId3v2Headers;
    }()
  }], [{
    key: "startsWithID3v2Header",
    value: function () {
      var _startsWithID3v2Header = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tokenizer) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return tokenizer.peekToken(ID3v2Token_1.ID3v2Header);
            case 2:
              _context4.t0 = _context4.sent.fileIdentifier;
              return _context4.abrupt("return", _context4.t0 === 'ID3');
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function startsWithID3v2Header(_x) {
        return _startsWithID3v2Header.apply(this, arguments);
      }
      return startsWithID3v2Header;
    }()
  }]);
  return AbstractID3Parser;
}(BasicParser_1.BasicParser);
exports.AbstractID3Parser = AbstractID3Parser;
},{"strtok3/lib/core":"node_modules/strtok3/lib/core.js","debug":"node_modules/debug/src/browser.js","./ID3v2Token":"node_modules/music-metadata/lib/id3v2/ID3v2Token.js","./ID3v2Parser":"node_modules/music-metadata/lib/id3v2/ID3v2Parser.js","../id3v1/ID3v1Parser":"node_modules/music-metadata/lib/id3v1/ID3v1Parser.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js"}],"node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VorbisDecoder = void 0;
var Token = require("token-types");
var VorbisDecoder = /*#__PURE__*/function () {
  function VorbisDecoder(data, offset) {
    _classCallCheck(this, VorbisDecoder);
    this.data = data;
    this.offset = offset;
  }
  _createClass(VorbisDecoder, [{
    key: "readInt32",
    value: function readInt32() {
      var value = Token.UINT32_LE.get(this.data, this.offset);
      this.offset += 4;
      return value;
    }
  }, {
    key: "readStringUtf8",
    value: function readStringUtf8() {
      var len = this.readInt32();
      var value = Buffer.from(this.data).toString('utf-8', this.offset, this.offset + len);
      this.offset += len;
      return value;
    }
  }, {
    key: "parseUserComment",
    value: function parseUserComment() {
      var offset0 = this.offset;
      var v = this.readStringUtf8();
      var idx = v.indexOf('=');
      return {
        key: v.slice(0, idx).toUpperCase(),
        value: v.slice(idx + 1),
        len: this.offset - offset0
      };
    }
  }]);
  return VorbisDecoder;
}();
exports.VorbisDecoder = VorbisDecoder;
},{"token-types":"node_modules/token-types/lib/index.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VorbisParser = void 0;
var Token = require("token-types");
var debug_1 = require("debug");
var VorbisDecoder_1 = require("./VorbisDecoder");
var Vorbis_1 = require("./Vorbis");
var debug = (0, debug_1.default)('music-metadata:parser:ogg:vorbis1');
/**
 * Vorbis 1 Parser.
 * Used by OggParser
 */
var VorbisParser = /*#__PURE__*/function () {
  function VorbisParser(metadata, options) {
    _classCallCheck(this, VorbisParser);
    this.metadata = metadata;
    this.options = options;
    this.pageSegments = [];
  }
  /**
   * Vorbis 1 parser
   * @param header Ogg Page Header
   * @param pageData Page data
   */
  _createClass(VorbisParser, [{
    key: "parsePage",
    value: function parsePage(header, pageData) {
      if (header.headerType.firstPage) {
        this.parseFirstPage(header, pageData);
      } else {
        if (header.headerType.continued) {
          if (this.pageSegments.length === 0) {
            throw new Error("Cannot continue on previous page");
          }
          this.pageSegments.push(pageData);
        }
        if (header.headerType.lastPage || !header.headerType.continued) {
          // Flush page segments
          if (this.pageSegments.length > 0) {
            var fullPage = Buffer.concat(this.pageSegments);
            this.parseFullPage(fullPage);
          }
          // Reset page segments
          this.pageSegments = header.headerType.lastPage ? [] : [pageData];
        }
      }
      if (header.headerType.lastPage) {
        this.calculateDuration(header);
      }
    }
  }, {
    key: "flush",
    value: function flush() {
      this.parseFullPage(Buffer.concat(this.pageSegments));
    }
  }, {
    key: "parseUserComment",
    value: function parseUserComment(pageData, offset) {
      var decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);
      var tag = decoder.parseUserComment();
      this.addTag(tag.key, tag.value);
      return tag.len;
    }
  }, {
    key: "addTag",
    value: function addTag(id, value) {
      if (id === 'METADATA_BLOCK_PICTURE' && typeof value === 'string') {
        if (this.options.skipCovers) {
          debug("Ignore picture");
          return;
        }
        value = Vorbis_1.VorbisPictureToken.fromBase64(value);
        debug("Push picture: id=".concat(id, ", format=").concat(value.format));
      } else {
        debug("Push tag: id=".concat(id, ", value=").concat(value));
      }
      this.metadata.addTag('vorbis', id, value);
    }
  }, {
    key: "calculateDuration",
    value: function calculateDuration(header) {
      if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
        // Calculate duration
        this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);
        this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
      }
    }
    /**
     * Parse first Ogg/Vorbis page
     * @param {IPageHeader} header
     * @param {Buffer} pageData
     */
  }, {
    key: "parseFirstPage",
    value: function parseFirstPage(header, pageData) {
      this.metadata.setFormat('codec', 'Vorbis I');
      debug("Parse first page");
      // Parse  Vorbis common header
      var commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);
      if (commonHeader.vorbis !== 'vorbis') throw new Error('Metadata does not look like Vorbis');
      if (commonHeader.packetType === 1) {
        var idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);
        this.metadata.setFormat('sampleRate', idHeader.sampleRate);
        this.metadata.setFormat('bitrate', idHeader.bitrateNominal);
        this.metadata.setFormat('numberOfChannels', idHeader.channelMode);
        debug("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);
      } else throw new Error('First Ogg page should be type 1: the identification header');
    }
  }, {
    key: "parseFullPage",
    value: function parseFullPage(pageData) {
      // New page
      var commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);
      debug("Parse full page: type=%s, byteLength=%s", commonHeader.packetType, pageData.byteLength);
      switch (commonHeader.packetType) {
        case 3:
          //  type 3: comment header
          return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);
        case 1: // type 1: the identification header
        case 5:
          // type 5: setup header type
          break;
        // ignore
      }
    }
    /**
     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
     */
  }, {
    key: "parseUserCommentList",
    value: function parseUserCommentList(pageData, offset) {
      var strLen = Token.UINT32_LE.get(pageData, offset);
      offset += 4;
      // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);
      offset += strLen;
      var userCommentListLength = Token.UINT32_LE.get(pageData, offset);
      offset += 4;
      while (userCommentListLength-- > 0) {
        offset += this.parseUserComment(pageData, offset);
      }
    }
  }]);
  return VorbisParser;
}();
exports.VorbisParser = VorbisParser;
},{"token-types":"node_modules/token-types/lib/index.js","debug":"node_modules/debug/src/browser.js","./VorbisDecoder":"node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","./Vorbis":"node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/flac/FlacParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlacParser = void 0;
var token_types_1 = require("token-types");
var debug_1 = require("debug");
var util = require("../common/Util");
var Vorbis_1 = require("../ogg/vorbis/Vorbis");
var AbstractID3Parser_1 = require("../id3v2/AbstractID3Parser");
var FourCC_1 = require("../common/FourCC");
var VorbisParser_1 = require("../ogg/vorbis/VorbisParser");
var VorbisDecoder_1 = require("../ogg/vorbis/VorbisDecoder");
var debug = (0, debug_1.default)('music-metadata:parser:FLAC');
/**
 * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:
 * ref: https://xiph.org/flac/format.html#metadata_block
 */
var BlockType;
(function (BlockType) {
  BlockType[BlockType["STREAMINFO"] = 0] = "STREAMINFO";
  BlockType[BlockType["PADDING"] = 1] = "PADDING";
  BlockType[BlockType["APPLICATION"] = 2] = "APPLICATION";
  BlockType[BlockType["SEEKTABLE"] = 3] = "SEEKTABLE";
  BlockType[BlockType["VORBIS_COMMENT"] = 4] = "VORBIS_COMMENT";
  BlockType[BlockType["CUESHEET"] = 5] = "CUESHEET";
  BlockType[BlockType["PICTURE"] = 6] = "PICTURE";
})(BlockType || (BlockType = {}));
var FlacParser = /*#__PURE__*/function (_AbstractID3Parser_1$) {
  _inherits(FlacParser, _AbstractID3Parser_1$);
  var _super = _createSuper(FlacParser);
  function FlacParser() {
    var _this;
    _classCallCheck(this, FlacParser);
    _this = _super.apply(this, arguments);
    _this.padding = 0;
    return _this;
  }
  /**
   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
   * @param {INativeMetadataCollector} metadata Output
   * @param {ITokenizer} tokenizer Input
   * @param {IOptions} options Parsing options
   */
  _createClass(FlacParser, [{
    key: "init",
    value: function init(metadata, tokenizer, options) {
      _get(_getPrototypeOf(FlacParser.prototype), "init", this).call(this, metadata, tokenizer, options);
      this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);
      return this;
    }
  }, {
    key: "postId3v2Parse",
    value: function () {
      var _postId3v2Parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var fourCC, blockHeader, dataSize;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.readToken(FourCC_1.FourCcToken);
            case 2:
              fourCC = _context.sent;
              if (!(fourCC.toString() !== 'fLaC')) {
                _context.next = 5;
                break;
              }
              throw new Error('Invalid FLAC preamble');
            case 5:
              _context.next = 7;
              return this.tokenizer.readToken(Metadata.BlockHeader);
            case 7:
              blockHeader = _context.sent;
              _context.next = 10;
              return this.parseDataBlock(blockHeader);
            case 10:
              if (!blockHeader.lastBlock) {
                _context.next = 5;
                break;
              }
            case 11:
              if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
                dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;
                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);
              }
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function postId3v2Parse() {
        return _postId3v2Parse.apply(this, arguments);
      }
      return postId3v2Parse;
    }()
  }, {
    key: "parseDataBlock",
    value: function parseDataBlock(blockHeader) {
      debug("blockHeader type=".concat(blockHeader.type, ", length=").concat(blockHeader.length));
      switch (blockHeader.type) {
        case BlockType.STREAMINFO:
          return this.parseBlockStreamInfo(blockHeader.length);
        case BlockType.PADDING:
          this.padding += blockHeader.length;
          break;
        case BlockType.APPLICATION:
          break;
        case BlockType.SEEKTABLE:
          break;
        case BlockType.VORBIS_COMMENT:
          return this.parseComment(blockHeader.length);
        case BlockType.CUESHEET:
          break;
        case BlockType.PICTURE:
          return this.parsePicture(blockHeader.length).then();
        default:
          this.metadata.addWarning('Unknown block type: ' + blockHeader.type);
      }
      // Ignore data block
      return this.tokenizer.ignore(blockHeader.length).then();
    }
    /**
     * Parse STREAMINFO
     */
  }, {
    key: "parseBlockStreamInfo",
    value: function () {
      var _parseBlockStreamInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(dataLen) {
        var streamInfo;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(dataLen !== Metadata.BlockStreamInfo.len)) {
                _context2.next = 2;
                break;
              }
              throw new Error('Unexpected block-stream-info length');
            case 2:
              _context2.next = 4;
              return this.tokenizer.readToken(Metadata.BlockStreamInfo);
            case 4:
              streamInfo = _context2.sent;
              this.metadata.setFormat('container', 'FLAC');
              this.metadata.setFormat('codec', 'FLAC');
              this.metadata.setFormat('lossless', true);
              this.metadata.setFormat('numberOfChannels', streamInfo.channels);
              this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);
              this.metadata.setFormat('sampleRate', streamInfo.sampleRate);
              if (streamInfo.totalSamples > 0) {
                this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);
              }
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parseBlockStreamInfo(_x) {
        return _parseBlockStreamInfo.apply(this, arguments);
      }
      return parseBlockStreamInfo;
    }()
    /**
     * Parse VORBIS_COMMENT
     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
     */
  }, {
    key: "parseComment",
    value: function () {
      var _parseComment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(dataLen) {
        var data, decoder, commentListLength, i, tag;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.tokenizer.readToken(new token_types_1.Uint8ArrayType(dataLen));
            case 2:
              data = _context3.sent;
              decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);
              decoder.readStringUtf8(); // vendor (skip)
              commentListLength = decoder.readInt32();
              for (i = 0; i < commentListLength; i++) {
                tag = decoder.parseUserComment();
                this.vorbisParser.addTag(tag.key, tag.value);
              }
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function parseComment(_x2) {
        return _parseComment.apply(this, arguments);
      }
      return parseComment;
    }()
  }, {
    key: "parsePicture",
    value: function () {
      var _parsePicture = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(dataLen) {
        var picture;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!this.options.skipCovers) {
                _context4.next = 4;
                break;
              }
              return _context4.abrupt("return", this.tokenizer.ignore(dataLen));
            case 4:
              _context4.next = 6;
              return this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));
            case 6:
              picture = _context4.sent;
              this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);
            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function parsePicture(_x3) {
        return _parsePicture.apply(this, arguments);
      }
      return parsePicture;
    }()
  }]);
  return FlacParser;
}(AbstractID3Parser_1.AbstractID3Parser);
exports.FlacParser = FlacParser;
var Metadata = /*#__PURE__*/_createClass(function Metadata() {
  _classCallCheck(this, Metadata);
});
Metadata.BlockHeader = {
  len: 4,
  get: function get(buf, off) {
    return {
      lastBlock: util.getBit(buf, off, 7),
      type: util.getBitAllignedNumber(buf, off, 1, 7),
      length: token_types_1.UINT24_BE.get(buf, off + 1)
    };
  }
};
/**
 * METADATA_BLOCK_DATA
 * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo
 */
Metadata.BlockStreamInfo = {
  len: 34,
  get: function get(buf, off) {
    return {
      // The minimum block size (in samples) used in the stream.
      minimumBlockSize: token_types_1.UINT16_BE.get(buf, off),
      // The maximum block size (in samples) used in the stream.
      // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
      maximumBlockSize: token_types_1.UINT16_BE.get(buf, off + 2) / 1000,
      // The minimum frame size (in bytes) used in the stream.
      // May be 0 to imply the value is not known.
      minimumFrameSize: token_types_1.UINT24_BE.get(buf, off + 4),
      // The maximum frame size (in bytes) used in the stream.
      // May be 0 to imply the value is not known.
      maximumFrameSize: token_types_1.UINT24_BE.get(buf, off + 7),
      // Sample rate in Hz. Though 20 bits are available,
      // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
      // Also, a value of 0 is invalid.
      sampleRate: token_types_1.UINT24_BE.get(buf, off + 10) >> 4,
      // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
      // (number of channels)-1. FLAC supports from 1 to 8 channels
      channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,
      // bits per sample)-1.
      // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
      bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,
      // Total samples in stream.
      // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
      // A value of zero here means the number of total samples is unknown.
      totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),
      // the MD5 hash of the file (see notes for usage... it's a littly tricky)
      fileMD5: new token_types_1.Uint8ArrayType(16).get(buf, off + 18)
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","debug":"node_modules/debug/src/browser.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","../ogg/vorbis/Vorbis":"node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","../id3v2/AbstractID3Parser":"node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js","../ogg/vorbis/VorbisParser":"node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js","../ogg/vorbis/VorbisDecoder":"node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js"}],"node_modules/music-metadata/lib/mp4/AtomToken.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChapterText = exports.StcoAtom = exports.StszAtom = exports.StscAtom = exports.SampleToChunkToken = exports.SttsAtom = exports.TimeToSampleToken = exports.SoundSampleDescriptionV0 = exports.SoundSampleDescriptionVersion = exports.StsdAtom = exports.TrackHeaderAtom = exports.NameAtom = exports.DataAtom = exports.MvhdAtom = exports.MdhdAtom = exports.FixedLengthAtom = exports.mhdr = exports.tkhd = exports.ftyp = exports.ExtendedSize = exports.Header = void 0;
var Token = require("token-types");
var debug_1 = require("debug");
var FourCC_1 = require("../common/FourCC");
var debug = (0, debug_1.default)('music-metadata:parser:MP4:atom');
exports.Header = {
  len: 8,
  get: function get(buf, off) {
    var length = Token.UINT32_BE.get(buf, off);
    if (length < 0) throw new Error('Invalid atom header length');
    return {
      length: BigInt(length),
      name: new Token.StringType(4, 'binary').get(buf, off + 4)
    };
  },
  put: function put(buf, off, hdr) {
    Token.UINT32_BE.put(buf, off, Number(hdr.length));
    return FourCC_1.FourCcToken.put(buf, off + 4, hdr.name);
  }
};
/**
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190
 */
exports.ExtendedSize = Token.UINT64_BE;
exports.ftyp = {
  len: 4,
  get: function get(buf, off) {
    return {
      type: new Token.StringType(4, 'ascii').get(buf, off)
    };
  }
};
exports.tkhd = {
  len: 4,
  get: function get(buf, off) {
    return {
      type: new Token.StringType(4, 'ascii').get(buf, off)
    };
  }
};
/**
 * Token: Movie Header Atom
 */
exports.mhdr = {
  len: 8,
  get: function get(buf, off) {
    return {
      version: Token.UINT8.get(buf, off),
      flags: Token.UINT24_BE.get(buf, off + 1),
      nextItemID: Token.UINT32_BE.get(buf, off + 4)
    };
  }
};
/**
 * Base class for 'fixed' length atoms.
 * In some cases these atoms are longer then the sum of the described fields.
 * Issue: https://github.com/Borewit/music-metadata/issues/120
 */
var FixedLengthAtom = /*#__PURE__*/_createClass(
/**
 *
 * @param {number} len Length as specified in the size field
 * @param {number} expLen Total length of sum of specified fields in the standard
 */
function FixedLengthAtom(len, expLen, atomId) {
  _classCallCheck(this, FixedLengthAtom);
  this.len = len;
  if (len < expLen) {
    throw new Error("Atom ".concat(atomId, " expected to be ").concat(expLen, ", but specifies ").concat(len, " bytes long."));
  } else if (len > expLen) {
    debug("Warning: atom ".concat(atomId, " expected to be ").concat(expLen, ", but was actually ").concat(len, " bytes long."));
  }
});
exports.FixedLengthAtom = FixedLengthAtom;
/**
 * Timestamp stored in seconds since Mac Epoch (1 January 1904)
 */
var SecondsSinceMacEpoch = {
  len: 4,
  get: function get(buf, off) {
    var secondsSinceUnixEpoch = Token.UINT32_BE.get(buf, off) - 2082844800;
    return new Date(secondsSinceUnixEpoch * 1000);
  }
};
/**
 * Token: Media Header Atom
 * Ref:
 * - https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34
 * - https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd
 */
var MdhdAtom = /*#__PURE__*/function (_FixedLengthAtom) {
  _inherits(MdhdAtom, _FixedLengthAtom);
  var _super = _createSuper(MdhdAtom);
  function MdhdAtom(len) {
    var _this;
    _classCallCheck(this, MdhdAtom);
    _this = _super.call(this, len, 24, 'mdhd');
    _this.len = len;
    return _this;
  }
  _createClass(MdhdAtom, [{
    key: "get",
    value: function get(buf, off) {
      return {
        version: Token.UINT8.get(buf, off + 0),
        flags: Token.UINT24_BE.get(buf, off + 1),
        creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
        modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
        timeScale: Token.UINT32_BE.get(buf, off + 12),
        duration: Token.UINT32_BE.get(buf, off + 16),
        language: Token.UINT16_BE.get(buf, off + 20),
        quality: Token.UINT16_BE.get(buf, off + 22)
      };
    }
  }]);
  return MdhdAtom;
}(FixedLengthAtom);
exports.MdhdAtom = MdhdAtom;
/**
 * Token: Movie Header Atom
 */
var MvhdAtom = /*#__PURE__*/function (_FixedLengthAtom2) {
  _inherits(MvhdAtom, _FixedLengthAtom2);
  var _super2 = _createSuper(MvhdAtom);
  function MvhdAtom(len) {
    var _this2;
    _classCallCheck(this, MvhdAtom);
    _this2 = _super2.call(this, len, 100, 'mvhd');
    _this2.len = len;
    return _this2;
  }
  _createClass(MvhdAtom, [{
    key: "get",
    value: function get(buf, off) {
      return {
        version: Token.UINT8.get(buf, off),
        flags: Token.UINT24_BE.get(buf, off + 1),
        creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
        modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
        timeScale: Token.UINT32_BE.get(buf, off + 12),
        duration: Token.UINT32_BE.get(buf, off + 16),
        preferredRate: Token.UINT32_BE.get(buf, off + 20),
        preferredVolume: Token.UINT16_BE.get(buf, off + 24),
        // ignore reserver: 10 bytes
        // ignore matrix structure: 36 bytes
        previewTime: Token.UINT32_BE.get(buf, off + 72),
        previewDuration: Token.UINT32_BE.get(buf, off + 76),
        posterTime: Token.UINT32_BE.get(buf, off + 80),
        selectionTime: Token.UINT32_BE.get(buf, off + 84),
        selectionDuration: Token.UINT32_BE.get(buf, off + 88),
        currentTime: Token.UINT32_BE.get(buf, off + 92),
        nextTrackID: Token.UINT32_BE.get(buf, off + 96)
      };
    }
  }]);
  return MvhdAtom;
}(FixedLengthAtom);
exports.MvhdAtom = MvhdAtom;
/**
 * Data Atom Structure
 */
var DataAtom = /*#__PURE__*/function () {
  function DataAtom(len) {
    _classCallCheck(this, DataAtom);
    this.len = len;
  }
  _createClass(DataAtom, [{
    key: "get",
    value: function get(buf, off) {
      return {
        type: {
          set: Token.UINT8.get(buf, off + 0),
          type: Token.UINT24_BE.get(buf, off + 1)
        },
        locale: Token.UINT24_BE.get(buf, off + 4),
        value: Buffer.from(new Token.Uint8ArrayType(this.len - 8).get(buf, off + 8))
      };
    }
  }]);
  return DataAtom;
}();
exports.DataAtom = DataAtom;
/**
 * Data Atom Structure
 * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31
 */
var NameAtom = /*#__PURE__*/function () {
  function NameAtom(len) {
    _classCallCheck(this, NameAtom);
    this.len = len;
  }
  _createClass(NameAtom, [{
    key: "get",
    value: function get(buf, off) {
      return {
        version: Token.UINT8.get(buf, off),
        flags: Token.UINT24_BE.get(buf, off + 1),
        name: new Token.StringType(this.len - 4, 'utf-8').get(buf, off + 4)
      };
    }
  }]);
  return NameAtom;
}();
exports.NameAtom = NameAtom;
/**
 * Track Header Atoms structure
 * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550
 */
var TrackHeaderAtom = /*#__PURE__*/function () {
  function TrackHeaderAtom(len) {
    _classCallCheck(this, TrackHeaderAtom);
    this.len = len;
  }
  _createClass(TrackHeaderAtom, [{
    key: "get",
    value: function get(buf, off) {
      return {
        version: Token.UINT8.get(buf, off),
        flags: Token.UINT24_BE.get(buf, off + 1),
        creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
        modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
        trackId: Token.UINT32_BE.get(buf, off + 12),
        // reserved 4 bytes
        duration: Token.UINT32_BE.get(buf, off + 20),
        layer: Token.UINT16_BE.get(buf, off + 24),
        alternateGroup: Token.UINT16_BE.get(buf, off + 26),
        volume: Token.UINT16_BE.get(buf, off + 28) // ToDo: fixed point
        // ToDo: add remaining fields
      };
    }
  }]);
  return TrackHeaderAtom;
}();
exports.TrackHeaderAtom = TrackHeaderAtom;
/**
 * Atom: Sample Description Atom ('stsd')
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691
 */
var stsdHeader = {
  len: 8,
  get: function get(buf, off) {
    return {
      version: Token.UINT8.get(buf, off),
      flags: Token.UINT24_BE.get(buf, off + 1),
      numberOfEntries: Token.UINT32_BE.get(buf, off + 4)
    };
  }
};
/**
 * Atom: Sample Description Atom ('stsd')
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691
 */
var SampleDescriptionTable = /*#__PURE__*/function () {
  function SampleDescriptionTable(len) {
    _classCallCheck(this, SampleDescriptionTable);
    this.len = len;
  }
  _createClass(SampleDescriptionTable, [{
    key: "get",
    value: function get(buf, off) {
      return {
        dataFormat: FourCC_1.FourCcToken.get(buf, off),
        dataReferenceIndex: Token.UINT16_BE.get(buf, off + 10),
        description: new Token.Uint8ArrayType(this.len - 12).get(buf, off + 12)
      };
    }
  }]);
  return SampleDescriptionTable;
}();
/**
 * Atom: Sample-description Atom ('stsd')
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691
 */
var StsdAtom = /*#__PURE__*/function () {
  function StsdAtom(len) {
    _classCallCheck(this, StsdAtom);
    this.len = len;
  }
  _createClass(StsdAtom, [{
    key: "get",
    value: function get(buf, off) {
      var header = stsdHeader.get(buf, off);
      off += stsdHeader.len;
      var table = [];
      for (var n = 0; n < header.numberOfEntries; ++n) {
        var size = Token.UINT32_BE.get(buf, off); // Sample description size
        off += Token.UINT32_BE.len;
        table.push(new SampleDescriptionTable(size).get(buf, off));
        off += size;
      }
      return {
        header: header,
        table: table
      };
    }
  }]);
  return StsdAtom;
}();
exports.StsdAtom = StsdAtom;
/**
 * Common Sound Sample Description (version & revision)
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317
 */
exports.SoundSampleDescriptionVersion = {
  len: 8,
  get: function get(buf, off) {
    return {
      version: Token.INT16_BE.get(buf, off),
      revision: Token.INT16_BE.get(buf, off + 2),
      vendor: Token.INT32_BE.get(buf, off + 4)
    };
  }
};
/**
 * Sound Sample Description (Version 0)
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736
 */
exports.SoundSampleDescriptionV0 = {
  len: 12,
  get: function get(buf, off) {
    return {
      numAudioChannels: Token.INT16_BE.get(buf, off + 0),
      sampleSize: Token.INT16_BE.get(buf, off + 2),
      compressionId: Token.INT16_BE.get(buf, off + 4),
      packetSize: Token.INT16_BE.get(buf, off + 6),
      sampleRate: Token.UINT16_BE.get(buf, off + 8) + Token.UINT16_BE.get(buf, off + 10) / 10000
    };
  }
};
var SimpleTableAtom = /*#__PURE__*/function () {
  function SimpleTableAtom(len, token) {
    _classCallCheck(this, SimpleTableAtom);
    this.len = len;
    this.token = token;
  }
  _createClass(SimpleTableAtom, [{
    key: "get",
    value: function get(buf, off) {
      var nrOfEntries = Token.INT32_BE.get(buf, off + 4);
      return {
        version: Token.INT8.get(buf, off + 0),
        flags: Token.INT24_BE.get(buf, off + 1),
        numberOfEntries: nrOfEntries,
        entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)
      };
    }
  }]);
  return SimpleTableAtom;
}();
exports.TimeToSampleToken = {
  len: 8,
  get: function get(buf, off) {
    return {
      count: Token.INT32_BE.get(buf, off + 0),
      duration: Token.INT32_BE.get(buf, off + 4)
    };
  }
};
/**
 * Time-to-sample('stts') atom.
 * Store duration information for a media’s samples.
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696
 */
var SttsAtom = /*#__PURE__*/function (_SimpleTableAtom) {
  _inherits(SttsAtom, _SimpleTableAtom);
  var _super3 = _createSuper(SttsAtom);
  function SttsAtom(len) {
    var _this3;
    _classCallCheck(this, SttsAtom);
    _this3 = _super3.call(this, len, exports.TimeToSampleToken);
    _this3.len = len;
    return _this3;
  }
  return _createClass(SttsAtom);
}(SimpleTableAtom);
exports.SttsAtom = SttsAtom;
exports.SampleToChunkToken = {
  len: 12,
  get: function get(buf, off) {
    return {
      firstChunk: Token.INT32_BE.get(buf, off),
      samplesPerChunk: Token.INT32_BE.get(buf, off + 4),
      sampleDescriptionId: Token.INT32_BE.get(buf, off + 8)
    };
  }
};
/**
 * Sample-to-Chunk ('stsc') atom interface
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706
 */
var StscAtom = /*#__PURE__*/function (_SimpleTableAtom2) {
  _inherits(StscAtom, _SimpleTableAtom2);
  var _super4 = _createSuper(StscAtom);
  function StscAtom(len) {
    var _this4;
    _classCallCheck(this, StscAtom);
    _this4 = _super4.call(this, len, exports.SampleToChunkToken);
    _this4.len = len;
    return _this4;
  }
  return _createClass(StscAtom);
}(SimpleTableAtom);
exports.StscAtom = StscAtom;
/**
 * Sample-size ('stsz') atom
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710
 */
var StszAtom = /*#__PURE__*/function () {
  function StszAtom(len) {
    _classCallCheck(this, StszAtom);
    this.len = len;
  }
  _createClass(StszAtom, [{
    key: "get",
    value: function get(buf, off) {
      var nrOfEntries = Token.INT32_BE.get(buf, off + 8);
      return {
        version: Token.INT8.get(buf, off),
        flags: Token.INT24_BE.get(buf, off + 1),
        sampleSize: Token.INT32_BE.get(buf, off + 4),
        numberOfEntries: nrOfEntries,
        entries: readTokenTable(buf, Token.INT32_BE, off + 12, this.len - 12, nrOfEntries)
      };
    }
  }]);
  return StszAtom;
}();
exports.StszAtom = StszAtom;
/**
 * Chunk offset atom, 'stco'
 * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715
 */
var StcoAtom = /*#__PURE__*/function (_SimpleTableAtom3) {
  _inherits(StcoAtom, _SimpleTableAtom3);
  var _super5 = _createSuper(StcoAtom);
  function StcoAtom(len) {
    var _this5;
    _classCallCheck(this, StcoAtom);
    _this5 = _super5.call(this, len, Token.INT32_BE);
    _this5.len = len;
    return _this5;
  }
  return _createClass(StcoAtom);
}(SimpleTableAtom);
exports.StcoAtom = StcoAtom;
/**
 * Token used to decode text-track from 'mdat' atom (raw data stream)
 */
var ChapterText = /*#__PURE__*/function () {
  function ChapterText(len) {
    _classCallCheck(this, ChapterText);
    this.len = len;
  }
  _createClass(ChapterText, [{
    key: "get",
    value: function get(buf, off) {
      var titleLen = Token.INT16_BE.get(buf, off + 0);
      var str = new Token.StringType(titleLen, 'utf-8');
      return str.get(buf, off + 2);
    }
  }]);
  return ChapterText;
}();
exports.ChapterText = ChapterText;
function readTokenTable(buf, token, off, remainingLen, numberOfEntries) {
  debug("remainingLen=".concat(remainingLen, ", numberOfEntries=").concat(numberOfEntries, " * token-len=").concat(token.len));
  if (remainingLen === 0) return [];
  if (remainingLen !== numberOfEntries * token.len) throw new Error('mismatch number-of-entries with remaining atom-length');
  var entries = [];
  // parse offset-table
  for (var n = 0; n < numberOfEntries; ++n) {
    entries.push(token.get(buf, off));
    off += token.len;
  }
  return entries;
}
},{"token-types":"node_modules/token-types/lib/index.js","debug":"node_modules/debug/src/browser.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/mp4/Atom.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Atom = void 0;
var debug_1 = require("debug");
var AtomToken = require("./AtomToken");
var debug = (0, debug_1.default)('music-metadata:parser:MP4:Atom');
var Atom = /*#__PURE__*/function () {
  function Atom(header, extended, parent) {
    _classCallCheck(this, Atom);
    this.header = header;
    this.extended = extended;
    this.parent = parent;
    this.children = [];
    this.atomPath = (this.parent ? this.parent.atomPath + '.' : '') + this.header.name;
  }
  _createClass(Atom, [{
    key: "getHeaderLength",
    value: function getHeaderLength() {
      return this.extended ? 16 : 8;
    }
  }, {
    key: "getPayloadLength",
    value: function getPayloadLength(remaining) {
      return (this.header.length === BigInt(0) ? remaining : Number(this.header.length)) - this.getHeaderLength();
    }
  }, {
    key: "readAtoms",
    value: function () {
      var _readAtoms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenizer, dataHandler, size) {
        var atomBean;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(size > 0)) {
                _context.next = 8;
                break;
              }
              _context.next = 3;
              return Atom.readAtom(tokenizer, dataHandler, this, size);
            case 3:
              atomBean = _context.sent;
              this.children.push(atomBean);
              size -= atomBean.header.length === BigInt(0) ? size : Number(atomBean.header.length);
              _context.next = 0;
              break;
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function readAtoms(_x, _x2, _x3) {
        return _readAtoms.apply(this, arguments);
      }
      return readAtoms;
    }()
  }, {
    key: "readData",
    value: function () {
      var _readData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tokenizer, dataHandler, remaining) {
        var peekHeader, paddingLength;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.t0 = this.header.name;
              _context2.next = _context2.t0 === 'moov' ? 3 : _context2.t0 === 'udta' ? 3 : _context2.t0 === 'trak' ? 3 : _context2.t0 === 'mdia' ? 3 : _context2.t0 === 'minf' ? 3 : _context2.t0 === 'stbl' ? 3 : _context2.t0 === '<id>' ? 3 : _context2.t0 === 'ilst' ? 3 : _context2.t0 === 'tref' ? 3 : _context2.t0 === 'meta' ? 4 : _context2.t0 === 'mdhd' ? 11 : _context2.t0 === 'mvhd' ? 11 : _context2.t0 === 'tkhd' ? 11 : _context2.t0 === 'stsz' ? 11 : _context2.t0 === 'mdat' ? 11 : 11;
              break;
            case 3:
              return _context2.abrupt("return", this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining)));
            case 4:
              _context2.next = 6;
              return tokenizer.peekToken(AtomToken.Header);
            case 6:
              peekHeader = _context2.sent;
              paddingLength = peekHeader.name === 'hdlr' ? 0 : 4;
              _context2.next = 10;
              return tokenizer.ignore(paddingLength);
            case 10:
              return _context2.abrupt("return", this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength));
            case 11:
              return _context2.abrupt("return", dataHandler(this, remaining));
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function readData(_x4, _x5, _x6) {
        return _readData.apply(this, arguments);
      }
      return readData;
    }()
  }], [{
    key: "readAtom",
    value: function () {
      var _readAtom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tokenizer, dataHandler, parent, remaining) {
        var offset, header, extended, atomBean, payloadLength;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              // Parse atom header
              offset = tokenizer.position; // debug(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')
              _context3.next = 3;
              return tokenizer.readToken(AtomToken.Header);
            case 3:
              header = _context3.sent;
              extended = header.length === BigInt(1);
              if (!extended) {
                _context3.next = 9;
                break;
              }
              _context3.next = 8;
              return tokenizer.readToken(AtomToken.ExtendedSize);
            case 8:
              header.length = _context3.sent;
            case 9:
              atomBean = new Atom(header, header.length === BigInt(1), parent);
              payloadLength = atomBean.getPayloadLength(remaining);
              debug("parse atom name=".concat(atomBean.atomPath, ", extended=").concat(atomBean.extended, ", offset=").concat(offset, ", len=").concat(atomBean.header.length)); //  buf.toString('ascii')
              _context3.next = 14;
              return atomBean.readData(tokenizer, dataHandler, payloadLength);
            case 14:
              return _context3.abrupt("return", atomBean);
            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function readAtom(_x7, _x8, _x9, _x10) {
        return _readAtom.apply(this, arguments);
      }
      return readAtom;
    }()
  }]);
  return Atom;
}();
exports.Atom = Atom;
},{"debug":"node_modules/debug/src/browser.js","./AtomToken":"node_modules/music-metadata/lib/mp4/AtomToken.js"}],"node_modules/music-metadata/lib/mp4/MP4Parser.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MP4Parser = void 0;
var debug_1 = require("debug");
var Token = require("token-types");
var BasicParser_1 = require("../common/BasicParser");
var ID3v1Parser_1 = require("../id3v1/ID3v1Parser");
var type_1 = require("../type");
var Atom_1 = require("./Atom");
var AtomToken = require("./AtomToken");
var debug = (0, debug_1.default)('music-metadata:parser:MP4');
var tagFormat = 'iTunes';
var encoderDict = {
  raw: {
    lossy: false,
    format: 'raw'
  },
  MAC3: {
    lossy: true,
    format: 'MACE 3:1'
  },
  MAC6: {
    lossy: true,
    format: 'MACE 6:1'
  },
  ima4: {
    lossy: true,
    format: 'IMA 4:1'
  },
  ulaw: {
    lossy: true,
    format: 'uLaw 2:1'
  },
  alaw: {
    lossy: true,
    format: 'uLaw 2:1'
  },
  Qclp: {
    lossy: true,
    format: 'QUALCOMM PureVoice'
  },
  '.mp3': {
    lossy: true,
    format: 'MPEG-1 layer 3'
  },
  alac: {
    lossy: false,
    format: 'ALAC'
  },
  'ac-3': {
    lossy: true,
    format: 'AC-3'
  },
  mp4a: {
    lossy: true,
    format: 'MPEG-4/AAC'
  },
  mp4s: {
    lossy: true,
    format: 'MP4S'
  },
  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
  c608: {
    lossy: true,
    format: 'CEA-608'
  },
  c708: {
    lossy: true,
    format: 'CEA-708'
  }
};
function distinct(value, index, self) {
  return self.indexOf(value) === index;
}
/*
 * Parser for the MP4 (MPEG-4 Part 14) container format
 * Standard: ISO/IEC 14496-14
 * supporting:
 * - QuickTime container
 * - MP4 File Format
 * - 3GPP file format
 * - 3GPP2 file format
 *
 * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.
 * Support for Apple iTunes tags as found in a M4A/M4V files.
 * Ref:
 *   https://en.wikipedia.org/wiki/ISO_base_media_file_format
 *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html
 *   http://atomicparsley.sourceforge.net/mpeg-4files.html
 *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata
 *   https://wiki.multimedia.cx/index.php/QuickTime_container
 */
var MP4Parser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(MP4Parser, _BasicParser_1$BasicP);
  var _super = _createSuper(MP4Parser);
  function MP4Parser() {
    var _this;
    _classCallCheck(this, MP4Parser);
    _this = _super.apply(this, arguments);
    _this.atomParsers = {
      /**
       * Parse movie header (mvhd) atom
       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
       */
      mvhd: function () {
        var _mvhd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(len) {
          var mvhd;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.tokenizer.readToken(new AtomToken.MvhdAtom(len));
              case 2:
                mvhd = _context.sent;
                _this.metadata.setFormat('creationTime', mvhd.creationTime);
                _this.metadata.setFormat('modificationTime', mvhd.modificationTime);
              case 5:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function mvhd(_x) {
          return _mvhd.apply(this, arguments);
        }
        return mvhd;
      }(),
      /**
       * Parse media header (mdhd) atom
       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615
       */
      mdhd: function () {
        var _mdhd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(len) {
          var mdhd_data, td;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this.tokenizer.readToken(new AtomToken.MdhdAtom(len));
              case 2:
                mdhd_data = _context2.sent;
                // this.parse_mxhd(mdhd_data, this.currentTrack);
                td = _this.getTrackDescription();
                td.creationTime = mdhd_data.creationTime;
                td.modificationTime = mdhd_data.modificationTime;
                td.timeScale = mdhd_data.timeScale;
                td.duration = mdhd_data.duration;
              case 8:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function mdhd(_x2) {
          return _mdhd.apply(this, arguments);
        }
        return mdhd;
      }(),
      chap: function () {
        var _chap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(len) {
          var td, trackIds;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                td = _this.getTrackDescription();
                trackIds = [];
              case 2:
                if (!(len >= Token.UINT32_BE.len)) {
                  _context3.next = 11;
                  break;
                }
                _context3.t0 = trackIds;
                _context3.next = 6;
                return _this.tokenizer.readNumber(Token.UINT32_BE);
              case 6:
                _context3.t1 = _context3.sent;
                _context3.t0.push.call(_context3.t0, _context3.t1);
                len -= Token.UINT32_BE.len;
                _context3.next = 2;
                break;
              case 11:
                td.chapterList = trackIds;
              case 12:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        function chap(_x3) {
          return _chap.apply(this, arguments);
        }
        return chap;
      }(),
      tkhd: function () {
        var _tkhd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(len) {
          var track;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return _this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len));
              case 2:
                track = _context4.sent;
                _this.tracks.push(track);
              case 4:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        function tkhd(_x4) {
          return _tkhd.apply(this, arguments);
        }
        return tkhd;
      }(),
      /**
       * Parse mdat atom.
       * Will scan for chapters
       */
      mdat: function () {
        var _mdat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(len) {
          var trackWithChapters, chapterTrackIds, chapterTracks;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _this.audioLengthInBytes = len;
                _this.calculateBitRate();
                if (!_this.options.includeChapters) {
                  _context5.next = 9;
                  break;
                }
                trackWithChapters = _this.tracks.filter(function (track) {
                  return track.chapterList;
                });
                if (!(trackWithChapters.length === 1)) {
                  _context5.next = 9;
                  break;
                }
                chapterTrackIds = trackWithChapters[0].chapterList;
                chapterTracks = _this.tracks.filter(function (track) {
                  return chapterTrackIds.indexOf(track.trackId) !== -1;
                });
                if (!(chapterTracks.length === 1)) {
                  _context5.next = 9;
                  break;
                }
                return _context5.abrupt("return", _this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len));
              case 9:
                _context5.next = 11;
                return _this.tokenizer.ignore(len);
              case 11:
              case "end":
                return _context5.stop();
            }
          }, _callee5);
        }));
        function mdat(_x5) {
          return _mdat.apply(this, arguments);
        }
        return mdat;
      }(),
      ftyp: function () {
        var _ftyp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(len) {
          var types, ftype, value, x;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                types = [];
              case 1:
                if (!(len > 0)) {
                  _context6.next = 10;
                  break;
                }
                _context6.next = 4;
                return _this.tokenizer.readToken(AtomToken.ftyp);
              case 4:
                ftype = _context6.sent;
                len -= AtomToken.ftyp.len;
                value = ftype.type.replace(/\W/g, '');
                if (value.length > 0) {
                  types.push(value); // unshift for backward compatibility
                }
                _context6.next = 1;
                break;
              case 10:
                debug("ftyp: ".concat(types.join('/')));
                x = types.filter(distinct).join('/');
                _this.metadata.setFormat('container', x);
              case 13:
              case "end":
                return _context6.stop();
            }
          }, _callee6);
        }));
        function ftyp(_x6) {
          return _ftyp.apply(this, arguments);
        }
        return ftyp;
      }(),
      /**
       * Parse sample description atom
       */
      stsd: function () {
        var _stsd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(len) {
          var stsd, trackDescription;
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _this.tokenizer.readToken(new AtomToken.StsdAtom(len));
              case 2:
                stsd = _context7.sent;
                trackDescription = _this.getTrackDescription();
                trackDescription.soundSampleDescription = stsd.table.map(function (dfEntry) {
                  return _this.parseSoundSampleDescription(dfEntry);
                });
              case 5:
              case "end":
                return _context7.stop();
            }
          }, _callee7);
        }));
        function stsd(_x7) {
          return _stsd.apply(this, arguments);
        }
        return stsd;
      }(),
      /**
       * sample-to-Chunk Atoms
       */
      stsc: function () {
        var _stsc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(len) {
          var stsc;
          return _regeneratorRuntime().wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return _this.tokenizer.readToken(new AtomToken.StscAtom(len));
              case 2:
                stsc = _context8.sent;
                _this.getTrackDescription().sampleToChunkTable = stsc.entries;
              case 4:
              case "end":
                return _context8.stop();
            }
          }, _callee8);
        }));
        function stsc(_x8) {
          return _stsc.apply(this, arguments);
        }
        return stsc;
      }(),
      /**
       * time to sample
       */
      stts: function () {
        var _stts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(len) {
          var stts;
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return _this.tokenizer.readToken(new AtomToken.SttsAtom(len));
              case 2:
                stts = _context9.sent;
                _this.getTrackDescription().timeToSampleTable = stts.entries;
              case 4:
              case "end":
                return _context9.stop();
            }
          }, _callee9);
        }));
        function stts(_x9) {
          return _stts.apply(this, arguments);
        }
        return stts;
      }(),
      /**
       * Parse sample-sizes atom ('stsz')
       */
      stsz: function () {
        var _stsz = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(len) {
          var stsz, td;
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return _this.tokenizer.readToken(new AtomToken.StszAtom(len));
              case 2:
                stsz = _context10.sent;
                td = _this.getTrackDescription();
                td.sampleSize = stsz.sampleSize;
                td.sampleSizeTable = stsz.entries;
              case 6:
              case "end":
                return _context10.stop();
            }
          }, _callee10);
        }));
        function stsz(_x10) {
          return _stsz.apply(this, arguments);
        }
        return stsz;
      }(),
      /**
       * Parse chunk-offset atom ('stco')
       */
      stco: function () {
        var _stco = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(len) {
          var stco;
          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return _this.tokenizer.readToken(new AtomToken.StcoAtom(len));
              case 2:
                stco = _context11.sent;
                _this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets
              case 4:
              case "end":
                return _context11.stop();
            }
          }, _callee11);
        }));
        function stco(_x11) {
          return _stco.apply(this, arguments);
        }
        return stco;
      }(),
      date: function () {
        var _date = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(len) {
          var date;
          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return _this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));
              case 2:
                date = _context12.sent;
                _this.addTag('date', date);
              case 4:
              case "end":
                return _context12.stop();
            }
          }, _callee12);
        }));
        function date(_x12) {
          return _date.apply(this, arguments);
        }
        return date;
      }()
    };
    return _this;
  }
  _createClass(MP4Parser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        var _this2 = this;
        var remainingFileSize, token, errMsg, _errMsg, rootAtom, formatList, audioTracks, audioTrack, duration, ssd, encoderInfo;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.tracks = [];
              remainingFileSize = this.tokenizer.fileInfo.size;
            case 2:
              if (!(!this.tokenizer.fileInfo.size || remainingFileSize > 0)) {
                _context13.next = 26;
                break;
              }
              _context13.prev = 3;
              _context13.next = 6;
              return this.tokenizer.peekToken(AtomToken.Header);
            case 6:
              token = _context13.sent;
              if (!(token.name === '\0\0\0\0')) {
                _context13.next = 12;
                break;
              }
              errMsg = "Error at offset=".concat(this.tokenizer.position, ": box.id=0");
              debug(errMsg);
              this.addWarning(errMsg);
              return _context13.abrupt("break", 26);
            case 12:
              _context13.next = 20;
              break;
            case 14:
              _context13.prev = 14;
              _context13.t0 = _context13["catch"](3);
              _errMsg = "Error at offset=".concat(this.tokenizer.position, ": ").concat(_context13.t0.message);
              debug(_errMsg);
              this.addWarning(_errMsg);
              return _context13.abrupt("break", 26);
            case 20:
              _context13.next = 22;
              return Atom_1.Atom.readAtom(this.tokenizer, function (atom, remaining) {
                return _this2.handleAtom(atom, remaining);
              }, null, remainingFileSize);
            case 22:
              rootAtom = _context13.sent;
              remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);
              _context13.next = 2;
              break;
            case 26:
              // Post process metadata
              formatList = [];
              this.tracks.forEach(function (track) {
                var trackFormats = [];
                track.soundSampleDescription.forEach(function (ssd) {
                  var streamInfo = {};
                  var encoderInfo = encoderDict[ssd.dataFormat];
                  if (encoderInfo) {
                    trackFormats.push(encoderInfo.format);
                    streamInfo.codecName = encoderInfo.format;
                  } else {
                    streamInfo.codecName = "<".concat(ssd.dataFormat, ">");
                  }
                  if (ssd.description) {
                    var description = ssd.description;
                    if (description.sampleRate > 0) {
                      streamInfo.type = type_1.TrackType.audio;
                      streamInfo.audio = {
                        samplingFrequency: description.sampleRate,
                        bitDepth: description.sampleSize,
                        channels: description.numAudioChannels
                      };
                    }
                  }
                  _this2.metadata.addStreamInfo(streamInfo);
                });
                if (trackFormats.length >= 1) {
                  formatList.push(trackFormats.join('/'));
                }
              });
              if (formatList.length > 0) {
                this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));
              }
              audioTracks = this.tracks.filter(function (track) {
                return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;
              });
              if (audioTracks.length >= 1) {
                audioTrack = audioTracks[0];
                duration = audioTrack.duration / audioTrack.timeScale;
                this.metadata.setFormat('duration', duration); // calculate duration in seconds
                ssd = audioTrack.soundSampleDescription[0];
                if (ssd.description) {
                  this.metadata.setFormat('sampleRate', ssd.description.sampleRate);
                  this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);
                  this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);
                }
                encoderInfo = encoderDict[ssd.dataFormat];
                if (encoderInfo) {
                  this.metadata.setFormat('lossless', !encoderInfo.lossy);
                }
                this.calculateBitRate();
              }
            case 31:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this, [[3, 14]]);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "handleAtom",
    value: function () {
      var _handleAtom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(atom, remaining) {
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              if (!atom.parent) {
                _context14.next = 5;
                break;
              }
              _context14.t0 = atom.parent.header.name;
              _context14.next = _context14.t0 === 'ilst' ? 4 : _context14.t0 === '<id>' ? 4 : 5;
              break;
            case 4:
              return _context14.abrupt("return", this.parseMetadataItemData(atom));
            case 5:
              if (!this.atomParsers[atom.header.name]) {
                _context14.next = 9;
                break;
              }
              return _context14.abrupt("return", this.atomParsers[atom.header.name](remaining));
            case 9:
              debug("No parser for atom path=".concat(atom.atomPath, ", payload-len=").concat(remaining, ", ignoring atom"));
              _context14.next = 12;
              return this.tokenizer.ignore(remaining);
            case 12:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function handleAtom(_x13, _x14) {
        return _handleAtom.apply(this, arguments);
      }
      return handleAtom;
    }()
  }, {
    key: "getTrackDescription",
    value: function getTrackDescription() {
      return this.tracks[this.tracks.length - 1];
    }
  }, {
    key: "calculateBitRate",
    value: function calculateBitRate() {
      if (this.audioLengthInBytes && this.metadata.format.duration) {
        this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);
      }
    }
  }, {
    key: "addTag",
    value: function addTag(id, value) {
      this.metadata.addTag(tagFormat, id, value);
    }
  }, {
    key: "addWarning",
    value: function addWarning(message) {
      debug('Warning: ' + message);
      this.metadata.addWarning(message);
    }
    /**
     * Parse data of Meta-item-list-atom (item of 'ilst' atom)
     * @param metaAtom
     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
     */
  }, {
    key: "parseMetadataItemData",
    value: function parseMetadataItemData(metaAtom) {
      var _this3 = this;
      var tagKey = metaAtom.header.name;
      return metaAtom.readAtoms(this.tokenizer, /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(child, remaining) {
          var payLoadLength, name, mean, dataAtom;
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                payLoadLength = child.getPayloadLength(remaining);
                _context15.t0 = child.header.name;
                _context15.next = _context15.t0 === 'data' ? 4 : _context15.t0 === 'name' ? 5 : _context15.t0 === 'mean' ? 10 : 15;
                break;
              case 4:
                return _context15.abrupt("return", _this3.parseValueAtom(tagKey, child));
              case 5:
                _context15.next = 7;
                return _this3.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));
              case 7:
                name = _context15.sent;
                tagKey += ':' + name.name;
                return _context15.abrupt("break", 19);
              case 10:
                _context15.next = 12;
                return _this3.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));
              case 12:
                mean = _context15.sent;
                // console.log("  %s[%s] = %s", tagKey, header.name, mean.name);
                tagKey += ':' + mean.name;
                return _context15.abrupt("break", 19);
              case 15:
                _context15.next = 17;
                return _this3.tokenizer.readToken(new Token.BufferType(payLoadLength));
              case 17:
                dataAtom = _context15.sent;
                _this3.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));
              case 19:
              case "end":
                return _context15.stop();
            }
          }, _callee15);
        }));
        return function (_x15, _x16) {
          return _ref.apply(this, arguments);
        };
      }(), metaAtom.getPayloadLength(0));
    }
  }, {
    key: "parseValueAtom",
    value: function () {
      var _parseValueAtom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(tagKey, metaAtom) {
        var dataAtom, num, of, genreInt, genreStr;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));
            case 2:
              dataAtom = _context16.sent;
              if (!(dataAtom.type.set !== 0)) {
                _context16.next = 5;
                break;
              }
              throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);
            case 5:
              _context16.t0 = dataAtom.type.type;
              _context16.next = _context16.t0 === 0 ? 8 : _context16.t0 === 1 ? 20 : _context16.t0 === 18 ? 20 : _context16.t0 === 13 ? 22 : _context16.t0 === 14 ? 26 : _context16.t0 === 21 ? 30 : _context16.t0 === 22 ? 32 : _context16.t0 === 65 ? 34 : _context16.t0 === 66 ? 36 : _context16.t0 === 67 ? 38 : 40;
              break;
            case 8:
              _context16.t1 = tagKey;
              _context16.next = _context16.t1 === 'trkn' ? 11 : _context16.t1 === 'disk' ? 11 : _context16.t1 === 'gnre' ? 15 : 19;
              break;
            case 11:
              num = Token.UINT8.get(dataAtom.value, 3);
              of = Token.UINT8.get(dataAtom.value, 5); // console.log("  %s[data] = %s/%s", tagKey, num, of);
              this.addTag(tagKey, num + '/' + of);
              return _context16.abrupt("break", 19);
            case 15:
              genreInt = Token.UINT8.get(dataAtom.value, 1);
              genreStr = ID3v1Parser_1.Genres[genreInt - 1]; // console.log("  %s[data] = %s", tagKey, genreStr);
              this.addTag(tagKey, genreStr);
              return _context16.abrupt("break", 19);
            case 19:
              return _context16.abrupt("break", 41);
            case 20:
              // Unknown: Found in m4b in combination with a '©gen' tag
              this.addTag(tagKey, dataAtom.value.toString('utf-8'));
              return _context16.abrupt("break", 41);
            case 22:
              if (!this.options.skipCovers) {
                _context16.next = 24;
                break;
              }
              return _context16.abrupt("break", 41);
            case 24:
              this.addTag(tagKey, {
                format: 'image/jpeg',
                data: Buffer.from(dataAtom.value)
              });
              return _context16.abrupt("break", 41);
            case 26:
              if (!this.options.skipCovers) {
                _context16.next = 28;
                break;
              }
              return _context16.abrupt("break", 41);
            case 28:
              this.addTag(tagKey, {
                format: 'image/png',
                data: Buffer.from(dataAtom.value)
              });
              return _context16.abrupt("break", 41);
            case 30:
              // BE Signed Integer
              this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));
              return _context16.abrupt("break", 41);
            case 32:
              // BE Unsigned Integer
              this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));
              return _context16.abrupt("break", 41);
            case 34:
              // An 8-bit signed integer
              this.addTag(tagKey, dataAtom.value.readInt8(0));
              return _context16.abrupt("break", 41);
            case 36:
              // A big-endian 16-bit signed integer
              this.addTag(tagKey, dataAtom.value.readInt16BE(0));
              return _context16.abrupt("break", 41);
            case 38:
              // A big-endian 32-bit signed integer
              this.addTag(tagKey, dataAtom.value.readInt32BE(0));
              return _context16.abrupt("break", 41);
            case 40:
              this.addWarning("atom key=".concat(tagKey, ", has unknown well-known-type (data-type): ").concat(dataAtom.type.type));
            case 41:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function parseValueAtom(_x17, _x18) {
        return _parseValueAtom.apply(this, arguments);
      }
      return parseValueAtom;
    }()
    /**
     * @param sampleDescription
     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
     */
  }, {
    key: "parseSoundSampleDescription",
    value: function parseSoundSampleDescription(sampleDescription) {
      var ssd = {
        dataFormat: sampleDescription.dataFormat,
        dataReferenceIndex: sampleDescription.dataReferenceIndex
      };
      var offset = 0;
      var version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);
      offset += AtomToken.SoundSampleDescriptionVersion.len;
      if (version.version === 0 || version.version === 1) {
        // Sound Sample Description (Version 0)
        ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);
      } else {
        debug("Warning: sound-sample-description ".concat(version, " not implemented"));
      }
      return ssd;
    }
  }, {
    key: "parseChapterTrack",
    value: function () {
      var _parseChapterTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(chapterTrack, track, len) {
        var chapters, i, chunkOffset, nextChunkLen, sampleSize, title, chapter;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              if (chapterTrack.sampleSize) {
                _context17.next = 3;
                break;
              }
              if (!(chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)) {
                _context17.next = 3;
                break;
              }
              throw new Error('Expected equal chunk-offset-table & sample-size-table length.');
            case 3:
              chapters = [];
              i = 0;
            case 5:
              if (!(i < chapterTrack.chunkOffsetTable.length && len > 0)) {
                _context17.next = 24;
                break;
              }
              chunkOffset = chapterTrack.chunkOffsetTable[i];
              nextChunkLen = chunkOffset - this.tokenizer.position;
              sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];
              len -= nextChunkLen + sampleSize;
              if (!(len < 0)) {
                _context17.next = 12;
                break;
              }
              throw new Error('Chapter chunk exceeding token length');
            case 12:
              _context17.next = 14;
              return this.tokenizer.ignore(nextChunkLen);
            case 14:
              _context17.next = 16;
              return this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));
            case 16:
              title = _context17.sent;
              debug("Chapter ".concat(i + 1, ": ").concat(title));
              chapter = {
                title: title,
                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)
              };
              debug("Chapter title=".concat(chapter.title, ", offset=").concat(chapter.sampleOffset, "/").concat(this.tracks[0].duration));
              chapters.push(chapter);
            case 21:
              ++i;
              _context17.next = 5;
              break;
            case 24:
              this.metadata.setFormat('chapters', chapters);
              _context17.next = 27;
              return this.tokenizer.ignore(len);
            case 27:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function parseChapterTrack(_x19, _x20, _x21) {
        return _parseChapterTrack.apply(this, arguments);
      }
      return parseChapterTrack;
    }()
  }, {
    key: "findSampleOffset",
    value: function findSampleOffset(track, chapterOffset) {
      var totalDuration = 0;
      track.timeToSampleTable.forEach(function (e) {
        totalDuration += e.count * e.duration;
      });
      debug("Total duration=".concat(totalDuration));
      var chunkIndex = 0;
      while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {
        ++chunkIndex;
      }
      return this.getChunkDuration(chunkIndex + 1, track);
    }
  }, {
    key: "getChunkDuration",
    value: function getChunkDuration(chunkId, track) {
      var ttsi = 0;
      var ttsc = track.timeToSampleTable[ttsi].count;
      var ttsd = track.timeToSampleTable[ttsi].duration;
      var curChunkId = 1;
      var samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
      var totalDuration = 0;
      while (curChunkId < chunkId) {
        var nrOfSamples = Math.min(ttsc, samplesPerChunk);
        totalDuration += nrOfSamples * ttsd;
        ttsc -= nrOfSamples;
        samplesPerChunk -= nrOfSamples;
        if (samplesPerChunk === 0) {
          ++curChunkId;
          samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
        } else {
          ++ttsi;
          ttsc = track.timeToSampleTable[ttsi].count;
          ttsd = track.timeToSampleTable[ttsi].duration;
        }
      }
      return totalDuration;
    }
  }, {
    key: "getSamplesPerChunk",
    value: function getSamplesPerChunk(chunkId, stcTable) {
      for (var i = 0; i < stcTable.length - 1; ++i) {
        if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {
          return stcTable[i].samplesPerChunk;
        }
      }
      return stcTable[stcTable.length - 1].samplesPerChunk;
    }
  }], [{
    key: "read_BE_Integer",
    value: function read_BE_Integer(array, signed) {
      var integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');
      var token = Token[integerType];
      if (!token) {
        throw new Error('Token for integer type not found: "' + integerType + '"');
      }
      return Number(token.get(array, 0));
    }
  }]);
  return MP4Parser;
}(BasicParser_1.BasicParser);
exports.MP4Parser = MP4Parser;
},{"debug":"node_modules/debug/src/browser.js","token-types":"node_modules/token-types/lib/index.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","../id3v1/ID3v1Parser":"node_modules/music-metadata/lib/id3v1/ID3v1Parser.js","../type":"node_modules/music-metadata/lib/type.js","./Atom":"node_modules/music-metadata/lib/mp4/Atom.js","./AtomToken":"node_modules/music-metadata/lib/mp4/AtomToken.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReplayGain = void 0;
var common = require("../common/Util");
/**
 * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#name-code
 */
var NameCode;
(function (NameCode) {
  /**
   * not set
   */
  NameCode[NameCode["not_set"] = 0] = "not_set";
  /**
   * Radio Gain Adjustment
   */
  NameCode[NameCode["radio"] = 1] = "radio";
  /**
   * Audiophile Gain Adjustment
   */
  NameCode[NameCode["audiophile"] = 2] = "audiophile";
})(NameCode || (NameCode = {}));
/**
 * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#originator-code
 */
var ReplayGainOriginator;
(function (ReplayGainOriginator) {
  /**
   * Replay Gain unspecified
   */
  ReplayGainOriginator[ReplayGainOriginator["unspecified"] = 0] = "unspecified";
  /**
   * Replay Gain pre-set by artist/producer/mastering engineer
   */
  ReplayGainOriginator[ReplayGainOriginator["engineer"] = 1] = "engineer";
  /**
   * Replay Gain set by user
   */
  ReplayGainOriginator[ReplayGainOriginator["user"] = 2] = "user";
  /**
   * Replay Gain determined automatically, as described on this site
   */
  ReplayGainOriginator[ReplayGainOriginator["automatic"] = 3] = "automatic";
  /**
   * Set by simple RMS average
   */
  ReplayGainOriginator[ReplayGainOriginator["rms_average"] = 4] = "rms_average";
})(ReplayGainOriginator || (ReplayGainOriginator = {}));
/**
 * Replay Gain Data Format
 *
 * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format
 */
exports.ReplayGain = {
  len: 2,
  get: function get(buf, off) {
    var gain_type = common.getBitAllignedNumber(buf, off, 0, 3);
    var sign = common.getBitAllignedNumber(buf, off, 6, 1);
    var gain_adj = common.getBitAllignedNumber(buf, off, 7, 9) / 10.0;
    if (gain_type > 0) {
      return {
        type: common.getBitAllignedNumber(buf, off, 0, 3),
        origin: common.getBitAllignedNumber(buf, off, 3, 3),
        adjustment: sign ? -gain_adj : gain_adj
      };
    }
    return undefined;
  }
};
},{"../common/Util":"node_modules/music-metadata/lib/common/Util.js"}],"node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js":[function(require,module,exports) {
"use strict";

/**
 * Extended Lame Header
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExtendedLameHeader = void 0;
var Token = require("token-types");
var common = require("../common/Util");
var ReplayGainDataFormat_1 = require("./ReplayGainDataFormat");
/**
 * Info Tag
 * @link http://gabriel.mp3-tech.org/mp3infotag.html
 * @link https://github.com/quodlibet/mutagen/blob/abd58ee58772224334a18817c3fb31103572f70e/mutagen/mp3/_util.py#L112
 */
exports.ExtendedLameHeader = {
  len: 27,
  get: function get(buf, off) {
    var track_peak = Token.UINT32_BE.get(buf, off + 2);
    return {
      revision: common.getBitAllignedNumber(buf, off, 0, 4),
      vbr_method: common.getBitAllignedNumber(buf, off, 4, 4),
      lowpass_filter: 100 * Token.UINT8.get(buf, off + 1),
      track_peak: track_peak === 0 ? undefined : track_peak / Math.pow(2, 23),
      track_gain: ReplayGainDataFormat_1.ReplayGain.get(buf, 6),
      album_gain: ReplayGainDataFormat_1.ReplayGain.get(buf, 8),
      music_length: Token.UINT32_BE.get(buf, off + 20),
      music_crc: Token.UINT8.get(buf, off + 24),
      header_crc: Token.UINT16_BE.get(buf, off + 24)
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","./ReplayGainDataFormat":"node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js"}],"node_modules/music-metadata/lib/mpeg/XingTag.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readXingHeader = exports.XingHeaderFlags = exports.LameEncoderVersion = exports.InfoTagHeaderTag = void 0;
var Token = require("token-types");
var util = require("../common/Util");
var ExtendedLameHeader_1 = require("./ExtendedLameHeader");
/**
 * Info Tag: Xing, LAME
 */
exports.InfoTagHeaderTag = new Token.StringType(4, 'ascii');
/**
 * LAME TAG value
 * Did not find any official documentation for this
 * Value e.g.: "3.98.4"
 */
exports.LameEncoderVersion = new Token.StringType(6, 'ascii');
/**
 * Info Tag
 * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
 */
exports.XingHeaderFlags = {
  len: 4,
  get: function get(buf, off) {
    return {
      frames: util.isBitSet(buf, off, 31),
      bytes: util.isBitSet(buf, off, 30),
      toc: util.isBitSet(buf, off, 29),
      vbrScale: util.isBitSet(buf, off, 28)
    };
  }
};
// /**
//  * XING Header Tag
//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
//  */
function readXingHeader(_x) {
  return _readXingHeader.apply(this, arguments);
}
function _readXingHeader() {
  _readXingHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenizer) {
    var flags, xingInfoTag, lameTag, match, majorMinorVersion, version;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return tokenizer.readToken(exports.XingHeaderFlags);
        case 2:
          flags = _context.sent;
          xingInfoTag = {};
          if (!flags.frames) {
            _context.next = 8;
            break;
          }
          _context.next = 7;
          return tokenizer.readToken(Token.UINT32_BE);
        case 7:
          xingInfoTag.numFrames = _context.sent;
        case 8:
          if (!flags.bytes) {
            _context.next = 12;
            break;
          }
          _context.next = 11;
          return tokenizer.readToken(Token.UINT32_BE);
        case 11:
          xingInfoTag.streamSize = _context.sent;
        case 12:
          if (!flags.toc) {
            _context.next = 16;
            break;
          }
          xingInfoTag.toc = Buffer.alloc(100);
          _context.next = 16;
          return tokenizer.readBuffer(xingInfoTag.toc);
        case 16:
          if (!flags.vbrScale) {
            _context.next = 20;
            break;
          }
          _context.next = 19;
          return tokenizer.readToken(Token.UINT32_BE);
        case 19:
          xingInfoTag.vbrScale = _context.sent;
        case 20:
          _context.next = 22;
          return tokenizer.peekToken(new Token.StringType(4, 'ascii'));
        case 22:
          lameTag = _context.sent;
          if (!(lameTag === 'LAME')) {
            _context.next = 38;
            break;
          }
          _context.next = 26;
          return tokenizer.ignore(4);
        case 26:
          _context.next = 28;
          return tokenizer.readToken(new Token.StringType(5, 'ascii'));
        case 28:
          _context.t0 = _context.sent;
          xingInfoTag.lame = {
            version: _context.t0
          };
          match = xingInfoTag.lame.version.match(/\d+.\d+/g);
          if (!match) {
            _context.next = 38;
            break;
          }
          majorMinorVersion = xingInfoTag.lame.version.match(/\d+.\d+/g)[0]; // e.g. 3.97
          version = majorMinorVersion.split('.').map(function (n) {
            return parseInt(n, 10);
          });
          if (!(version[0] >= 3 && version[1] >= 90)) {
            _context.next = 38;
            break;
          }
          _context.next = 37;
          return tokenizer.readToken(ExtendedLameHeader_1.ExtendedLameHeader);
        case 37:
          xingInfoTag.lame.extended = _context.sent;
        case 38:
          return _context.abrupt("return", xingInfoTag);
        case 39:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _readXingHeader.apply(this, arguments);
}
exports.readXingHeader = readXingHeader;
},{"token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","./ExtendedLameHeader":"node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/mpeg/MpegParser.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MpegParser = void 0;
var Token = require("token-types");
var core_1 = require("strtok3/lib/core");
var debug_1 = require("debug");
var common = require("../common/Util");
var AbstractID3Parser_1 = require("../id3v2/AbstractID3Parser");
var XingTag_1 = require("./XingTag");
var debug = (0, debug_1.default)('music-metadata:parser:mpeg');
/**
 * Cache buffer size used for searching synchronization preabmle
 */
var maxPeekLen = 1024;
/**
 * MPEG-4 Audio definitions
 * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio
 */
var MPEG4 = {
  /**
   * Audio Object Types
   */
  AudioObjectTypes: ['AAC Main', 'AAC LC', 'AAC SSR', 'AAC LTP' // Long Term Prediction
  ],

  /**
   * Sampling Frequencies
   * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
   */
  SamplingFrequencies: [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1]
  /**
   * Channel Configurations
   */
};

var MPEG4_ChannelConfigurations = [undefined, ['front-center'], ['front-left', 'front-right'], ['front-center', 'front-left', 'front-right'], ['front-center', 'front-left', 'front-right', 'back-center'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'], ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']];
/**
 * MPEG Audio Layer I/II/III frame header
 * Ref: https://www.mp3-tech.org/programmer/frame_header.html
 * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
 * Ref: https://wiki.multimedia.cx/index.php/ADTS
 */
var MpegFrameHeader = /*#__PURE__*/function () {
  function MpegFrameHeader(buf, off) {
    _classCallCheck(this, MpegFrameHeader);
    // B(20,19): MPEG Audio versionIndex ID
    this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);
    // C(18,17): Layer description
    this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];
    if (this.versionIndex > 1 && this.layer === 0) {
      this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)
    } else {
      this.parseMpegHeader(buf, off); // Conventional MPEG header
    }
    // D(16): Protection bit (if true 16-bit CRC follows header)
    this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);
  }
  _createClass(MpegFrameHeader, [{
    key: "calcDuration",
    value: function calcDuration(numFrames) {
      return numFrames * this.calcSamplesPerFrame() / this.samplingRate;
    }
  }, {
    key: "calcSamplesPerFrame",
    value: function calcSamplesPerFrame() {
      return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
    }
  }, {
    key: "calculateSideInfoLength",
    value: function calculateSideInfoLength() {
      if (this.layer !== 3) return 2;
      if (this.channelModeIndex === 3) {
        // mono
        if (this.version === 1) {
          return 17;
        } else if (this.version === 2 || this.version === 2.5) {
          return 9;
        }
      } else {
        if (this.version === 1) {
          return 32;
        } else if (this.version === 2 || this.version === 2.5) {
          return 17;
        }
      }
    }
  }, {
    key: "calcSlotSize",
    value: function calcSlotSize() {
      return [null, 4, 1, 1][this.layer];
    }
  }, {
    key: "parseMpegHeader",
    value: function parseMpegHeader(buf, off) {
      this.container = 'MPEG';
      // E(15,12): Bitrate index
      this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);
      // F(11,10): Sampling rate frequency index
      this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);
      // G(9): Padding bit
      this.padding = common.isBitSet(buf, off + 2, 6);
      // H(8): Private bit
      this.privateBit = common.isBitSet(buf, off + 2, 7);
      // I(7,6): Channel Mode
      this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);
      // J(5,4): Mode extension (Only used in Joint stereo)
      this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);
      // K(3): Copyright
      this.isCopyrighted = common.isBitSet(buf, off + 3, 4);
      // L(2): Original
      this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);
      // M(3): The original bit indicates, if it is set, that the frame is located on its original media.
      this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);
      this.version = MpegFrameHeader.VersionID[this.versionIndex];
      this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
      this.codec = "MPEG ".concat(this.version, " Layer ").concat(this.layer);
      // Calculate bitrate
      var bitrateInKbps = this.calcBitrate();
      if (!bitrateInKbps) {
        throw new Error('Cannot determine bit-rate');
      }
      this.bitrate = bitrateInKbps * 1000;
      // Calculate sampling rate
      this.samplingRate = this.calcSamplingRate();
      if (this.samplingRate == null) {
        throw new Error('Cannot determine sampling-rate');
      }
    }
  }, {
    key: "parseAdtsHeader",
    value: function parseAdtsHeader(buf, off) {
      debug("layer=0 => ADTS");
      this.version = this.versionIndex === 2 ? 4 : 2;
      this.container = 'ADTS/MPEG-' + this.version;
      var profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);
      this.codec = 'AAC';
      this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];
      debug("MPEG-4 audio-codec=".concat(this.codec));
      var samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);
      this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];
      debug("sampling-rate=".concat(this.samplingRate));
      var channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);
      this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];
      debug("channel-config=".concat(this.mp4ChannelConfig.join('+')));
      this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;
    }
  }, {
    key: "calcBitrate",
    value: function calcBitrate() {
      if (this.bitrateIndex === 0x00 ||
      // free
      this.bitrateIndex === 0x0F) {
        // reserved
        return;
      }
      var codecIndex = "".concat(Math.floor(this.version)).concat(this.layer);
      return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];
    }
  }, {
    key: "calcSamplingRate",
    value: function calcSamplingRate() {
      if (this.sampRateFreqIndex === 0x03) return null; // 'reserved'
      return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
    }
  }]);
  return MpegFrameHeader;
}();
MpegFrameHeader.SyncByte1 = 0xFF;
MpegFrameHeader.SyncByte2 = 0xE0;
MpegFrameHeader.VersionID = [2.5, null, 2, 1];
MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
MpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];
MpegFrameHeader.bitrate_index = {
  0x01: {
    11: 32,
    12: 32,
    13: 32,
    21: 32,
    22: 8,
    23: 8
  },
  0x02: {
    11: 64,
    12: 48,
    13: 40,
    21: 48,
    22: 16,
    23: 16
  },
  0x03: {
    11: 96,
    12: 56,
    13: 48,
    21: 56,
    22: 24,
    23: 24
  },
  0x04: {
    11: 128,
    12: 64,
    13: 56,
    21: 64,
    22: 32,
    23: 32
  },
  0x05: {
    11: 160,
    12: 80,
    13: 64,
    21: 80,
    22: 40,
    23: 40
  },
  0x06: {
    11: 192,
    12: 96,
    13: 80,
    21: 96,
    22: 48,
    23: 48
  },
  0x07: {
    11: 224,
    12: 112,
    13: 96,
    21: 112,
    22: 56,
    23: 56
  },
  0x08: {
    11: 256,
    12: 128,
    13: 112,
    21: 128,
    22: 64,
    23: 64
  },
  0x09: {
    11: 288,
    12: 160,
    13: 128,
    21: 144,
    22: 80,
    23: 80
  },
  0x0A: {
    11: 320,
    12: 192,
    13: 160,
    21: 160,
    22: 96,
    23: 96
  },
  0x0B: {
    11: 352,
    12: 224,
    13: 192,
    21: 176,
    22: 112,
    23: 112
  },
  0x0C: {
    11: 384,
    12: 256,
    13: 224,
    21: 192,
    22: 128,
    23: 128
  },
  0x0D: {
    11: 416,
    12: 320,
    13: 256,
    21: 224,
    22: 144,
    23: 144
  },
  0x0E: {
    11: 448,
    12: 384,
    13: 320,
    21: 256,
    22: 160,
    23: 160
  }
};
MpegFrameHeader.sampling_rate_freq_index = {
  1: {
    0x00: 44100,
    0x01: 48000,
    0x02: 32000
  },
  2: {
    0x00: 22050,
    0x01: 24000,
    0x02: 16000
  },
  2.5: {
    0x00: 11025,
    0x01: 12000,
    0x02: 8000
  }
};
MpegFrameHeader.samplesInFrameTable = [/* Layer   I    II   III */
[0, 384, 1152, 1152], [0, 384, 1152, 576] // MPEG-2(.5
];
/**
 * MPEG Audio Layer I/II/III
 */
var FrameHeader = {
  len: 4,
  get: function get(buf, off) {
    return new MpegFrameHeader(buf, off);
  }
};
function getVbrCodecProfile(vbrScale) {
  return 'V' + Math.floor((100 - vbrScale) / 10);
}
var MpegParser = /*#__PURE__*/function (_AbstractID3Parser_1$) {
  _inherits(MpegParser, _AbstractID3Parser_1$);
  var _super = _createSuper(MpegParser);
  function MpegParser() {
    var _this;
    _classCallCheck(this, MpegParser);
    _this = _super.apply(this, arguments);
    _this.frameCount = 0;
    _this.syncFrameCount = -1;
    _this.countSkipFrameData = 0;
    _this.totalDataLength = 0;
    _this.bitrates = [];
    _this.calculateEofDuration = false;
    _this.buf_frame_header = Buffer.alloc(4);
    _this.syncPeek = {
      buf: Buffer.alloc(maxPeekLen),
      len: 0
    };
    return _this;
  }
  /**
   * Called after ID3 headers have been parsed
   */
  _createClass(MpegParser, [{
    key: "postId3v2Parse",
    value: function () {
      var _postId3v2Parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var quit, numberOfSamples, duration;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.metadata.setFormat('lossless', false);
              _context.prev = 1;
              quit = false;
            case 3:
              if (quit) {
                _context.next = 11;
                break;
              }
              _context.next = 6;
              return this.sync();
            case 6:
              _context.next = 8;
              return this.parseCommonMpegHeader();
            case 8:
              quit = _context.sent;
              _context.next = 3;
              break;
            case 11:
              _context.next = 21;
              break;
            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](1);
              if (!(_context.t0 instanceof core_1.EndOfStreamError)) {
                _context.next = 20;
                break;
              }
              debug("End-of-stream");
              if (this.calculateEofDuration) {
                numberOfSamples = this.frameCount * this.samplesPerFrame;
                this.metadata.setFormat('numberOfSamples', numberOfSamples);
                duration = numberOfSamples / this.metadata.format.sampleRate;
                debug("Calculate duration at EOF: ".concat(duration, " sec."), duration);
                this.metadata.setFormat('duration', duration);
              }
              _context.next = 21;
              break;
            case 20:
              throw _context.t0;
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 13]]);
      }));
      function postId3v2Parse() {
        return _postId3v2Parse.apply(this, arguments);
      }
      return postId3v2Parse;
    }()
    /**
     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
     */
  }, {
    key: "finalize",
    value: function finalize() {
      var format = this.metadata.format;
      var hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');
      if (format.duration && this.tokenizer.fileInfo.size) {
        var mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
        if (format.codecProfile && format.codecProfile[0] === 'V') {
          this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);
        }
      } else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {
        var _mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
        var numberOfSamples = Math.round(_mpegSize / this.frame_size) * this.samplesPerFrame;
        this.metadata.setFormat('numberOfSamples', numberOfSamples);
        var duration = numberOfSamples / format.sampleRate;
        debug("Calculate CBR duration based on file size: %s", duration);
        this.metadata.setFormat('duration', duration);
      }
    }
  }, {
    key: "sync",
    value: function () {
      var _sync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var gotFirstSync, bo;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              gotFirstSync = false;
            case 1:
              if (!true) {
                _context2.next = 36;
                break;
              }
              bo = 0;
              _context2.next = 5;
              return this.tokenizer.peekBuffer(this.syncPeek.buf, {
                length: maxPeekLen,
                mayBeLess: true
              });
            case 5:
              this.syncPeek.len = _context2.sent;
              if (!(this.syncPeek.len <= 163)) {
                _context2.next = 8;
                break;
              }
              throw new core_1.EndOfStreamError();
            case 8:
              if (!true) {
                _context2.next = 34;
                break;
              }
              if (!(gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0)) {
                _context2.next = 20;
                break;
              }
              this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;
              this.buf_frame_header[1] = this.syncPeek.buf[bo];
              _context2.next = 14;
              return this.tokenizer.ignore(bo);
            case 14:
              debug("Sync at offset=".concat(this.tokenizer.position - 1, ", frameCount=").concat(this.frameCount));
              if (this.syncFrameCount === this.frameCount) {
                debug("Re-synced MPEG stream, frameCount=".concat(this.frameCount));
                this.frameCount = 0;
                this.frame_size = 0;
              }
              this.syncFrameCount = this.frameCount;
              return _context2.abrupt("return");
            case 20:
              gotFirstSync = false;
              bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);
              if (!(bo === -1)) {
                _context2.next = 30;
                break;
              }
              if (!(this.syncPeek.len < this.syncPeek.buf.length)) {
                _context2.next = 25;
                break;
              }
              throw new core_1.EndOfStreamError();
            case 25:
              _context2.next = 27;
              return this.tokenizer.ignore(this.syncPeek.len);
            case 27:
              return _context2.abrupt("break", 34);
            case 30:
              ++bo;
              gotFirstSync = true;
            case 32:
              _context2.next = 8;
              break;
            case 34:
              _context2.next = 1;
              break;
            case 36:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function sync() {
        return _sync.apply(this, arguments);
      }
      return sync;
    }()
    /**
     * Combined ADTS & MPEG (MP2 & MP3) header handling
     * @return {Promise<boolean>} true if parser should quit
     */
  }, {
    key: "parseCommonMpegHeader",
    value: function () {
      var _parseCommonMpegHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var header;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (this.frameCount === 0) {
                this.mpegOffset = this.tokenizer.position - 1;
              }
              _context3.next = 3;
              return this.tokenizer.peekBuffer(this.buf_frame_header, {
                offset: 1,
                length: 3
              });
            case 3:
              _context3.prev = 3;
              header = FrameHeader.get(this.buf_frame_header, 0);
              _context3.next = 13;
              break;
            case 7:
              _context3.prev = 7;
              _context3.t0 = _context3["catch"](3);
              _context3.next = 11;
              return this.tokenizer.ignore(1);
            case 11:
              this.metadata.addWarning('Parse error: ' + _context3.t0.message);
              return _context3.abrupt("return", false);
            case 13:
              _context3.next = 15;
              return this.tokenizer.ignore(3);
            case 15:
              this.metadata.setFormat('container', header.container);
              this.metadata.setFormat('codec', header.codec);
              this.metadata.setFormat('lossless', false);
              this.metadata.setFormat('sampleRate', header.samplingRate);
              this.frameCount++;
              return _context3.abrupt("return", header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header));
            case 21:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[3, 7]]);
      }));
      function parseCommonMpegHeader() {
        return _parseCommonMpegHeader.apply(this, arguments);
      }
      return parseCommonMpegHeader;
    }()
    /**
     * @return {Promise<boolean>} true if parser should quit
     */
  }, {
    key: "parseAudioFrameHeader",
    value: function () {
      var _parseAudioFrameHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(header) {
        var slot_size, samples_per_frame, bps, fsize;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);
              this.metadata.setFormat('bitrate', header.bitrate);
              if (this.frameCount < 20 * 10000) {
                debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
              }
              slot_size = header.calcSlotSize();
              if (!(slot_size === null)) {
                _context4.next = 6;
                break;
              }
              throw new Error('invalid slot_size');
            case 6:
              samples_per_frame = header.calcSamplesPerFrame();
              debug("samples_per_frame=".concat(samples_per_frame));
              bps = samples_per_frame / 8.0;
              fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);
              this.frame_size = Math.floor(fsize);
              this.audioFrameHeader = header;
              this.bitrates.push(header.bitrate);
              // xtra header only exists in first frame
              if (!(this.frameCount === 1)) {
                _context4.next = 18;
                break;
              }
              this.offset = FrameHeader.len;
              _context4.next = 17;
              return this.skipSideInformation();
            case 17:
              return _context4.abrupt("return", false);
            case 18:
              if (!(this.frameCount === 3)) {
                _context4.next = 30;
                break;
              }
              if (!this.areAllSame(this.bitrates)) {
                _context4.next = 26;
                break;
              }
              // Actual calculation will be done in finalize
              this.samplesPerFrame = samples_per_frame;
              this.metadata.setFormat('codecProfile', 'CBR');
              if (!this.tokenizer.fileInfo.size) {
                _context4.next = 24;
                break;
              }
              return _context4.abrupt("return", true);
            case 24:
              _context4.next = 28;
              break;
            case 26:
              if (!this.metadata.format.duration) {
                _context4.next = 28;
                break;
              }
              return _context4.abrupt("return", true);
            case 28:
              if (this.options.duration) {
                _context4.next = 30;
                break;
              }
              return _context4.abrupt("return", true);
            case 30:
              // once we know the file is VBR attach listener to end of
              // stream so we can do the duration calculation when we
              // have counted all the frames
              if (this.options.duration && this.frameCount === 4) {
                this.samplesPerFrame = samples_per_frame;
                this.calculateEofDuration = true;
              }
              this.offset = 4;
              if (!header.isProtectedByCRC) {
                _context4.next = 38;
                break;
              }
              _context4.next = 35;
              return this.parseCrc();
            case 35:
              return _context4.abrupt("return", false);
            case 38:
              _context4.next = 40;
              return this.skipSideInformation();
            case 40:
              return _context4.abrupt("return", false);
            case 41:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function parseAudioFrameHeader(_x) {
        return _parseAudioFrameHeader.apply(this, arguments);
      }
      return parseAudioFrameHeader;
    }()
  }, {
    key: "parseAdts",
    value: function () {
      var _parseAdts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(header) {
        var buf, framesPerSec, bytesPerFrame, bitrate;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              buf = Buffer.alloc(3);
              _context5.next = 3;
              return this.tokenizer.readBuffer(buf);
            case 3:
              header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);
              this.totalDataLength += header.frameLength;
              this.samplesPerFrame = 1024;
              framesPerSec = header.samplingRate / this.samplesPerFrame;
              bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;
              bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;
              this.metadata.setFormat('bitrate', bitrate);
              debug("frame-count=".concat(this.frameCount, ", size=").concat(header.frameLength, " bytes, bit-rate=").concat(bitrate));
              _context5.next = 13;
              return this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);
            case 13:
              if (!(this.frameCount === 3)) {
                _context5.next = 21;
                break;
              }
              this.metadata.setFormat('codecProfile', header.codecProfile);
              if (header.mp4ChannelConfig) {
                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);
              }
              if (!this.options.duration) {
                _context5.next = 20;
                break;
              }
              this.calculateEofDuration = true;
              _context5.next = 21;
              break;
            case 20:
              return _context5.abrupt("return", true);
            case 21:
              return _context5.abrupt("return", false);
            case 22:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function parseAdts(_x2) {
        return _parseAdts.apply(this, arguments);
      }
      return parseAdts;
    }()
  }, {
    key: "parseCrc",
    value: function () {
      var _parseCrc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.tokenizer.readNumber(Token.INT16_BE);
            case 2:
              this.crc = _context6.sent;
              this.offset += 2;
              return _context6.abrupt("return", this.skipSideInformation());
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function parseCrc() {
        return _parseCrc.apply(this, arguments);
      }
      return parseCrc;
    }()
  }, {
    key: "skipSideInformation",
    value: function () {
      var _skipSideInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var sideinfo_length;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              sideinfo_length = this.audioFrameHeader.calculateSideInfoLength(); // side information
              _context7.next = 3;
              return this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));
            case 3:
              this.offset += sideinfo_length;
              _context7.next = 6;
              return this.readXtraInfoHeader();
            case 6:
              return _context7.abrupt("return");
            case 7:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function skipSideInformation() {
        return _skipSideInformation.apply(this, arguments);
      }
      return skipSideInformation;
    }()
  }, {
    key: "readXtraInfoHeader",
    value: function () {
      var _readXtraInfoHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var headerTag, infoTag, codecProfile, version, frameDataLeft;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);
            case 2:
              headerTag = _context8.sent;
              this.offset += XingTag_1.InfoTagHeaderTag.len; // 12
              _context8.t0 = headerTag;
              _context8.next = _context8.t0 === 'Info' ? 7 : _context8.t0 === 'Xing' ? 9 : _context8.t0 === 'Xtra' ? 15 : _context8.t0 === 'LAME' ? 16 : 29;
              break;
            case 7:
              this.metadata.setFormat('codecProfile', 'CBR');
              return _context8.abrupt("return", this.readXingInfoHeader());
            case 9:
              _context8.next = 11;
              return this.readXingInfoHeader();
            case 11:
              infoTag = _context8.sent;
              codecProfile = getVbrCodecProfile(infoTag.vbrScale);
              this.metadata.setFormat('codecProfile', codecProfile);
              return _context8.abrupt("return", null);
            case 15:
              return _context8.abrupt("break", 29);
            case 16:
              _context8.next = 18;
              return this.tokenizer.readToken(XingTag_1.LameEncoderVersion);
            case 18:
              version = _context8.sent;
              if (!(this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len)) {
                _context8.next = 27;
                break;
              }
              this.offset += XingTag_1.LameEncoderVersion.len;
              this.metadata.setFormat('tool', 'LAME ' + version);
              _context8.next = 24;
              return this.skipFrameData(this.frame_size - this.offset);
            case 24:
              return _context8.abrupt("return", null);
            case 27:
              this.metadata.addWarning('Corrupt LAME header');
              return _context8.abrupt("break", 29);
            case 29:
              // ToDo: promise duration???
              frameDataLeft = this.frame_size - this.offset;
              if (!(frameDataLeft < 0)) {
                _context8.next = 34;
                break;
              }
              this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');
              _context8.next = 36;
              break;
            case 34:
              _context8.next = 36;
              return this.skipFrameData(frameDataLeft);
            case 36:
              return _context8.abrupt("return", null);
            case 37:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function readXtraInfoHeader() {
        return _readXtraInfoHeader.apply(this, arguments);
      }
      return readXtraInfoHeader;
    }()
    /**
     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
     * @returns {Promise<string>}
     */
  }, {
    key: "readXingInfoHeader",
    value: function () {
      var _readXingInfoHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var offset, infoTag, duration, frameDataLeft;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              offset = this.tokenizer.position;
              _context9.next = 3;
              return (0, XingTag_1.readXingHeader)(this.tokenizer);
            case 3:
              infoTag = _context9.sent;
              this.offset += this.tokenizer.position - offset;
              if (infoTag.lame) {
                this.metadata.setFormat('tool', 'LAME ' + common.stripNulls(infoTag.lame.version));
                if (infoTag.lame.extended) {
                  // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);
                  this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);
                  if (infoTag.lame.extended.track_gain) {
                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);
                  }
                  if (infoTag.lame.extended.album_gain) {
                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);
                  }
                  this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);
                }
              }
              if (!infoTag.streamSize) {
                _context9.next = 11;
                break;
              }
              duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
              this.metadata.setFormat('duration', duration);
              debug('Get duration from Xing header: %s', this.metadata.format.duration);
              return _context9.abrupt("return", infoTag);
            case 11:
              // frames field is not present
              frameDataLeft = this.frame_size - this.offset;
              _context9.next = 14;
              return this.skipFrameData(frameDataLeft);
            case 14:
              return _context9.abrupt("return", infoTag);
            case 15:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function readXingInfoHeader() {
        return _readXingInfoHeader.apply(this, arguments);
      }
      return readXingInfoHeader;
    }()
  }, {
    key: "skipFrameData",
    value: function () {
      var _skipFrameData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(frameDataLeft) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              if (!(frameDataLeft < 0)) {
                _context10.next = 2;
                break;
              }
              throw new Error('frame-data-left cannot be negative');
            case 2:
              _context10.next = 4;
              return this.tokenizer.ignore(frameDataLeft);
            case 4:
              this.countSkipFrameData += frameDataLeft;
            case 5:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function skipFrameData(_x3) {
        return _skipFrameData.apply(this, arguments);
      }
      return skipFrameData;
    }()
  }, {
    key: "areAllSame",
    value: function areAllSame(array) {
      var first = array[0];
      return array.every(function (element) {
        return element === first;
      });
    }
  }]);
  return MpegParser;
}(AbstractID3Parser_1.AbstractID3Parser);
exports.MpegParser = MpegParser;
},{"token-types":"node_modules/token-types/lib/index.js","strtok3/lib/core":"node_modules/strtok3/lib/core.js","debug":"node_modules/debug/src/browser.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","../id3v2/AbstractID3Parser":"node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","./XingTag":"node_modules/music-metadata/lib/mpeg/XingTag.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamReader = void 0;
var Token = require("token-types");
var debug_1 = require("debug");
var util = require("../../common/Util");
var debug = (0, debug_1.default)('music-metadata:parser:musepack:sv8');
var PacketKey = new Token.StringType(2, 'binary');
/**
 * Stream Header Packet part 1
 * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket
 */
var SH_part1 = {
  len: 5,
  get: function get(buf, off) {
    return {
      crc: Token.UINT32_LE.get(buf, off),
      streamVersion: Token.UINT8.get(buf, off + 4)
    };
  }
};
/**
 * Stream Header Packet part 3
 * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket
 */
var SH_part3 = {
  len: 2,
  get: function get(buf, off) {
    return {
      sampleFrequency: [44100, 48000, 37800, 32000][util.getBitAllignedNumber(buf, off, 0, 3)],
      maxUsedBands: util.getBitAllignedNumber(buf, off, 3, 5),
      channelCount: util.getBitAllignedNumber(buf, off + 1, 0, 4) + 1,
      msUsed: util.isBitSet(buf, off + 1, 4),
      audioBlockFrames: util.getBitAllignedNumber(buf, off + 1, 5, 3)
    };
  }
};
var StreamReader = /*#__PURE__*/function () {
  function StreamReader(tokenizer) {
    _classCallCheck(this, StreamReader);
    this.tokenizer = tokenizer;
  }
  _createClass(StreamReader, [{
    key: "readPacketHeader",
    value: function () {
      var _readPacketHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var key, size;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.readToken(PacketKey);
            case 2:
              key = _context.sent;
              _context.next = 5;
              return this.readVariableSizeField();
            case 5:
              size = _context.sent;
              return _context.abrupt("return", {
                key: key,
                payloadLength: size.value - 2 - size.len
              });
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function readPacketHeader() {
        return _readPacketHeader.apply(this, arguments);
      }
      return readPacketHeader;
    }()
  }, {
    key: "readStreamHeader",
    value: function () {
      var _readStreamHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(size) {
        var streamHeader, part1, sampleCount, bs, part3;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              streamHeader = {};
              debug("Reading SH at offset=".concat(this.tokenizer.position));
              _context2.next = 4;
              return this.tokenizer.readToken(SH_part1);
            case 4:
              part1 = _context2.sent;
              size -= SH_part1.len;
              Object.assign(streamHeader, part1);
              debug("SH.streamVersion = ".concat(part1.streamVersion));
              _context2.next = 10;
              return this.readVariableSizeField();
            case 10:
              sampleCount = _context2.sent;
              size -= sampleCount.len;
              streamHeader.sampleCount = sampleCount.value;
              _context2.next = 15;
              return this.readVariableSizeField();
            case 15:
              bs = _context2.sent;
              size -= bs.len;
              streamHeader.beginningOfSilence = bs.value;
              _context2.next = 20;
              return this.tokenizer.readToken(SH_part3);
            case 20:
              part3 = _context2.sent;
              size -= SH_part3.len;
              Object.assign(streamHeader, part3);
              // assert.equal(size, 0);
              _context2.next = 25;
              return this.tokenizer.ignore(size);
            case 25:
              return _context2.abrupt("return", streamHeader);
            case 26:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function readStreamHeader(_x) {
        return _readStreamHeader.apply(this, arguments);
      }
      return readStreamHeader;
    }()
  }, {
    key: "readVariableSizeField",
    value: function () {
      var _readVariableSizeField = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var len,
          hb,
          n,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              len = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 1;
              hb = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
              _context3.next = 4;
              return this.tokenizer.readNumber(Token.UINT8);
            case 4:
              n = _context3.sent;
              if (!((n & 0x80) === 0)) {
                _context3.next = 7;
                break;
              }
              return _context3.abrupt("return", {
                len: len,
                value: hb + n
              });
            case 7:
              n &= 0x7F;
              n += hb;
              return _context3.abrupt("return", this.readVariableSizeField(len + 1, n << 7));
            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function readVariableSizeField() {
        return _readVariableSizeField.apply(this, arguments);
      }
      return readVariableSizeField;
    }()
  }]);
  return StreamReader;
}();
exports.StreamReader = StreamReader;
},{"token-types":"node_modules/token-types/lib/index.js","debug":"node_modules/debug/src/browser.js","../../common/Util":"node_modules/music-metadata/lib/common/Util.js"}],"node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MpcSv8Parser = void 0;
var debug_1 = require("debug");
var BasicParser_1 = require("../../common/BasicParser");
var APEv2Parser_1 = require("../../apev2/APEv2Parser");
var FourCC_1 = require("../../common/FourCC");
var SV8 = require("./StreamVersion8");
var debug = (0, debug_1.default)('music-metadata:parser:musepack');
var MpcSv8Parser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(MpcSv8Parser, _BasicParser_1$BasicP);
  var _super = _createSuper(MpcSv8Parser);
  function MpcSv8Parser() {
    var _this;
    _classCallCheck(this, MpcSv8Parser);
    _this = _super.apply(this, arguments);
    _this.audioLength = 0;
    return _this;
  }
  _createClass(MpcSv8Parser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var signature;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.readToken(FourCC_1.FourCcToken);
            case 2:
              signature = _context.sent;
              if (!(signature !== 'MPCK')) {
                _context.next = 5;
                break;
              }
              throw new Error('Invalid Magic number');
            case 5:
              this.metadata.setFormat('container', 'Musepack, SV8');
              return _context.abrupt("return", this.parsePacket());
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "parsePacket",
    value: function () {
      var _parsePacket = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var sv8reader, header, sh;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              sv8reader = new SV8.StreamReader(this.tokenizer);
            case 1:
              _context2.next = 3;
              return sv8reader.readPacketHeader();
            case 3:
              header = _context2.sent;
              debug("packet-header key=".concat(header.key, ", payloadLength=").concat(header.payloadLength));
              _context2.t0 = header.key;
              _context2.next = _context2.t0 === 'SH' ? 8 : _context2.t0 === 'AP' ? 16 : _context2.t0 === 'RG' ? 20 : _context2.t0 === 'EI' ? 20 : _context2.t0 === 'SO' ? 20 : _context2.t0 === 'ST' ? 20 : _context2.t0 === 'CT' ? 20 : _context2.t0 === 'SE' ? 23 : 25;
              break;
            case 8:
              _context2.next = 10;
              return sv8reader.readStreamHeader(header.payloadLength);
            case 10:
              sh = _context2.sent;
              this.metadata.setFormat('numberOfSamples', sh.sampleCount);
              this.metadata.setFormat('sampleRate', sh.sampleFrequency);
              this.metadata.setFormat('duration', sh.sampleCount / sh.sampleFrequency);
              this.metadata.setFormat('numberOfChannels', sh.channelCount);
              return _context2.abrupt("break", 26);
            case 16:
              // Audio Packet
              this.audioLength += header.payloadLength;
              _context2.next = 19;
              return this.tokenizer.ignore(header.payloadLength);
            case 19:
              return _context2.abrupt("break", 26);
            case 20:
              _context2.next = 22;
              return this.tokenizer.ignore(header.payloadLength);
            case 22:
              return _context2.abrupt("break", 26);
            case 23:
              // Stream End
              this.metadata.setFormat('bitrate', this.audioLength * 8 / this.metadata.format.duration);
              return _context2.abrupt("return", APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options));
            case 25:
              throw new Error("Unexpected header: ".concat(header.key));
            case 26:
              if (true) {
                _context2.next = 1;
                break;
              }
            case 27:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parsePacket() {
        return _parsePacket.apply(this, arguments);
      }
      return parsePacket;
    }()
  }]);
  return MpcSv8Parser;
}(BasicParser_1.BasicParser);
exports.MpcSv8Parser = MpcSv8Parser;
},{"debug":"node_modules/debug/src/browser.js","../../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","../../apev2/APEv2Parser":"node_modules/music-metadata/lib/apev2/APEv2Parser.js","../../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js","./StreamVersion8":"node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js"}],"node_modules/music-metadata/lib/musepack/sv7/BitReader.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitReader = void 0;
var Token = require("token-types");
var BitReader = /*#__PURE__*/function () {
  function BitReader(tokenizer) {
    _classCallCheck(this, BitReader);
    this.tokenizer = tokenizer;
    this.pos = 0;
    this.dword = undefined;
  }
  /**
   *
   * @param bits 1..30 bits
   */
  _createClass(BitReader, [{
    key: "read",
    value: function () {
      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(bits) {
        var out;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(this.dword === undefined)) {
                _context.next = 6;
                break;
              }
              _context.next = 3;
              return this.tokenizer.readToken(Token.UINT32_LE);
            case 3:
              this.dword = _context.sent;
              _context.next = 0;
              break;
            case 6:
              out = this.dword;
              this.pos += bits;
              if (!(this.pos < 32)) {
                _context.next = 13;
                break;
              }
              out >>>= 32 - this.pos;
              return _context.abrupt("return", out & (1 << bits) - 1);
            case 13:
              this.pos -= 32;
              if (!(this.pos === 0)) {
                _context.next = 19;
                break;
              }
              this.dword = undefined;
              return _context.abrupt("return", out & (1 << bits) - 1);
            case 19:
              _context.next = 21;
              return this.tokenizer.readToken(Token.UINT32_LE);
            case 21:
              this.dword = _context.sent;
              if (this.pos) {
                out <<= this.pos;
                out |= this.dword >>> 32 - this.pos;
              }
              return _context.abrupt("return", out & (1 << bits) - 1);
            case 24:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function read(_x) {
        return _read.apply(this, arguments);
      }
      return read;
    }()
  }, {
    key: "ignore",
    value: function () {
      var _ignore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(bits) {
        var remaining, remainder, numOfWords;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (this.pos > 0) {
                remaining = 32 - this.pos;
                this.dword = undefined;
                bits -= remaining;
                this.pos = 0;
              }
              remainder = bits % 32;
              numOfWords = (bits - remainder) / 32;
              _context2.next = 5;
              return this.tokenizer.ignore(numOfWords * 4);
            case 5:
              return _context2.abrupt("return", this.read(remainder));
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function ignore(_x2) {
        return _ignore.apply(this, arguments);
      }
      return ignore;
    }()
  }]);
  return BitReader;
}();
exports.BitReader = BitReader;
},{"token-types":"node_modules/token-types/lib/index.js"}],"node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Header = void 0;
var Token = require("token-types");
var util = require("../../common/Util");
/**
 * BASIC STRUCTURE
 */
exports.Header = {
  len: 6 * 4,
  get: function get(buf, off) {
    var header = {
      // word 0
      signature: Buffer.from(buf).toString('latin1', off, off + 3),
      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
      streamMinorVersion: util.getBitAllignedNumber(buf, off + 3, 0, 4),
      streamMajorVersion: util.getBitAllignedNumber(buf, off + 3, 4, 4),
      // word 1
      frameCount: Token.UINT32_LE.get(buf, off + 4),
      // word 2
      maxLevel: Token.UINT16_LE.get(buf, off + 8),
      sampleFrequency: [44100, 48000, 37800, 32000][util.getBitAllignedNumber(buf, off + 10, 0, 2)],
      link: util.getBitAllignedNumber(buf, off + 10, 2, 2),
      profile: util.getBitAllignedNumber(buf, off + 10, 4, 4),
      maxBand: util.getBitAllignedNumber(buf, off + 11, 0, 6),
      intensityStereo: util.isBitSet(buf, off + 11, 6),
      midSideStereo: util.isBitSet(buf, off + 11, 7),
      // word 3
      titlePeak: Token.UINT16_LE.get(buf, off + 12),
      titleGain: Token.UINT16_LE.get(buf, off + 14),
      // word 4
      albumPeak: Token.UINT16_LE.get(buf, off + 16),
      albumGain: Token.UINT16_LE.get(buf, off + 18),
      // word
      lastFrameLength: Token.UINT32_LE.get(buf, off + 20) >>> 20 & 0x7FF,
      trueGapless: util.isBitSet(buf, off + 23, 0)
    };
    header.lastFrameLength = header.trueGapless ? Token.UINT32_LE.get(buf, 20) >>> 20 & 0x7FF : 0;
    return header;
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../../common/Util":"node_modules/music-metadata/lib/common/Util.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MpcSv7Parser = void 0;
var debug_1 = require("debug");
var BasicParser_1 = require("../../common/BasicParser");
var APEv2Parser_1 = require("../../apev2/APEv2Parser");
var BitReader_1 = require("./BitReader");
var SV7 = require("./StreamVersion7");
var debug = (0, debug_1.default)('music-metadata:parser:musepack');
var MpcSv7Parser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(MpcSv7Parser, _BasicParser_1$BasicP);
  var _super = _createSuper(MpcSv7Parser);
  function MpcSv7Parser() {
    var _this;
    _classCallCheck(this, MpcSv7Parser);
    _this = _super.apply(this, arguments);
    _this.audioLength = 0;
    return _this;
  }
  _createClass(MpcSv7Parser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var header, numberOfSamples, version;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.readToken(SV7.Header);
            case 2:
              header = _context.sent;
              if (!(header.signature !== 'MP+')) {
                _context.next = 5;
                break;
              }
              throw new Error('Unexpected magic number');
            case 5:
              debug("stream-version=".concat(header.streamMajorVersion, ".").concat(header.streamMinorVersion));
              this.metadata.setFormat('container', 'Musepack, SV7');
              this.metadata.setFormat('sampleRate', header.sampleFrequency);
              numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;
              this.metadata.setFormat('numberOfSamples', numberOfSamples);
              this.duration = numberOfSamples / header.sampleFrequency;
              this.metadata.setFormat('duration', this.duration);
              this.bitreader = new BitReader_1.BitReader(this.tokenizer);
              this.metadata.setFormat('numberOfChannels', header.midSideStereo || header.intensityStereo ? 2 : 1);
              _context.next = 16;
              return this.bitreader.read(8);
            case 16:
              version = _context.sent;
              this.metadata.setFormat('codec', (version / 100).toFixed(2));
              _context.next = 20;
              return this.skipAudioData(header.frameCount);
            case 20:
              debug("End of audio stream, switching to APEv2, offset=".concat(this.tokenizer.position));
              return _context.abrupt("return", APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options));
            case 22:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "skipAudioData",
    value: function () {
      var _skipAudioData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(frameCount) {
        var frameLength, lastFrameLength;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(frameCount-- > 0)) {
                _context2.next = 9;
                break;
              }
              _context2.next = 3;
              return this.bitreader.read(20);
            case 3:
              frameLength = _context2.sent;
              this.audioLength += 20 + frameLength;
              _context2.next = 7;
              return this.bitreader.ignore(frameLength);
            case 7:
              _context2.next = 0;
              break;
            case 9:
              _context2.next = 11;
              return this.bitreader.read(11);
            case 11:
              lastFrameLength = _context2.sent;
              this.audioLength += lastFrameLength;
              this.metadata.setFormat('bitrate', this.audioLength / this.duration);
            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function skipAudioData(_x) {
        return _skipAudioData.apply(this, arguments);
      }
      return skipAudioData;
    }()
  }]);
  return MpcSv7Parser;
}(BasicParser_1.BasicParser);
exports.MpcSv7Parser = MpcSv7Parser;
},{"debug":"node_modules/debug/src/browser.js","../../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","../../apev2/APEv2Parser":"node_modules/music-metadata/lib/apev2/APEv2Parser.js","./BitReader":"node_modules/music-metadata/lib/musepack/sv7/BitReader.js","./StreamVersion7":"node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js"}],"node_modules/music-metadata/lib/musepack/index.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var debug_1 = require("debug");
var Token = require("token-types");
var AbstractID3Parser_1 = require("../id3v2/AbstractID3Parser");
var MpcSv8Parser_1 = require("./sv8/MpcSv8Parser");
var MpcSv7Parser_1 = require("./sv7/MpcSv7Parser");
var debug = (0, debug_1.default)('music-metadata:parser:musepack');
var MusepackParser = /*#__PURE__*/function (_AbstractID3Parser_1$) {
  _inherits(MusepackParser, _AbstractID3Parser_1$);
  var _super = _createSuper(MusepackParser);
  function MusepackParser() {
    _classCallCheck(this, MusepackParser);
    return _super.apply(this, arguments);
  }
  _createClass(MusepackParser, [{
    key: "postId3v2Parse",
    value: function () {
      var _postId3v2Parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var signature, mpcParser;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.peekToken(new Token.StringType(3, 'binary'));
            case 2:
              signature = _context.sent;
              _context.t0 = signature;
              _context.next = _context.t0 === 'MP+' ? 6 : _context.t0 === 'MPC' ? 9 : 12;
              break;
            case 6:
              debug('Musepack stream-version 7');
              mpcParser = new MpcSv7Parser_1.MpcSv7Parser();
              return _context.abrupt("break", 13);
            case 9:
              debug('Musepack stream-version 8');
              mpcParser = new MpcSv8Parser_1.MpcSv8Parser();
              return _context.abrupt("break", 13);
            case 12:
              throw new Error('Invalid Musepack signature prefix');
            case 13:
              mpcParser.init(this.metadata, this.tokenizer, this.options);
              return _context.abrupt("return", mpcParser.parse());
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function postId3v2Parse() {
        return _postId3v2Parse.apply(this, arguments);
      }
      return postId3v2Parse;
    }()
  }]);
  return MusepackParser;
}(AbstractID3Parser_1.AbstractID3Parser);
exports.default = MusepackParser;
},{"debug":"node_modules/debug/src/browser.js","token-types":"node_modules/token-types/lib/index.js","../id3v2/AbstractID3Parser":"node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","./sv8/MpcSv8Parser":"node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js","./sv7/MpcSv7Parser":"node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js"}],"node_modules/music-metadata/lib/ogg/opus/Opus.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdHeader = void 0;
var Token = require("token-types");
/**
 * Opus ID Header parser
 * Ref: https://wiki.xiph.org/OggOpus#ID_Header
 */
var IdHeader = /*#__PURE__*/function () {
  function IdHeader(len) {
    _classCallCheck(this, IdHeader);
    this.len = len;
    if (len < 19) {
      throw new Error("ID-header-page 0 should be at least 19 bytes long");
    }
  }
  _createClass(IdHeader, [{
    key: "get",
    value: function get(buf, off) {
      return {
        magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),
        version: buf.readUInt8(off + 8),
        channelCount: buf.readUInt8(off + 9),
        preSkip: buf.readInt16LE(off + 10),
        inputSampleRate: buf.readInt32LE(off + 12),
        outputGain: buf.readInt16LE(off + 16),
        channelMapping: buf.readUInt8(off + 18)
      };
    }
  }]);
  return IdHeader;
}();
exports.IdHeader = IdHeader;
},{"token-types":"node_modules/token-types/lib/index.js"}],"node_modules/music-metadata/lib/ogg/opus/OpusParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpusParser = void 0;
var Token = require("token-types");
var VorbisParser_1 = require("../vorbis/VorbisParser");
var Opus = require("./Opus");
/**
 * Opus parser
 * Internet Engineering Task Force (IETF) - RFC 6716
 * Used by OggParser
 */
var OpusParser = /*#__PURE__*/function (_VorbisParser_1$Vorbi) {
  _inherits(OpusParser, _VorbisParser_1$Vorbi);
  var _super = _createSuper(OpusParser);
  function OpusParser(metadata, options, tokenizer) {
    var _this;
    _classCallCheck(this, OpusParser);
    _this = _super.call(this, metadata, options);
    _this.tokenizer = tokenizer;
    _this.lastPos = -1;
    return _this;
  }
  /**
   * Parse first Opus Ogg page
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  _createClass(OpusParser, [{
    key: "parseFirstPage",
    value: function parseFirstPage(header, pageData) {
      this.metadata.setFormat('codec', 'Opus');
      // Parse Opus ID Header
      this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);
      if (this.idHeader.magicSignature !== "OpusHead") throw new Error("Illegal ogg/Opus magic-signature");
      this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);
      this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);
    }
  }, {
    key: "parseFullPage",
    value: function parseFullPage(pageData) {
      var magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);
      switch (magicSignature) {
        case 'OpusTags':
          this.parseUserCommentList(pageData, 8);
          this.lastPos = this.tokenizer.position - pageData.length;
          break;
        default:
          break;
      }
    }
  }, {
    key: "calculateDuration",
    value: function calculateDuration(header) {
      if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
        // Calculate duration
        var pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;
        this.metadata.setFormat('numberOfSamples', pos_48bit);
        this.metadata.setFormat('duration', pos_48bit / 48000);
        if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
          var dataSize = this.tokenizer.fileInfo.size - this.lastPos;
          this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);
        }
      }
    }
  }]);
  return OpusParser;
}(VorbisParser_1.VorbisParser);
exports.OpusParser = OpusParser;
},{"token-types":"node_modules/token-types/lib/index.js","../vorbis/VorbisParser":"node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js","./Opus":"node_modules/music-metadata/lib/ogg/opus/Opus.js"}],"node_modules/music-metadata/lib/ogg/speex/Speex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Header = void 0;
var Token = require("token-types");
var util = require("../../common/Util");
/**
 * Speex Header Packet
 * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000
 */
exports.Header = {
  len: 80,
  get: function get(buf, off) {
    return {
      speex: new Token.StringType(8, 'ascii').get(buf, off + 0),
      version: util.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),
      version_id: buf.readInt32LE(off + 28),
      header_size: buf.readInt32LE(off + 32),
      rate: buf.readInt32LE(off + 36),
      mode: buf.readInt32LE(off + 40),
      mode_bitstream_version: buf.readInt32LE(off + 44),
      nb_channels: buf.readInt32LE(off + 48),
      bitrate: buf.readInt32LE(off + 52),
      frame_size: buf.readInt32LE(off + 56),
      vbr: buf.readInt32LE(off + 60),
      frames_per_packet: buf.readInt32LE(off + 64),
      extra_headers: buf.readInt32LE(off + 68),
      reserved1: buf.readInt32LE(off + 72),
      reserved2: buf.readInt32LE(off + 76)
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../../common/Util":"node_modules/music-metadata/lib/common/Util.js"}],"node_modules/music-metadata/lib/ogg/speex/SpeexParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpeexParser = void 0;
var debug_1 = require("debug");
var VorbisParser_1 = require("../vorbis/VorbisParser");
var Speex = require("./Speex");
var debug = (0, debug_1.default)('music-metadata:parser:ogg:speex');
/**
 * Speex, RFC 5574
 * Ref:
 * - https://www.speex.org/docs/manual/speex-manual/
 * - https://tools.ietf.org/html/rfc5574
 */
var SpeexParser = /*#__PURE__*/function (_VorbisParser_1$Vorbi) {
  _inherits(SpeexParser, _VorbisParser_1$Vorbi);
  var _super = _createSuper(SpeexParser);
  function SpeexParser(metadata, options, tokenizer) {
    var _this;
    _classCallCheck(this, SpeexParser);
    _this = _super.call(this, metadata, options);
    _this.tokenizer = tokenizer;
    return _this;
  }
  /**
   * Parse first Speex Ogg page
   * @param {IPageHeader} header
   * @param {Buffer} pageData
   */
  _createClass(SpeexParser, [{
    key: "parseFirstPage",
    value: function parseFirstPage(header, pageData) {
      debug('First Ogg/Speex page');
      var speexHeader = Speex.Header.get(pageData, 0);
      this.metadata.setFormat('codec', "Speex ".concat(speexHeader.version));
      this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);
      this.metadata.setFormat('sampleRate', speexHeader.rate);
      if (speexHeader.bitrate !== -1) {
        this.metadata.setFormat('bitrate', speexHeader.bitrate);
      }
    }
  }]);
  return SpeexParser;
}(VorbisParser_1.VorbisParser);
exports.SpeexParser = SpeexParser;
},{"debug":"node_modules/debug/src/browser.js","../vorbis/VorbisParser":"node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js","./Speex":"node_modules/music-metadata/lib/ogg/speex/Speex.js"}],"node_modules/music-metadata/lib/ogg/theora/Theora.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdentificationHeader = void 0;
var Token = require("token-types");
/**
 * 6.2 Identification Header
 * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode
 */
exports.IdentificationHeader = {
  len: 42,
  get: function get(buf, off) {
    return {
      id: new Token.StringType(7, 'ascii').get(buf, off),
      vmaj: buf.readUInt8(off + 7),
      vmin: buf.readUInt8(off + 8),
      vrev: buf.readUInt8(off + 9),
      vmbw: buf.readUInt16BE(off + 10),
      vmbh: buf.readUInt16BE(off + 17),
      nombr: Token.UINT24_BE.get(buf, off + 37),
      nqual: buf.readUInt8(off + 40)
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js"}],"node_modules/music-metadata/lib/ogg/theora/TheoraParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TheoraParser = void 0;
var debug_1 = require("debug");
var Theora_1 = require("./Theora");
var debug = (0, debug_1.default)('music-metadata:parser:ogg:theora');
/**
 * Ref:
 * - https://theora.org/doc/Theora.pdf
 */
var TheoraParser = /*#__PURE__*/function () {
  function TheoraParser(metadata, options, tokenizer) {
    _classCallCheck(this, TheoraParser);
    this.metadata = metadata;
    this.tokenizer = tokenizer;
  }
  /**
   * Vorbis 1 parser
   * @param header Ogg Page Header
   * @param pageData Page data
   */
  _createClass(TheoraParser, [{
    key: "parsePage",
    value: function parsePage(header, pageData) {
      if (header.headerType.firstPage) {
        this.parseFirstPage(header, pageData);
      }
    }
  }, {
    key: "flush",
    value: function flush() {
      debug('flush');
    }
  }, {
    key: "calculateDuration",
    value: function calculateDuration(header) {
      debug('duration calculation not implemented');
    }
    /**
     * Parse first Theora Ogg page. the initial identification header packet
     * @param {IPageHeader} header
     * @param {Buffer} pageData
     */
  }, {
    key: "parseFirstPage",
    value: function parseFirstPage(header, pageData) {
      debug('First Ogg/Theora page');
      this.metadata.setFormat('codec', 'Theora');
      var idHeader = Theora_1.IdentificationHeader.get(pageData, 0);
      this.metadata.setFormat('bitrate', idHeader.nombr);
    }
  }]);
  return TheoraParser;
}();
exports.TheoraParser = TheoraParser;
},{"debug":"node_modules/debug/src/browser.js","./Theora":"node_modules/music-metadata/lib/ogg/theora/Theora.js"}],"node_modules/music-metadata/lib/ogg/OggParser.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OggParser = exports.SegmentTable = void 0;
var Token = require("token-types");
var core_1 = require("strtok3/lib/core");
var debug_1 = require("debug");
var util = require("../common/Util");
var FourCC_1 = require("../common/FourCC");
var BasicParser_1 = require("../common/BasicParser");
var VorbisParser_1 = require("./vorbis/VorbisParser");
var OpusParser_1 = require("./opus/OpusParser");
var SpeexParser_1 = require("./speex/SpeexParser");
var TheoraParser_1 = require("./theora/TheoraParser");
var debug = (0, debug_1.default)('music-metadata:parser:ogg');
var SegmentTable = /*#__PURE__*/function () {
  function SegmentTable(header) {
    _classCallCheck(this, SegmentTable);
    this.len = header.page_segments;
  }
  _createClass(SegmentTable, [{
    key: "get",
    value: function get(buf, off) {
      return {
        totalPageSize: SegmentTable.sum(buf, off, this.len)
      };
    }
  }], [{
    key: "sum",
    value: function sum(buf, off, len) {
      var s = 0;
      for (var i = off; i < off + len; ++i) {
        s += buf[i];
      }
      return s;
    }
  }]);
  return SegmentTable;
}();
exports.SegmentTable = SegmentTable;
/**
 * Parser for Ogg logical bitstream framing
 */
var OggParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(OggParser, _BasicParser_1$BasicP);
  var _super = _createSuper(OggParser);
  function OggParser() {
    _classCallCheck(this, OggParser);
    return _super.apply(this, arguments);
  }
  _createClass(OggParser, [{
    key: "parse",
    value:
    /**
     * Parse page
     * @returns {Promise<void>}
     */
    function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var header, segmentTable, pageData, id;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              debug('pos=%s, parsePage()', this.tokenizer.position);
              _context.prev = 1;
            case 2:
              _context.next = 4;
              return this.tokenizer.readToken(OggParser.Header);
            case 4:
              header = _context.sent;
              if (!(header.capturePattern !== 'OggS')) {
                _context.next = 7;
                break;
              }
              throw new Error('Invalid Ogg capture pattern');
            case 7:
              this.metadata.setFormat('container', 'Ogg');
              this.header = header;
              this.pageNumber = header.pageSequenceNo;
              debug('page#=%s, Ogg.id=%s', header.pageSequenceNo, header.capturePattern);
              _context.next = 13;
              return this.tokenizer.readToken(new SegmentTable(header));
            case 13:
              segmentTable = _context.sent;
              debug('totalPageSize=%s', segmentTable.totalPageSize);
              _context.next = 17;
              return this.tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));
            case 17:
              pageData = _context.sent;
              debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);
              if (!header.headerType.firstPage) {
                _context.next = 37;
                break;
              }
              id = new Token.StringType(7, 'ascii').get(Buffer.from(pageData), 0);
              _context.t0 = id;
              _context.next = _context.t0 === '\x01vorbis' ? 24 : _context.t0 === 'OpusHea' ? 27 : _context.t0 === 'Speex  ' ? 30 : _context.t0 === 'fishead' ? 33 : _context.t0 === '\x00theora' ? 33 : 36;
              break;
            case 24:
              // Ogg/Vorbis
              debug('Set page consumer to Ogg/Vorbis');
              this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);
              return _context.abrupt("break", 37);
            case 27:
              // Ogg/Opus
              debug('Set page consumer to Ogg/Opus');
              this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);
              return _context.abrupt("break", 37);
            case 30:
              // Ogg/Speex
              debug('Set page consumer to Ogg/Speex');
              this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);
              return _context.abrupt("break", 37);
            case 33:
              // Ogg/Theora
              debug('Set page consumer to Ogg/Theora');
              this.pageConsumer = new TheoraParser_1.TheoraParser(this.metadata, this.options, this.tokenizer);
              return _context.abrupt("break", 37);
            case 36:
              throw new Error('gg audio-codec not recognized (id=' + id + ')');
            case 37:
              this.pageConsumer.parsePage(header, pageData);
            case 38:
              if (!header.headerType.lastPage) {
                _context.next = 2;
                break;
              }
            case 39:
              _context.next = 55;
              break;
            case 41:
              _context.prev = 41;
              _context.t1 = _context["catch"](1);
              if (!(_context.t1 instanceof core_1.EndOfStreamError)) {
                _context.next = 50;
                break;
              }
              this.metadata.addWarning('Last OGG-page is not marked with last-page flag');
              debug("End-of-stream");
              this.metadata.addWarning('Last OGG-page is not marked with last-page flag');
              if (this.header) {
                this.pageConsumer.calculateDuration(this.header);
              }
              _context.next = 55;
              break;
            case 50:
              if (!_context.t1.message.startsWith('FourCC')) {
                _context.next = 54;
                break;
              }
              if (this.pageNumber > 0) {
                // ignore this error: work-around if last OGG-page is not marked with last-page flag
                this.metadata.addWarning('Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag');
                this.pageConsumer.flush();
              }
              _context.next = 55;
              break;
            case 54:
              throw _context.t1;
            case 55:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 41]]);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }]);
  return OggParser;
}(BasicParser_1.BasicParser);
OggParser.Header = {
  len: 27,
  get: function get(buf, off) {
    return {
      capturePattern: FourCC_1.FourCcToken.get(buf, off),
      version: Token.UINT8.get(buf, off + 4),
      headerType: {
        continued: util.getBit(buf, off + 5, 0),
        firstPage: util.getBit(buf, off + 5, 1),
        lastPage: util.getBit(buf, off + 5, 2)
      },
      // packet_flag: buf.readUInt8(off + 5),
      absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),
      streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),
      pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),
      pageChecksum: Token.UINT32_LE.get(buf, off + 22),
      page_segments: Token.UINT8.get(buf, off + 26)
    };
  }
};
exports.OggParser = OggParser;
},{"token-types":"node_modules/token-types/lib/index.js","strtok3/lib/core":"node_modules/strtok3/lib/core.js","debug":"node_modules/debug/src/browser.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","./vorbis/VorbisParser":"node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js","./opus/OpusParser":"node_modules/music-metadata/lib/ogg/opus/OpusParser.js","./speex/SpeexParser":"node_modules/music-metadata/lib/ogg/speex/SpeexParser.js","./theora/TheoraParser":"node_modules/music-metadata/lib/ogg/theora/TheoraParser.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/riff/RiffChunk.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ListInfoTagValue = exports.Header = void 0;
var Token = require("token-types");
/**
 * Common RIFF chunk header
 */
exports.Header = {
  len: 8,
  get: function get(buf, off) {
    return {
      // Group-ID
      chunkID: buf.toString('binary', off, off + 4),
      // Size
      chunkSize: Token.UINT32_LE.get(buf, 4)
    };
  }
};
/**
 * Token to parse RIFF-INFO tag value
 */
var ListInfoTagValue = /*#__PURE__*/function () {
  function ListInfoTagValue(tagHeader) {
    _classCallCheck(this, ListInfoTagValue);
    this.tagHeader = tagHeader;
    this.len = tagHeader.chunkSize;
    this.len += this.len & 1; // if it is an odd length, round up to even
  }
  _createClass(ListInfoTagValue, [{
    key: "get",
    value: function get(buf, off) {
      return new Token.StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);
    }
  }]);
  return ListInfoTagValue;
}();
exports.ListInfoTagValue = ListInfoTagValue;
},{"token-types":"node_modules/token-types/lib/index.js"}],"node_modules/music-metadata/lib/wav/WaveChunk.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FactChunk = exports.Format = exports.WaveFormat = void 0;
/**
 * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx
 */
var WaveFormat;
(function (WaveFormat) {
  WaveFormat[WaveFormat["PCM"] = 1] = "PCM";
  // MPEG-4 and AAC Audio Types
  WaveFormat[WaveFormat["ADPCM"] = 2] = "ADPCM";
  WaveFormat[WaveFormat["IEEE_FLOAT"] = 3] = "IEEE_FLOAT";
  WaveFormat[WaveFormat["MPEG_ADTS_AAC"] = 5632] = "MPEG_ADTS_AAC";
  WaveFormat[WaveFormat["MPEG_LOAS"] = 5634] = "MPEG_LOAS";
  WaveFormat[WaveFormat["RAW_AAC1"] = 255] = "RAW_AAC1";
  // Dolby Audio Types
  WaveFormat[WaveFormat["DOLBY_AC3_SPDIF"] = 146] = "DOLBY_AC3_SPDIF";
  WaveFormat[WaveFormat["DVM"] = 8192] = "DVM";
  WaveFormat[WaveFormat["RAW_SPORT"] = 576] = "RAW_SPORT";
  WaveFormat[WaveFormat["ESST_AC3"] = 577] = "ESST_AC3";
  WaveFormat[WaveFormat["DRM"] = 9] = "DRM";
  WaveFormat[WaveFormat["DTS2"] = 8193] = "DTS2";
  WaveFormat[WaveFormat["MPEG"] = 80] = "MPEG";
})(WaveFormat = exports.WaveFormat || (exports.WaveFormat = {}));
/**
 * format chunk; chunk-id is "fmt "
 * http://soundfile.sapp.org/doc/WaveFormat/
 */
var Format = /*#__PURE__*/function () {
  function Format(header) {
    _classCallCheck(this, Format);
    if (header.chunkSize < 16) throw new Error('Invalid chunk size');
    this.len = header.chunkSize;
  }
  _createClass(Format, [{
    key: "get",
    value: function get(buf, off) {
      return {
        wFormatTag: buf.readUInt16LE(off),
        nChannels: buf.readUInt16LE(off + 2),
        nSamplesPerSec: buf.readUInt32LE(off + 4),
        nAvgBytesPerSec: buf.readUInt32LE(off + 8),
        nBlockAlign: buf.readUInt16LE(off + 12),
        wBitsPerSample: buf.readUInt16LE(off + 14)
      };
    }
  }]);
  return Format;
}();
exports.Format = Format;
/**
 * Fact chunk; chunk-id is "fact"
 * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html
 * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file
 */
var FactChunk = /*#__PURE__*/function () {
  function FactChunk(header) {
    _classCallCheck(this, FactChunk);
    if (header.chunkSize < 4) {
      throw new Error('Invalid fact chunk size.');
    }
    this.len = header.chunkSize;
  }
  _createClass(FactChunk, [{
    key: "get",
    value: function get(buf, off) {
      return {
        dwSampleLength: buf.readUInt32LE(off)
      };
    }
  }]);
  return FactChunk;
}();
exports.FactChunk = FactChunk;
},{}],"node_modules/music-metadata/lib/wav/BwfChunk.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BroadcastAudioExtensionChunk = void 0;
var Token = require("token-types");
var Util_1 = require("../common/Util");
/**
 * Broadcast Audio Extension Chunk
 * Ref: https://tech.ebu.ch/docs/tech/tech3285.pdf
 */
exports.BroadcastAudioExtensionChunk = {
  len: 420,
  get: function get(uint8array, off) {
    return {
      description: (0, Util_1.stripNulls)(new Token.StringType(256, 'ascii').get(uint8array, off)).trim(),
      originator: (0, Util_1.stripNulls)(new Token.StringType(32, 'ascii').get(uint8array, off + 256)).trim(),
      originatorReference: (0, Util_1.stripNulls)(new Token.StringType(32, 'ascii').get(uint8array, off + 288)).trim(),
      originationDate: (0, Util_1.stripNulls)(new Token.StringType(10, 'ascii').get(uint8array, off + 320)).trim(),
      originationTime: (0, Util_1.stripNulls)(new Token.StringType(8, 'ascii').get(uint8array, off + 330)).trim(),
      timeReferenceLow: Token.UINT32_LE.get(uint8array, off + 338),
      timeReferenceHigh: Token.UINT32_LE.get(uint8array, off + 342),
      version: Token.UINT16_LE.get(uint8array, off + 346),
      umid: new Token.Uint8ArrayType(64).get(uint8array, off + 348),
      loudnessValue: Token.UINT16_LE.get(uint8array, off + 412),
      maxTruePeakLevel: Token.UINT16_LE.get(uint8array, off + 414),
      maxMomentaryLoudness: Token.UINT16_LE.get(uint8array, off + 416),
      maxShortTermLoudness: Token.UINT16_LE.get(uint8array, off + 418)
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js"}],"node_modules/music-metadata/lib/wav/WaveParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaveParser = void 0;
var strtok3 = require("strtok3/lib/core");
var Token = require("token-types");
var debug_1 = require("debug");
var riff = require("../riff/RiffChunk");
var WaveChunk = require("./../wav/WaveChunk");
var ID3v2Parser_1 = require("../id3v2/ID3v2Parser");
var util = require("../common/Util");
var FourCC_1 = require("../common/FourCC");
var BasicParser_1 = require("../common/BasicParser");
var BwfChunk_1 = require("../wav/BwfChunk");
var debug = (0, debug_1.default)('music-metadata:parser:RIFF');
/**
 * Resource Interchange File Format (RIFF) Parser
 *
 * WAVE PCM soundfile format
 *
 * Ref:
 * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html
 * - http://soundfile.sapp.org/doc/WaveFormat
 *
 * ToDo: Split WAVE part from RIFF parser
 */
var WaveParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(WaveParser, _BasicParser_1$BasicP);
  var _super = _createSuper(WaveParser);
  function WaveParser() {
    _classCallCheck(this, WaveParser);
    return _super.apply(this, arguments);
  }
  _createClass(WaveParser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var riffHeader;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.readToken(riff.Header);
            case 2:
              riffHeader = _context.sent;
              debug("pos=".concat(this.tokenizer.position, ", parse: chunkID=").concat(riffHeader.chunkID));
              if (!(riffHeader.chunkID !== 'RIFF')) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return");
            case 6:
              return _context.abrupt("return", this.parseRiffChunk(riffHeader.chunkSize).catch(function (err) {
                if (!(err instanceof strtok3.EndOfStreamError)) {
                  throw err;
                }
              }));
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "parseRiffChunk",
    value: function () {
      var _parseRiffChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(chunkSize) {
        var type;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.tokenizer.readToken(FourCC_1.FourCcToken);
            case 2:
              type = _context2.sent;
              this.metadata.setFormat('container', type);
              _context2.t0 = type;
              _context2.next = _context2.t0 === 'WAVE' ? 7 : 8;
              break;
            case 7:
              return _context2.abrupt("return", this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len));
            case 8:
              throw new Error("Unsupported RIFF format: RIFF/".concat(type));
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parseRiffChunk(_x) {
        return _parseRiffChunk.apply(this, arguments);
      }
      return parseRiffChunk;
    }()
  }, {
    key: "readWaveChunk",
    value: function () {
      var _readWaveChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(remaining) {
        var _this = this;
        var _loop;
        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var header, fmt, subFormat, id3_data, rst, chunkSize, calcRemaining, numberOfSamples, bext, bextRemaining;
                return _regeneratorRuntime().wrap(function _loop$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return _this.tokenizer.readToken(riff.Header);
                    case 2:
                      header = _context3.sent;
                      remaining -= riff.Header.len + header.chunkSize;
                      if (header.chunkSize > remaining) {
                        _this.metadata.addWarning('Data chunk size exceeds file size');
                      }
                      _this.header = header;
                      debug("pos=".concat(_this.tokenizer.position, ", readChunk: chunkID=RIFF/WAVE/").concat(header.chunkID));
                      _context3.t0 = header.chunkID;
                      _context3.next = _context3.t0 === 'LIST' ? 10 : _context3.t0 === 'fact' ? 13 : _context3.t0 === 'fmt ' ? 18 : _context3.t0 === 'id3 ' ? 30 : _context3.t0 === 'ID3 ' ? 30 : _context3.t0 === 'data' ? 37 : _context3.t0 === 'bext' ? 46 : _context3.t0 === '\x00\x00\x00\x00' ? 54 : 59;
                      break;
                    case 10:
                      _context3.next = 12;
                      return _this.parseListTag(header);
                    case 12:
                      return _context3.abrupt("break", 63);
                    case 13:
                      // extended Format chunk,
                      _this.metadata.setFormat('lossless', false);
                      _context3.next = 16;
                      return _this.tokenizer.readToken(new WaveChunk.FactChunk(header));
                    case 16:
                      _this.fact = _context3.sent;
                      return _context3.abrupt("break", 63);
                    case 18:
                      _context3.next = 20;
                      return _this.tokenizer.readToken(new WaveChunk.Format(header));
                    case 20:
                      fmt = _context3.sent;
                      subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];
                      if (!subFormat) {
                        debug('WAVE/non-PCM format=' + fmt.wFormatTag);
                        subFormat = 'non-PCM (' + fmt.wFormatTag + ')';
                      }
                      _this.metadata.setFormat('codec', subFormat);
                      _this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);
                      _this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);
                      _this.metadata.setFormat('numberOfChannels', fmt.nChannels);
                      _this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);
                      _this.blockAlign = fmt.nBlockAlign;
                      return _context3.abrupt("break", 63);
                    case 30:
                      _context3.next = 32;
                      return _this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));
                    case 32:
                      id3_data = _context3.sent;
                      rst = strtok3.fromBuffer(id3_data);
                      _context3.next = 36;
                      return new ID3v2Parser_1.ID3v2Parser().parse(_this.metadata, rst, _this.options);
                    case 36:
                      return _context3.abrupt("break", 63);
                    case 37:
                      // PCM-data
                      if (_this.metadata.format.lossless !== false) {
                        _this.metadata.setFormat('lossless', true);
                      }
                      chunkSize = header.chunkSize;
                      if (_this.tokenizer.fileInfo.size) {
                        calcRemaining = _this.tokenizer.fileInfo.size - _this.tokenizer.position;
                        if (calcRemaining < chunkSize) {
                          _this.metadata.addWarning('data chunk length exceeding file length');
                          chunkSize = calcRemaining;
                        }
                      }
                      numberOfSamples = _this.fact ? _this.fact.dwSampleLength : chunkSize === 0xffffffff ? undefined : chunkSize / _this.blockAlign;
                      if (numberOfSamples) {
                        _this.metadata.setFormat('numberOfSamples', numberOfSamples);
                        _this.metadata.setFormat('duration', numberOfSamples / _this.metadata.format.sampleRate);
                      }
                      if (_this.metadata.format.codec === 'ADPCM') {
                        // ADPCM is 4 bits lossy encoding resulting in 352kbps
                        _this.metadata.setFormat('bitrate', 352000);
                      } else {
                        _this.metadata.setFormat('bitrate', _this.blockAlign * _this.metadata.format.sampleRate * 8);
                      }
                      _context3.next = 45;
                      return _this.tokenizer.ignore(header.chunkSize);
                    case 45:
                      return _context3.abrupt("break", 63);
                    case 46:
                      _context3.next = 48;
                      return _this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);
                    case 48:
                      bext = _context3.sent;
                      Object.keys(bext).forEach(function (key) {
                        _this.metadata.addTag('exif', 'bext.' + key, bext[key]);
                      });
                      bextRemaining = header.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;
                      _context3.next = 53;
                      return _this.tokenizer.ignore(bextRemaining);
                    case 53:
                      return _context3.abrupt("break", 63);
                    case 54:
                      // padding ??
                      debug("Ignore padding chunk: RIFF/".concat(header.chunkID, " of ").concat(header.chunkSize, " bytes"));
                      _this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);
                      _context3.next = 58;
                      return _this.tokenizer.ignore(header.chunkSize);
                    case 58:
                      return _context3.abrupt("break", 63);
                    case 59:
                      debug("Ignore chunk: RIFF/".concat(header.chunkID, " of ").concat(header.chunkSize, " bytes"));
                      _this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);
                      _context3.next = 63;
                      return _this.tokenizer.ignore(header.chunkSize);
                    case 63:
                      if (!(_this.header.chunkSize % 2 === 1)) {
                        _context3.next = 67;
                        break;
                      }
                      debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF
                      _context3.next = 67;
                      return _this.tokenizer.ignore(1);
                    case 67:
                    case "end":
                      return _context3.stop();
                  }
                }, _loop);
              });
            case 1:
              if (!(remaining >= riff.Header.len)) {
                _context4.next = 5;
                break;
              }
              return _context4.delegateYield(_loop(), "t0", 3);
            case 3:
              _context4.next = 1;
              break;
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee3);
      }));
      function readWaveChunk(_x2) {
        return _readWaveChunk.apply(this, arguments);
      }
      return readWaveChunk;
    }()
  }, {
    key: "parseListTag",
    value: function () {
      var _parseListTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(listHeader) {
        var listType;
        return _regeneratorRuntime().wrap(function _callee4$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.tokenizer.readToken(new Token.StringType(4, 'binary'));
            case 2:
              listType = _context5.sent;
              debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);
              _context5.t0 = listType;
              _context5.next = _context5.t0 === 'INFO' ? 7 : _context5.t0 === 'adtl' ? 8 : 8;
              break;
            case 7:
              return _context5.abrupt("return", this.parseRiffInfoTags(listHeader.chunkSize - 4));
            case 8:
              this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);
              debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);
              return _context5.abrupt("return", this.tokenizer.ignore(listHeader.chunkSize - 4).then());
            case 11:
            case "end":
              return _context5.stop();
          }
        }, _callee4, this);
      }));
      function parseListTag(_x3) {
        return _parseListTag.apply(this, arguments);
      }
      return parseListTag;
    }()
  }, {
    key: "parseRiffInfoTags",
    value: function () {
      var _parseRiffInfoTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(chunkSize) {
        var header, valueToken, value;
        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (!(chunkSize >= 8)) {
                _context6.next = 12;
                break;
              }
              _context6.next = 3;
              return this.tokenizer.readToken(riff.Header);
            case 3:
              header = _context6.sent;
              valueToken = new riff.ListInfoTagValue(header);
              _context6.next = 7;
              return this.tokenizer.readToken(valueToken);
            case 7:
              value = _context6.sent;
              this.addTag(header.chunkID, util.stripNulls(value));
              chunkSize -= 8 + valueToken.len;
              _context6.next = 0;
              break;
            case 12:
              if (!(chunkSize !== 0)) {
                _context6.next = 14;
                break;
              }
              throw Error('Illegal remaining size: ' + chunkSize);
            case 14:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this);
      }));
      function parseRiffInfoTags(_x4) {
        return _parseRiffInfoTags.apply(this, arguments);
      }
      return parseRiffInfoTags;
    }()
  }, {
    key: "addTag",
    value: function addTag(id, value) {
      this.metadata.addTag('exif', id, value);
    }
  }]);
  return WaveParser;
}(BasicParser_1.BasicParser);
exports.WaveParser = WaveParser;
},{"strtok3/lib/core":"node_modules/strtok3/lib/core.js","token-types":"node_modules/token-types/lib/index.js","debug":"node_modules/debug/src/browser.js","../riff/RiffChunk":"node_modules/music-metadata/lib/riff/RiffChunk.js","./../wav/WaveChunk":"node_modules/music-metadata/lib/wav/WaveChunk.js","../id3v2/ID3v2Parser":"node_modules/music-metadata/lib/id3v2/ID3v2Parser.js","../common/Util":"node_modules/music-metadata/lib/common/Util.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","../wav/BwfChunk":"node_modules/music-metadata/lib/wav/BwfChunk.js"}],"node_modules/music-metadata/lib/wavpack/WavPackToken.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WavPack = void 0;
var Token = require("token-types");
var FourCC_1 = require("../common/FourCC");
var SampleRates = [6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 64000, 88200, 96000, 192000, -1];
var WavPack = /*#__PURE__*/function () {
  function WavPack() {
    _classCallCheck(this, WavPack);
  }
  _createClass(WavPack, null, [{
    key: "isBitSet",
    value: function isBitSet(flags, bitOffset) {
      return WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;
    }
  }, {
    key: "getBitAllignedNumber",
    value: function getBitAllignedNumber(flags, bitOffset, len) {
      return flags >>> bitOffset & 0xffffffff >>> 32 - len;
    }
  }]);
  return WavPack;
}();
/**
 * WavPack Block Header
 *
 * 32-byte little-endian header at the front of every WavPack block
 *
 * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 2/6: 2.0 "Block Header")
 */
WavPack.BlockHeaderToken = {
  len: 32,
  get: function get(buf, off) {
    var flags = Token.UINT32_LE.get(buf, off + 24);
    var res = {
      // should equal 'wvpk'
      BlockID: FourCC_1.FourCcToken.get(buf, off),
      //  0x402 to 0x410 are valid for decode
      blockSize: Token.UINT32_LE.get(buf, off + 4),
      //  0x402 (1026) to 0x410 are valid for decode
      version: Token.UINT16_LE.get(buf, off + 8),
      //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
      totalSamples: /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */Token.UINT32_LE.get(buf, off + 12),
      // 40-bit block_index
      blockIndex: /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */Token.UINT32_LE.get(buf, off + 16),
      // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
      blockSamples: Token.UINT32_LE.get(buf, off + 20),
      // various flags for id and decoding
      flags: {
        bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,
        isMono: WavPack.isBitSet(flags, 2),
        isHybrid: WavPack.isBitSet(flags, 3),
        isJointStereo: WavPack.isBitSet(flags, 4),
        crossChannel: WavPack.isBitSet(flags, 5),
        hybridNoiseShaping: WavPack.isBitSet(flags, 6),
        floatingPoint: WavPack.isBitSet(flags, 7),
        samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],
        isDSD: WavPack.isBitSet(flags, 31)
      },
      // crc for actual decoded data
      crc: new Token.Uint8ArrayType(4).get(buf, off + 28)
    };
    if (res.flags.isDSD) {
      res.totalSamples *= 8;
    }
    return res;
  }
};
/**
 * 3.0 Metadata Sub-Blocks
 * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 4/6: 3.0 "Metadata Sub-Block")
 */
WavPack.MetadataIdToken = {
  len: 1,
  get: function get(buf, off) {
    return {
      functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),
      isOptional: WavPack.isBitSet(buf[off], 5),
      isOddSize: WavPack.isBitSet(buf[off], 6),
      largeBlock: WavPack.isBitSet(buf[off], 7)
    };
  }
};
exports.WavPack = WavPack;
},{"token-types":"node_modules/token-types/lib/index.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js"}],"node_modules/music-metadata/lib/wavpack/WavPackParser.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WavPackParser = void 0;
var Token = require("token-types");
var APEv2Parser_1 = require("../apev2/APEv2Parser");
var FourCC_1 = require("../common/FourCC");
var BasicParser_1 = require("../common/BasicParser");
var WavPackToken_1 = require("./WavPackToken");
var debug_1 = require("debug");
var debug = (0, debug_1.default)('music-metadata:parser:WavPack');
/**
 * WavPack Parser
 */
var WavPackParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(WavPackParser, _BasicParser_1$BasicP);
  var _super = _createSuper(WavPackParser);
  function WavPackParser() {
    _classCallCheck(this, WavPackParser);
    return _super.apply(this, arguments);
  }
  _createClass(WavPackParser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.audioDataSize = 0;
              // First parse all WavPack blocks
              _context.next = 3;
              return this.parseWavPackBlocks();
            case 3:
              return _context.abrupt("return", APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "parseWavPackBlocks",
    value: function () {
      var _parseWavPackBlocks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var blockId, header, ignoreBytes;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.tokenizer.peekToken(FourCC_1.FourCcToken);
            case 2:
              blockId = _context2.sent;
              if (!(blockId !== 'wvpk')) {
                _context2.next = 5;
                break;
              }
              return _context2.abrupt("break", 17);
            case 5:
              _context2.next = 7;
              return this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);
            case 7:
              header = _context2.sent;
              if (!(header.BlockID !== 'wvpk')) {
                _context2.next = 10;
                break;
              }
              throw new Error('Invalid WavPack Block-ID');
            case 10:
              debug("WavPack header blockIndex=".concat(header.blockIndex, ", len=").concat(WavPackToken_1.WavPack.BlockHeaderToken.len));
              if (header.blockIndex === 0 && !this.metadata.format.container) {
                this.metadata.setFormat('container', 'WavPack');
                this.metadata.setFormat('lossless', !header.flags.isHybrid);
                // tagTypes: this.type,
                this.metadata.setFormat('bitsPerSample', header.flags.bitsPerSample);
                if (!header.flags.isDSD) {
                  // In case isDSD, these values will ne set in ID_DSD_BLOCK
                  this.metadata.setFormat('sampleRate', header.flags.samplingRate);
                  this.metadata.setFormat('duration', header.totalSamples / header.flags.samplingRate);
                }
                this.metadata.setFormat('numberOfChannels', header.flags.isMono ? 1 : 2);
                this.metadata.setFormat('numberOfSamples', header.totalSamples);
                this.metadata.setFormat('codec', header.flags.isDSD ? 'DSD' : 'PCM');
              }
              ignoreBytes = header.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);
              _context2.next = 15;
              return header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes);
            case 15:
              if (header.blockSamples > 0) {
                this.audioDataSize += header.blockSize; // Count audio data for bit-rate calculation
              }
            case 16:
              if (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len) {
                _context2.next = 0;
                break;
              }
            case 17:
              this.metadata.setFormat('bitrate', this.audioDataSize * 8 / this.metadata.format.duration);
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parseWavPackBlocks() {
        return _parseWavPackBlocks.apply(this, arguments);
      }
      return parseWavPackBlocks;
    }()
    /**
     * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
     * @param remainingLength
     */
  }, {
    key: "parseMetadataSubBlock",
    value: function () {
      var _parseMetadataSubBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(header, remainingLength) {
        var id, dataSizeInWords, data, mp, samplingRate;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(remainingLength > WavPackToken_1.WavPack.MetadataIdToken.len)) {
                _context3.next = 36;
                break;
              }
              _context3.next = 3;
              return this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken);
            case 3:
              id = _context3.sent;
              _context3.next = 6;
              return this.tokenizer.readNumber(id.largeBlock ? Token.UINT24_LE : Token.UINT8);
            case 6:
              dataSizeInWords = _context3.sent;
              data = Buffer.alloc(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));
              _context3.next = 10;
              return this.tokenizer.readBuffer(data);
            case 10:
              debug("Metadata Sub-Blocks functionId=0x".concat(id.functionId.toString(16), ", id.largeBlock=").concat(id.largeBlock, ",data-size=").concat(data.length));
              _context3.t0 = id.functionId;
              _context3.next = _context3.t0 === 0x0 ? 14 : _context3.t0 === 0xe ? 15 : _context3.t0 === 0x24 ? 23 : _context3.t0 === 0x26 ? 25 : _context3.t0 === 0x2f ? 27 : 29;
              break;
            case 14:
              return _context3.abrupt("break", 31);
            case 15:
              // ID_DSD_BLOCK
              debug('ID_DSD_BLOCK');
              // https://github.com/dbry/WavPack/issues/71#issuecomment-483094813
              mp = 1 << data.readUInt8(0);
              samplingRate = header.flags.samplingRate * mp * 8; // ToDo: second factor should be read from DSD-metadata block https://github.com/dbry/WavPack/issues/71#issuecomment-483094813
              if (header.flags.isDSD) {
                _context3.next = 20;
                break;
              }
              throw new Error('Only expect DSD block if DSD-flag is set');
            case 20:
              this.metadata.setFormat('sampleRate', samplingRate);
              this.metadata.setFormat('duration', header.totalSamples / samplingRate);
              return _context3.abrupt("break", 31);
            case 23:
              // ID_ALT_TRAILER: maybe used to embed original ID3 tag header
              debug('ID_ALT_TRAILER: trailer for non-wav files');
              return _context3.abrupt("break", 31);
            case 25:
              // ID_MD5_CHECKSUM
              this.metadata.setFormat('audioMD5', data);
              return _context3.abrupt("break", 31);
            case 27:
              // ID_BLOCK_CHECKSUM
              debug("ID_BLOCK_CHECKSUM: checksum=".concat(data.toString('hex')));
              return _context3.abrupt("break", 31);
            case 29:
              debug("Ignore unsupported meta-sub-block-id functionId=0x".concat(id.functionId.toString(16)));
              return _context3.abrupt("break", 31);
            case 31:
              remainingLength -= WavPackToken_1.WavPack.MetadataIdToken.len + (id.largeBlock ? Token.UINT24_LE.len : Token.UINT8.len) + dataSizeInWords * 2;
              debug("remainingLength=".concat(remainingLength));
              if (id.isOddSize) this.tokenizer.ignore(1);
              _context3.next = 0;
              break;
            case 36:
              if (!(remainingLength !== 0)) {
                _context3.next = 38;
                break;
              }
              throw new Error('metadata-sub-block should fit it remaining length');
            case 38:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function parseMetadataSubBlock(_x, _x2) {
        return _parseMetadataSubBlock.apply(this, arguments);
      }
      return parseMetadataSubBlock;
    }()
  }]);
  return WavPackParser;
}(BasicParser_1.BasicParser);
exports.WavPackParser = WavPackParser;
},{"token-types":"node_modules/token-types/lib/index.js","../apev2/APEv2Parser":"node_modules/music-metadata/lib/apev2/APEv2Parser.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","./WavPackToken":"node_modules/music-metadata/lib/wavpack/WavPackToken.js","debug":"node_modules/debug/src/browser.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/dsf/DsfChunk.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormatChunk = exports.ChannelType = exports.DsdChunk = exports.ChunkHeader = void 0;
var Token = require("token-types");
var FourCC_1 = require("../common/FourCC");
/**
 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
 */
exports.ChunkHeader = {
  len: 12,
  get: function get(buf, off) {
    return {
      id: FourCC_1.FourCcToken.get(buf, off),
      size: Token.UINT64_LE.get(buf, off + 4)
    };
  }
};
/**
 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
 */
exports.DsdChunk = {
  len: 16,
  get: function get(buf, off) {
    return {
      fileSize: Token.INT64_LE.get(buf, off),
      metadataPointer: Token.INT64_LE.get(buf, off + 8)
    };
  }
};
var ChannelType;
(function (ChannelType) {
  ChannelType[ChannelType["mono"] = 1] = "mono";
  ChannelType[ChannelType["stereo"] = 2] = "stereo";
  ChannelType[ChannelType["channels"] = 3] = "channels";
  ChannelType[ChannelType["quad"] = 4] = "quad";
  ChannelType[ChannelType["4 channels"] = 5] = "4 channels";
  ChannelType[ChannelType["5 channels"] = 6] = "5 channels";
  ChannelType[ChannelType["5.1 channels"] = 7] = "5.1 channels";
})(ChannelType = exports.ChannelType || (exports.ChannelType = {}));
/**
 * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size
 */
exports.FormatChunk = {
  len: 40,
  get: function get(buf, off) {
    return {
      formatVersion: Token.INT32_LE.get(buf, off),
      formatID: Token.INT32_LE.get(buf, off + 4),
      channelType: Token.INT32_LE.get(buf, off + 8),
      channelNum: Token.INT32_LE.get(buf, off + 12),
      samplingFrequency: Token.INT32_LE.get(buf, off + 16),
      bitsPerSample: Token.INT32_LE.get(buf, off + 20),
      sampleCount: Token.INT64_LE.get(buf, off + 24),
      blockSizePerChannel: Token.INT32_LE.get(buf, off + 32)
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js"}],"node_modules/music-metadata/lib/dsf/DsfParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DsfParser = void 0;
var debug_1 = require("debug");
var AbstractID3Parser_1 = require("../id3v2/AbstractID3Parser");
var DsfChunk_1 = require("./DsfChunk");
var ID3v2Parser_1 = require("../id3v2/ID3v2Parser");
var debug = (0, debug_1.default)('music-metadata:parser:DSF');
/**
 * DSF (dsd stream file) File Parser
 * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf
 */
var DsfParser = /*#__PURE__*/function (_AbstractID3Parser_1$) {
  _inherits(DsfParser, _AbstractID3Parser_1$);
  var _super = _createSuper(DsfParser);
  function DsfParser() {
    _classCallCheck(this, DsfParser);
    return _super.apply(this, arguments);
  }
  _createClass(DsfParser, [{
    key: "postId3v2Parse",
    value: function () {
      var _postId3v2Parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var p0, chunkHeader, dsdChunk;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              p0 = this.tokenizer.position; // mark start position, normally 0
              _context.next = 3;
              return this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
            case 3:
              chunkHeader = _context.sent;
              if (!(chunkHeader.id !== 'DSD ')) {
                _context.next = 6;
                break;
              }
              throw new Error('Invalid chunk signature');
            case 6:
              this.metadata.setFormat('container', 'DSF');
              this.metadata.setFormat('lossless', true);
              _context.next = 10;
              return this.tokenizer.readToken(DsfChunk_1.DsdChunk);
            case 10:
              dsdChunk = _context.sent;
              if (!(dsdChunk.metadataPointer === BigInt(0))) {
                _context.next = 15;
                break;
              }
              debug("No ID3v2 tag present");
              _context.next = 21;
              break;
            case 15:
              debug("expect ID3v2 at offset=".concat(dsdChunk.metadataPointer));
              _context.next = 18;
              return this.parseChunks(dsdChunk.fileSize - chunkHeader.size);
            case 18:
              _context.next = 20;
              return this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);
            case 20:
              return _context.abrupt("return", new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options));
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function postId3v2Parse() {
        return _postId3v2Parse.apply(this, arguments);
      }
      return postId3v2Parse;
    }()
  }, {
    key: "parseChunks",
    value: function () {
      var _parseChunks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(bytesRemaining) {
        var chunkHeader, formatChunk, bitrate;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(bytesRemaining >= DsfChunk_1.ChunkHeader.len)) {
                _context2.next = 24;
                break;
              }
              _context2.next = 3;
              return this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
            case 3:
              chunkHeader = _context2.sent;
              debug("Parsing chunk name=".concat(chunkHeader.id, " size=").concat(chunkHeader.size));
              _context2.t0 = chunkHeader.id;
              _context2.next = _context2.t0 === 'fmt ' ? 8 : 19;
              break;
            case 8:
              _context2.next = 10;
              return this.tokenizer.readToken(DsfChunk_1.FormatChunk);
            case 10:
              formatChunk = _context2.sent;
              this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);
              this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);
              this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);
              this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);
              this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);
              bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
              this.metadata.setFormat('bitrate', bitrate);
              return _context2.abrupt("return");
            case 19:
              this.tokenizer.ignore(Number(chunkHeader.size) - DsfChunk_1.ChunkHeader.len);
              return _context2.abrupt("break", 21);
            case 21:
              bytesRemaining -= chunkHeader.size;
              _context2.next = 0;
              break;
            case 24:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parseChunks(_x) {
        return _parseChunks.apply(this, arguments);
      }
      return parseChunks;
    }()
  }]);
  return DsfParser;
}(AbstractID3Parser_1.AbstractID3Parser);
exports.DsfParser = DsfParser;
},{"debug":"node_modules/debug/src/browser.js","../id3v2/AbstractID3Parser":"node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","./DsfChunk":"node_modules/music-metadata/lib/dsf/DsfChunk.js","../id3v2/ID3v2Parser":"node_modules/music-metadata/lib/id3v2/ID3v2Parser.js"}],"node_modules/music-metadata/lib/dsdiff/DsdiffToken.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChunkHeader64 = void 0;
var Token = require("token-types");
var FourCC_1 = require("../common/FourCC");
/**
 * DSDIFF chunk header
 * The data-size encoding is deviating from EA-IFF 85
 * Ref: http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf
 */
exports.ChunkHeader64 = {
  len: 12,
  get: function get(buf, off) {
    return {
      // Group-ID
      chunkID: FourCC_1.FourCcToken.get(buf, off),
      // Size
      chunkSize: Token.INT64_BE.get(buf, off + 4)
    };
  }
};
},{"token-types":"node_modules/token-types/lib/index.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js"}],"node_modules/music-metadata/lib/dsdiff/DsdiffParser.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DsdiffParser = void 0;
var Token = require("token-types");
var debug_1 = require("debug");
var strtok3 = require("strtok3/lib/core");
var FourCC_1 = require("../common/FourCC");
var BasicParser_1 = require("../common/BasicParser");
var ID3v2Parser_1 = require("../id3v2/ID3v2Parser");
var DsdiffToken_1 = require("./DsdiffToken");
var debug = (0, debug_1.default)('music-metadata:parser:aiff');
/**
 * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)
 *
 * Ref:
 * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf
 */
var DsdiffParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(DsdiffParser, _BasicParser_1$BasicP);
  var _super = _createSuper(DsdiffParser);
  function DsdiffParser() {
    _classCallCheck(this, DsdiffParser);
    return _super.apply(this, arguments);
  }
  _createClass(DsdiffParser, [{
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var header, type;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
            case 2:
              header = _context.sent;
              if (!(header.chunkID !== 'FRM8')) {
                _context.next = 5;
                break;
              }
              throw new Error('Unexpected chunk-ID');
            case 5:
              _context.next = 7;
              return this.tokenizer.readToken(FourCC_1.FourCcToken);
            case 7:
              type = _context.sent.trim();
              _context.t0 = type;
              _context.next = _context.t0 === 'DSD' ? 11 : 14;
              break;
            case 11:
              this.metadata.setFormat('container', "DSDIFF/".concat(type));
              this.metadata.setFormat('lossless', true);
              return _context.abrupt("return", this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len)));
            case 14:
              throw Error("Unsupported DSDIFF type: ".concat(type));
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "readFmt8Chunks",
    value: function () {
      var _readFmt8Chunks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(remainingSize) {
        var chunkHeader;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(remainingSize >= DsdiffToken_1.ChunkHeader64.len)) {
                _context2.next = 10;
                break;
              }
              _context2.next = 3;
              return this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
            case 3:
              chunkHeader = _context2.sent;
              //  If the data is an odd number of bytes in length, a pad byte must be added at the end
              debug("Chunk id=".concat(chunkHeader.chunkID));
              _context2.next = 7;
              return this.readData(chunkHeader);
            case 7:
              remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize;
              _context2.next = 0;
              break;
            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function readFmt8Chunks(_x) {
        return _readFmt8Chunks.apply(this, arguments);
      }
      return readFmt8Chunks;
    }()
  }, {
    key: "readData",
    value: function () {
      var _readData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(header) {
        var p0, version, propType, id3_data, rst, remaining;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              debug("Reading data of chunk[ID=".concat(header.chunkID, ", size=").concat(header.chunkSize, "]"));
              p0 = this.tokenizer.position;
              _context3.t0 = header.chunkID.trim();
              _context3.next = _context3.t0 === 'FVER' ? 5 : _context3.t0 === 'PROP' ? 10 : _context3.t0 === 'ID3' ? 18 : _context3.t0 === 'DSD' ? 27 : 25;
              break;
            case 5:
              _context3.next = 7;
              return this.tokenizer.readToken(Token.UINT32_LE);
            case 7:
              version = _context3.sent;
              debug("DSDIFF version=".concat(version));
              return _context3.abrupt("break", 30);
            case 10:
              _context3.next = 12;
              return this.tokenizer.readToken(FourCC_1.FourCcToken);
            case 12:
              propType = _context3.sent;
              if (!(propType !== 'SND ')) {
                _context3.next = 15;
                break;
              }
              throw new Error('Unexpected PROP-chunk ID');
            case 15:
              _context3.next = 17;
              return this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));
            case 17:
              return _context3.abrupt("break", 30);
            case 18:
              _context3.next = 20;
              return this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));
            case 20:
              id3_data = _context3.sent;
              rst = strtok3.fromBuffer(id3_data);
              _context3.next = 24;
              return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
            case 24:
              return _context3.abrupt("break", 30);
            case 25:
              debug("Ignore chunk[ID=".concat(header.chunkID, ", size=").concat(header.chunkSize, "]"));
              return _context3.abrupt("break", 30);
            case 27:
              this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));
              this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
              return _context3.abrupt("break", 30);
            case 30:
              remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);
              if (!(remaining > 0)) {
                _context3.next = 35;
                break;
              }
              debug("After Parsing chunk, remaining ".concat(remaining, " bytes"));
              _context3.next = 35;
              return this.tokenizer.ignore(Number(remaining));
            case 35:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function readData(_x2) {
        return _readData.apply(this, arguments);
      }
      return readData;
    }()
  }, {
    key: "handleSoundPropertyChunks",
    value: function () {
      var _handleSoundPropertyChunks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(remainingSize) {
        var sndPropHeader, p0, sampleRate, numChannels, compressionIdCode, count, compressionName, hours, minutes, seconds, samples, lsConfig, remaining, bitrate;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              debug("Parsing sound-property-chunks, remainingSize=".concat(remainingSize));
            case 1:
              if (!(remainingSize > 0)) {
                _context4.next = 65;
                break;
              }
              _context4.next = 4;
              return this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
            case 4:
              sndPropHeader = _context4.sent;
              debug("Sound-property-chunk[ID=".concat(sndPropHeader.chunkID, ", size=").concat(sndPropHeader.chunkSize, "]"));
              p0 = this.tokenizer.position;
              _context4.t0 = sndPropHeader.chunkID.trim();
              _context4.next = _context4.t0 === 'FS' ? 10 : _context4.t0 === 'CHNL' ? 15 : _context4.t0 === 'CMPR' ? 22 : _context4.t0 === 'ABSS' ? 34 : _context4.t0 === 'LSCO' ? 48 : _context4.t0 === 'COMT' ? 53 : 53;
              break;
            case 10:
              _context4.next = 12;
              return this.tokenizer.readToken(Token.UINT32_BE);
            case 12:
              sampleRate = _context4.sent;
              this.metadata.setFormat('sampleRate', sampleRate);
              return _context4.abrupt("break", 56);
            case 15:
              _context4.next = 17;
              return this.tokenizer.readToken(Token.UINT16_BE);
            case 17:
              numChannels = _context4.sent;
              this.metadata.setFormat('numberOfChannels', numChannels);
              _context4.next = 21;
              return this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));
            case 21:
              return _context4.abrupt("break", 56);
            case 22:
              _context4.next = 24;
              return this.tokenizer.readToken(FourCC_1.FourCcToken);
            case 24:
              compressionIdCode = _context4.sent.trim();
              _context4.next = 27;
              return this.tokenizer.readToken(Token.UINT8);
            case 27:
              count = _context4.sent;
              _context4.next = 30;
              return this.tokenizer.readToken(new Token.StringType(count, 'ascii'));
            case 30:
              compressionName = _context4.sent;
              if (compressionIdCode === 'DSD') {
                this.metadata.setFormat('lossless', true);
                this.metadata.setFormat('bitsPerSample', 1);
              }
              this.metadata.setFormat('codec', "".concat(compressionIdCode, " (").concat(compressionName, ")"));
              return _context4.abrupt("break", 56);
            case 34:
              _context4.next = 36;
              return this.tokenizer.readToken(Token.UINT16_BE);
            case 36:
              hours = _context4.sent;
              _context4.next = 39;
              return this.tokenizer.readToken(Token.UINT8);
            case 39:
              minutes = _context4.sent;
              _context4.next = 42;
              return this.tokenizer.readToken(Token.UINT8);
            case 42:
              seconds = _context4.sent;
              _context4.next = 45;
              return this.tokenizer.readToken(Token.UINT32_BE);
            case 45:
              samples = _context4.sent;
              debug("ABSS ".concat(hours, ":").concat(minutes, ":").concat(seconds, ".").concat(samples));
              return _context4.abrupt("break", 56);
            case 48:
              _context4.next = 50;
              return this.tokenizer.readToken(Token.UINT16_BE);
            case 50:
              lsConfig = _context4.sent;
              debug("LSCO lsConfig=".concat(lsConfig));
              return _context4.abrupt("break", 56);
            case 53:
              debug("Unknown sound-property-chunk[ID=".concat(sndPropHeader.chunkID, ", size=").concat(sndPropHeader.chunkSize, "]"));
              _context4.next = 56;
              return this.tokenizer.ignore(Number(sndPropHeader.chunkSize));
            case 56:
              remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);
              if (!(remaining > 0)) {
                _context4.next = 61;
                break;
              }
              debug("After Parsing sound-property-chunk ".concat(sndPropHeader.chunkSize, ", remaining ").concat(remaining, " bytes"));
              _context4.next = 61;
              return this.tokenizer.ignore(Number(remaining));
            case 61:
              remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize;
              debug("Parsing sound-property-chunks, remainingSize=".concat(remainingSize));
              _context4.next = 1;
              break;
            case 65:
              if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
                bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
                this.metadata.setFormat('bitrate', bitrate);
              }
            case 66:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function handleSoundPropertyChunks(_x3) {
        return _handleSoundPropertyChunks.apply(this, arguments);
      }
      return handleSoundPropertyChunks;
    }()
  }, {
    key: "handleChannelChunks",
    value: function () {
      var _handleChannelChunks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(remainingSize) {
        var channels, channelId;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              debug("Parsing channel-chunks, remainingSize=".concat(remainingSize));
              channels = [];
            case 2:
              if (!(remainingSize >= FourCC_1.FourCcToken.len)) {
                _context5.next = 11;
                break;
              }
              _context5.next = 5;
              return this.tokenizer.readToken(FourCC_1.FourCcToken);
            case 5:
              channelId = _context5.sent;
              debug("Channel[ID=".concat(channelId, "]"));
              channels.push(channelId);
              remainingSize -= BigInt(FourCC_1.FourCcToken.len);
              _context5.next = 2;
              break;
            case 11:
              debug("Channels: ".concat(channels.join(', ')));
              return _context5.abrupt("return", channels);
            case 13:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function handleChannelChunks(_x4) {
        return _handleChannelChunks.apply(this, arguments);
      }
      return handleChannelChunks;
    }()
  }]);
  return DsdiffParser;
}(BasicParser_1.BasicParser);
exports.DsdiffParser = DsdiffParser;
},{"token-types":"node_modules/token-types/lib/index.js","debug":"node_modules/debug/src/browser.js","strtok3/lib/core":"node_modules/strtok3/lib/core.js","../common/FourCC":"node_modules/music-metadata/lib/common/FourCC.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","../id3v2/ID3v2Parser":"node_modules/music-metadata/lib/id3v2/ID3v2Parser.js","./DsdiffToken":"node_modules/music-metadata/lib/dsdiff/DsdiffToken.js"}],"node_modules/music-metadata/lib/matroska/MatroskaDtd.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.elements = void 0;
var types_1 = require("./types");
/**
 * Elements of document type description
 * Derived from https://github.com/tungol/EBML/blob/master/doctypes/matroska.dtd
 * Extended with:
 * - https://www.matroska.org/technical/specs/index.html
 */
exports.elements = {
  0x1a45dfa3: {
    name: 'ebml',
    container: {
      0x4286: {
        name: 'ebmlVersion',
        value: types_1.DataType.uint
      },
      0x42f7: {
        name: 'ebmlReadVersion',
        value: types_1.DataType.uint
      },
      0x42f2: {
        name: 'ebmlMaxIDWidth',
        value: types_1.DataType.uint
      },
      0x42f3: {
        name: 'ebmlMaxSizeWidth',
        value: types_1.DataType.uint
      },
      0x4282: {
        name: 'docType',
        value: types_1.DataType.string
      },
      0x4287: {
        name: 'docTypeVersion',
        value: types_1.DataType.uint
      },
      0x4285: {
        name: 'docTypeReadVersion',
        value: types_1.DataType.uint
      } // 5.1.7
    }
  },

  // Matroska segments
  0x18538067: {
    name: 'segment',
    container: {
      // Meta Seek Information
      0x114d9b74: {
        name: 'seekHead',
        container: {
          0x4dbb: {
            name: 'seek',
            container: {
              0x53ab: {
                name: 'seekId',
                value: types_1.DataType.binary
              },
              0x53ac: {
                name: 'seekPosition',
                value: types_1.DataType.uint
              }
            }
          }
        }
      },
      // Segment Information
      0x1549a966: {
        name: 'info',
        container: {
          0x73a4: {
            name: 'uid',
            value: types_1.DataType.uid
          },
          0x7384: {
            name: 'filename',
            value: types_1.DataType.string
          },
          0x3cb923: {
            name: 'prevUID',
            value: types_1.DataType.uid
          },
          0x3c83ab: {
            name: 'prevFilename',
            value: types_1.DataType.string
          },
          0x3eb923: {
            name: 'nextUID',
            value: types_1.DataType.uid
          },
          0x3e83bb: {
            name: 'nextFilename',
            value: types_1.DataType.string
          },
          0x2ad7b1: {
            name: 'timecodeScale',
            value: types_1.DataType.uint
          },
          0x4489: {
            name: 'duration',
            value: types_1.DataType.float
          },
          0x4461: {
            name: 'dateUTC',
            value: types_1.DataType.uint
          },
          0x7ba9: {
            name: 'title',
            value: types_1.DataType.string
          },
          0x4d80: {
            name: 'muxingApp',
            value: types_1.DataType.string
          },
          0x5741: {
            name: 'writingApp',
            value: types_1.DataType.string
          }
        }
      },
      // Cluster
      0x1f43b675: {
        name: 'cluster',
        multiple: true,
        container: {
          0xe7: {
            name: 'timecode',
            value: types_1.DataType.uid
          },
          0xa3: {
            name: 'unknown',
            value: types_1.DataType.binary
          },
          0xa7: {
            name: 'position',
            value: types_1.DataType.uid
          },
          0xab: {
            name: 'prevSize',
            value: types_1.DataType.uid
          }
        }
      },
      // Track
      0x1654ae6b: {
        name: 'tracks',
        container: {
          0xae: {
            name: 'entries',
            multiple: true,
            container: {
              0xd7: {
                name: 'trackNumber',
                value: types_1.DataType.uint
              },
              0x73c5: {
                name: 'uid',
                value: types_1.DataType.uid
              },
              0x83: {
                name: 'trackType',
                value: types_1.DataType.uint
              },
              0xb9: {
                name: 'flagEnabled',
                value: types_1.DataType.bool
              },
              0x88: {
                name: 'flagDefault',
                value: types_1.DataType.bool
              },
              0x55aa: {
                name: 'flagForced',
                value: types_1.DataType.bool
              },
              0x9c: {
                name: 'flagLacing',
                value: types_1.DataType.bool
              },
              0x6de7: {
                name: 'minCache',
                value: types_1.DataType.uint
              },
              0x6de8: {
                name: 'maxCache',
                value: types_1.DataType.uint
              },
              0x23e383: {
                name: 'defaultDuration',
                value: types_1.DataType.uint
              },
              0x23314f: {
                name: 'timecodeScale',
                value: types_1.DataType.float
              },
              0x536e: {
                name: 'name',
                value: types_1.DataType.string
              },
              0x22b59c: {
                name: 'language',
                value: types_1.DataType.string
              },
              0x86: {
                name: 'codecID',
                value: types_1.DataType.string
              },
              0x63a2: {
                name: 'codecPrivate',
                value: types_1.DataType.binary
              },
              0x258688: {
                name: 'codecName',
                value: types_1.DataType.string
              },
              0x3a9697: {
                name: 'codecSettings',
                value: types_1.DataType.string
              },
              0x3b4040: {
                name: 'codecInfoUrl',
                value: types_1.DataType.string
              },
              0x26b240: {
                name: 'codecDownloadUrl',
                value: types_1.DataType.string
              },
              0xaa: {
                name: 'codecDecodeAll',
                value: types_1.DataType.bool
              },
              0x6fab: {
                name: 'trackOverlay',
                value: types_1.DataType.uint
              },
              // Video
              0xe0: {
                name: 'video',
                container: {
                  0x9a: {
                    name: 'flagInterlaced',
                    value: types_1.DataType.bool
                  },
                  0x53b8: {
                    name: 'stereoMode',
                    value: types_1.DataType.uint
                  },
                  0xb0: {
                    name: 'pixelWidth',
                    value: types_1.DataType.uint
                  },
                  0xba: {
                    name: 'pixelHeight',
                    value: types_1.DataType.uint
                  },
                  0x54b0: {
                    name: 'displayWidth',
                    value: types_1.DataType.uint
                  },
                  0x54ba: {
                    name: 'displayHeight',
                    value: types_1.DataType.uint
                  },
                  0x54b3: {
                    name: 'aspectRatioType',
                    value: types_1.DataType.uint
                  },
                  0x2eb524: {
                    name: 'colourSpace',
                    value: types_1.DataType.uint
                  },
                  0x2fb523: {
                    name: 'gammaValue',
                    value: types_1.DataType.float
                  }
                }
              },
              // Audio
              0xe1: {
                name: 'audio',
                container: {
                  0xb5: {
                    name: 'samplingFrequency',
                    value: types_1.DataType.float
                  },
                  0x78b5: {
                    name: 'outputSamplingFrequency',
                    value: types_1.DataType.float
                  },
                  0x9f: {
                    name: 'channels',
                    value: types_1.DataType.uint
                  },
                  0x94: {
                    name: 'channels',
                    value: types_1.DataType.uint
                  },
                  0x7d7b: {
                    name: 'channelPositions',
                    value: types_1.DataType.binary
                  },
                  0x6264: {
                    name: 'bitDepth',
                    value: types_1.DataType.uint
                  }
                }
              },
              // Content Encoding
              0x6d80: {
                name: 'contentEncodings',
                container: {
                  0x6240: {
                    name: 'contentEncoding',
                    container: {
                      0x5031: {
                        name: 'order',
                        value: types_1.DataType.uint
                      },
                      0x5032: {
                        name: 'scope',
                        value: types_1.DataType.bool
                      },
                      0x5033: {
                        name: 'type',
                        value: types_1.DataType.uint
                      },
                      0x5034: {
                        name: 'contentEncoding',
                        container: {
                          0x4254: {
                            name: 'contentCompAlgo',
                            value: types_1.DataType.uint
                          },
                          0x4255: {
                            name: 'contentCompSettings',
                            value: types_1.DataType.binary
                          }
                        }
                      },
                      0x5035: {
                        name: 'contentEncoding',
                        container: {
                          0x47e1: {
                            name: 'contentEncAlgo',
                            value: types_1.DataType.uint
                          },
                          0x47e2: {
                            name: 'contentEncKeyID',
                            value: types_1.DataType.binary
                          },
                          0x47e3: {
                            name: 'contentSignature ',
                            value: types_1.DataType.binary
                          },
                          0x47e4: {
                            name: 'ContentSigKeyID  ',
                            value: types_1.DataType.binary
                          },
                          0x47e5: {
                            name: 'contentSigAlgo ',
                            value: types_1.DataType.uint
                          },
                          0x47e6: {
                            name: 'contentSigHashAlgo ',
                            value: types_1.DataType.uint
                          }
                        }
                      },
                      0x6264: {
                        name: 'bitDepth',
                        value: types_1.DataType.uint
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      // Cueing Data
      0x1c53bb6b: {
        name: 'cues',
        container: {
          0xbb: {
            name: 'cuePoint',
            container: {
              0xb3: {
                name: 'cueTime',
                value: types_1.DataType.uid
              },
              0xb7: {
                name: 'positions',
                container: {
                  0xf7: {
                    name: 'track',
                    value: types_1.DataType.uint
                  },
                  0xf1: {
                    name: 'clusterPosition',
                    value: types_1.DataType.uint
                  },
                  0x5378: {
                    name: 'blockNumber',
                    value: types_1.DataType.uint
                  },
                  0xea: {
                    name: 'codecState',
                    value: types_1.DataType.uint
                  },
                  0xdb: {
                    name: 'reference',
                    container: {
                      0x96: {
                        name: 'time',
                        value: types_1.DataType.uint
                      },
                      0x97: {
                        name: 'cluster',
                        value: types_1.DataType.uint
                      },
                      0x535f: {
                        name: 'number',
                        value: types_1.DataType.uint
                      },
                      0xeb: {
                        name: 'codecState',
                        value: types_1.DataType.uint
                      }
                    }
                  },
                  0xf0: {
                    name: 'relativePosition',
                    value: types_1.DataType.uint
                  } // extended
                }
              }
            }
          }
        }
      },

      // Attachment
      0x1941a469: {
        name: 'attachments',
        container: {
          0x61a7: {
            name: 'attachedFiles',
            multiple: true,
            container: {
              0x467e: {
                name: 'description',
                value: types_1.DataType.string
              },
              0x466e: {
                name: 'name',
                value: types_1.DataType.string
              },
              0x4660: {
                name: 'mimeType',
                value: types_1.DataType.string
              },
              0x465c: {
                name: 'data',
                value: types_1.DataType.binary
              },
              0x46ae: {
                name: 'uid',
                value: types_1.DataType.uid
              }
            }
          }
        }
      },
      // Chapters
      0x1043a770: {
        name: 'chapters',
        container: {
          0x45b9: {
            name: 'editionEntry',
            container: {
              0xb6: {
                name: 'chapterAtom',
                container: {
                  0x73c4: {
                    name: 'uid',
                    value: types_1.DataType.uid
                  },
                  0x91: {
                    name: 'timeStart',
                    value: types_1.DataType.uint
                  },
                  0x92: {
                    name: 'timeEnd',
                    value: types_1.DataType.uid
                  },
                  0x98: {
                    name: 'hidden',
                    value: types_1.DataType.bool
                  },
                  0x4598: {
                    name: 'enabled',
                    value: types_1.DataType.uid
                  },
                  0x8f: {
                    name: 'track',
                    container: {
                      0x89: {
                        name: 'trackNumber',
                        value: types_1.DataType.uid
                      },
                      0x80: {
                        name: 'display',
                        container: {
                          0x85: {
                            name: 'string',
                            value: types_1.DataType.string
                          },
                          0x437c: {
                            name: 'language ',
                            value: types_1.DataType.string
                          },
                          0x437e: {
                            name: 'country ',
                            value: types_1.DataType.string
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      // Tagging
      0x1254c367: {
        name: 'tags',
        container: {
          0x7373: {
            name: 'tag',
            multiple: true,
            container: {
              0x63c0: {
                name: 'target',
                container: {
                  0x63c5: {
                    name: 'tagTrackUID',
                    value: types_1.DataType.uid
                  },
                  0x63c4: {
                    name: 'tagChapterUID',
                    value: types_1.DataType.uint
                  },
                  0x63c6: {
                    name: 'tagAttachmentUID',
                    value: types_1.DataType.uid
                  },
                  0x63ca: {
                    name: 'targetType',
                    value: types_1.DataType.string
                  },
                  0x68ca: {
                    name: 'targetTypeValue',
                    value: types_1.DataType.uint
                  },
                  0x63c9: {
                    name: 'tagEditionUID',
                    value: types_1.DataType.uid
                  } // extended
                }
              },

              0x67c8: {
                name: 'simpleTags',
                multiple: true,
                container: {
                  0x45a3: {
                    name: 'name',
                    value: types_1.DataType.string
                  },
                  0x4487: {
                    name: 'string',
                    value: types_1.DataType.string
                  },
                  0x4485: {
                    name: 'binary',
                    value: types_1.DataType.binary
                  },
                  0x447a: {
                    name: 'language',
                    value: types_1.DataType.string
                  },
                  0x447b: {
                    name: 'languageIETF',
                    value: types_1.DataType.string
                  },
                  0x4484: {
                    name: 'default',
                    value: types_1.DataType.bool
                  } // extended
                }
              }
            }
          }
        }
      }
    }
  }
};
},{"./types":"node_modules/music-metadata/lib/matroska/types.js"}],"node_modules/music-metadata/lib/matroska/MatroskaParser.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MatroskaParser = void 0;
var token_types_1 = require("token-types");
var debug_1 = require("debug");
var BasicParser_1 = require("../common/BasicParser");
var types_1 = require("./types");
var matroskaDtd = require("./MatroskaDtd");
var debug = (0, debug_1.default)('music-metadata:parser:matroska');
/**
 * Extensible Binary Meta Language (EBML) parser
 * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language
 * http://matroska.sourceforge.net/technical/specs/rfc/index.html
 *
 * WEBM VP8 AUDIO FILE
 */
var MatroskaParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {
  _inherits(MatroskaParser, _BasicParser_1$BasicP);
  var _super = _createSuper(MatroskaParser);
  function MatroskaParser() {
    var _this;
    _classCallCheck(this, MatroskaParser);
    _this = _super.call(this);
    _this.padding = 0;
    _this.parserMap = new Map();
    _this.ebmlMaxIDLength = 4;
    _this.ebmlMaxSizeLength = 8;
    _this.parserMap.set(types_1.DataType.uint, function (e) {
      return _this.readUint(e);
    });
    _this.parserMap.set(types_1.DataType.string, function (e) {
      return _this.readString(e);
    });
    _this.parserMap.set(types_1.DataType.binary, function (e) {
      return _this.readBuffer(e);
    });
    _this.parserMap.set(types_1.DataType.uid, /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(e) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.readUint(e);
            case 2:
              _context.t0 = _context.sent;
              return _context.abrupt("return", _context.t0 === 1);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    _this.parserMap.set(types_1.DataType.bool, function (e) {
      return _this.readFlag(e);
    });
    _this.parserMap.set(types_1.DataType.float, function (e) {
      return _this.readFloat(e);
    });
    return _this;
  }
  /**
   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
   * @param {INativeMetadataCollector} metadata Output
   * @param {ITokenizer} tokenizer Input
   * @param {IOptions} options Parsing options
   */
  _createClass(MatroskaParser, [{
    key: "init",
    value: function init(metadata, tokenizer, options) {
      _get(_getPrototypeOf(MatroskaParser.prototype), "init", this).call(this, metadata, tokenizer, options);
      return this;
    }
  }, {
    key: "parse",
    value: function () {
      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _this2 = this;
        var matroska, info, timecodeScale, duration, audioTracks, audioTrack;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);
            case 2:
              matroska = _context2.sent;
              this.metadata.setFormat('container', "EBML/".concat(matroska.ebml.docType));
              if (matroska.segment) {
                info = matroska.segment.info;
                if (info) {
                  timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;
                  if (typeof info.duration === 'number') {
                    duration = info.duration * timecodeScale / 1000000000;
                    this.addTag('segment:title', info.title);
                    this.metadata.setFormat('duration', duration);
                  }
                }
                audioTracks = matroska.segment.tracks;
                if (audioTracks && audioTracks.entries) {
                  audioTracks.entries.forEach(function (entry) {
                    var stream = {
                      codecName: entry.codecID.replace('A_', '').replace('V_', ''),
                      codecSettings: entry.codecSettings,
                      flagDefault: entry.flagDefault,
                      flagLacing: entry.flagLacing,
                      flagEnabled: entry.flagEnabled,
                      language: entry.language,
                      name: entry.name,
                      type: entry.trackType,
                      audio: entry.audio,
                      video: entry.video
                    };
                    _this2.metadata.addStreamInfo(stream);
                  });
                  audioTrack = audioTracks.entries.filter(function (entry) {
                    return entry.trackType === types_1.TrackType.audio.valueOf();
                  }).reduce(function (acc, cur) {
                    if (!acc) {
                      return cur;
                    }
                    if (!acc.flagDefault && cur.flagDefault) {
                      return cur;
                    }
                    if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {
                      return cur;
                    }
                    return acc;
                  }, null);
                  if (audioTrack) {
                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));
                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);
                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);
                  }
                  if (matroska.segment.tags) {
                    matroska.segment.tags.tag.forEach(function (tag) {
                      var target = tag.target;
                      var targetType = (target === null || target === void 0 ? void 0 : target.targetTypeValue) ? types_1.TargetType[target.targetTypeValue] : (target === null || target === void 0 ? void 0 : target.targetType) ? target.targetType : 'track';
                      tag.simpleTags.forEach(function (simpleTag) {
                        var value = simpleTag.string ? simpleTag.string : simpleTag.binary;
                        _this2.addTag("".concat(targetType, ":").concat(simpleTag.name), value);
                      });
                    });
                  }
                  if (matroska.segment.attachments) {
                    matroska.segment.attachments.attachedFiles.filter(function (file) {
                      return file.mimeType.startsWith('image/');
                    }).map(function (file) {
                      return {
                        data: file.data,
                        format: file.mimeType,
                        description: file.description,
                        name: file.name
                      };
                    }).forEach(function (picture) {
                      _this2.addTag('picture', picture);
                    });
                  }
                }
              }
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parse() {
        return _parse.apply(this, arguments);
      }
      return parse;
    }()
  }, {
    key: "parseContainer",
    value: function () {
      var _parseContainer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(container, posDone, path) {
        var tree, element, type, res;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              tree = {};
            case 1:
              if (!(this.tokenizer.position < posDone)) {
                _context3.next = 42;
                break;
              }
              element = void 0;
              _context3.prev = 3;
              _context3.next = 6;
              return this.readElement();
            case 6:
              element = _context3.sent;
              _context3.next = 14;
              break;
            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](3);
              if (!(_context3.t0.message === 'End-Of-Stream')) {
                _context3.next = 13;
                break;
              }
              return _context3.abrupt("break", 42);
            case 13:
              throw _context3.t0;
            case 14:
              type = container[element.id];
              if (!type) {
                _context3.next = 29;
                break;
              }
              debug("Element: name=".concat(type.name, ", container=").concat(!!type.container));
              if (!type.container) {
                _context3.next = 24;
                break;
              }
              _context3.next = 20;
              return this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));
            case 20:
              res = _context3.sent;
              if (type.multiple) {
                if (!tree[type.name]) {
                  tree[type.name] = [];
                }
                tree[type.name].push(res);
              } else {
                tree[type.name] = res;
              }
              _context3.next = 27;
              break;
            case 24:
              _context3.next = 26;
              return this.parserMap.get(type.value)(element);
            case 26:
              tree[type.name] = _context3.sent;
            case 27:
              _context3.next = 40;
              break;
            case 29:
              _context3.t1 = element.id;
              _context3.next = _context3.t1 === 0xec ? 32 : 36;
              break;
            case 32:
              // void
              this.padding += element.len;
              _context3.next = 35;
              return this.tokenizer.ignore(element.len);
            case 35:
              return _context3.abrupt("break", 40);
            case 36:
              debug("parseEbml: path=".concat(path.join('/'), ", unknown element: id=").concat(element.id.toString(16)));
              this.padding += element.len;
              _context3.next = 40;
              return this.tokenizer.ignore(element.len);
            case 40:
              _context3.next = 1;
              break;
            case 42:
              return _context3.abrupt("return", tree);
            case 43:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[3, 9]]);
      }));
      function parseContainer(_x2, _x3, _x4) {
        return _parseContainer.apply(this, arguments);
      }
      return parseContainer;
    }()
  }, {
    key: "readVintData",
    value: function () {
      var _readVintData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(maxLength) {
        var msb, mask, oc, id;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.tokenizer.peekNumber(token_types_1.UINT8);
            case 2:
              msb = _context4.sent;
              mask = 0x80;
              oc = 1; // Calculate VINT_WIDTH
            case 5:
              if (!((msb & mask) === 0)) {
                _context4.next = 12;
                break;
              }
              if (!(oc > maxLength)) {
                _context4.next = 8;
                break;
              }
              throw new Error('VINT value exceeding maximum size');
            case 8:
              ++oc;
              mask >>= 1;
              _context4.next = 5;
              break;
            case 12:
              id = Buffer.alloc(oc);
              _context4.next = 15;
              return this.tokenizer.readBuffer(id);
            case 15:
              return _context4.abrupt("return", id);
            case 16:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function readVintData(_x5) {
        return _readVintData.apply(this, arguments);
      }
      return readVintData;
    }()
  }, {
    key: "readElement",
    value: function () {
      var _readElement = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var id, lenField, nrLen;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.readVintData(this.ebmlMaxIDLength);
            case 2:
              id = _context5.sent;
              _context5.next = 5;
              return this.readVintData(this.ebmlMaxSizeLength);
            case 5:
              lenField = _context5.sent;
              lenField[0] ^= 0x80 >> lenField.length - 1;
              nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer
              return _context5.abrupt("return", {
                id: id.readUIntBE(0, id.length),
                len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
              });
            case 9:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function readElement() {
        return _readElement.apply(this, arguments);
      }
      return readElement;
    }()
  }, {
    key: "isMaxValue",
    value: function isMaxValue(vintData) {
      if (vintData.length === this.ebmlMaxSizeLength) {
        for (var n = 1; n < this.ebmlMaxSizeLength; ++n) {
          if (vintData[n] !== 0xff) return false;
        }
        return true;
      }
      return false;
    }
  }, {
    key: "readFloat",
    value: function () {
      var _readFloat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(e) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.t0 = e.len;
              _context6.next = _context6.t0 === 0 ? 3 : _context6.t0 === 4 ? 4 : _context6.t0 === 8 ? 5 : _context6.t0 === 10 ? 6 : 7;
              break;
            case 3:
              return _context6.abrupt("return", 0.0);
            case 4:
              return _context6.abrupt("return", this.tokenizer.readNumber(token_types_1.Float32_BE));
            case 5:
              return _context6.abrupt("return", this.tokenizer.readNumber(token_types_1.Float64_BE));
            case 6:
              return _context6.abrupt("return", this.tokenizer.readNumber(token_types_1.Float64_BE));
            case 7:
              throw new Error("Invalid IEEE-754 float length: ".concat(e.len));
            case 8:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function readFloat(_x6) {
        return _readFloat.apply(this, arguments);
      }
      return readFloat;
    }()
  }, {
    key: "readFlag",
    value: function () {
      var _readFlag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(e) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.readUint(e);
            case 2:
              _context7.t0 = _context7.sent;
              return _context7.abrupt("return", _context7.t0 === 1);
            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function readFlag(_x7) {
        return _readFlag.apply(this, arguments);
      }
      return readFlag;
    }()
  }, {
    key: "readUint",
    value: function () {
      var _readUint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(e) {
        var buf, nrLen;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.readBuffer(e);
            case 2:
              buf = _context8.sent;
              nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer
              return _context8.abrupt("return", buf.readUIntBE(e.len - nrLen, nrLen));
            case 5:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function readUint(_x8) {
        return _readUint.apply(this, arguments);
      }
      return readUint;
    }()
  }, {
    key: "readString",
    value: function () {
      var _readString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(e) {
        var rawString;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.tokenizer.readToken(new token_types_1.StringType(e.len, 'utf-8'));
            case 2:
              rawString = _context9.sent;
              return _context9.abrupt("return", rawString.replace(/\00.*$/g, ''));
            case 4:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function readString(_x9) {
        return _readString.apply(this, arguments);
      }
      return readString;
    }()
  }, {
    key: "readBuffer",
    value: function () {
      var _readBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(e) {
        var buf;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              buf = Buffer.alloc(e.len);
              _context10.next = 3;
              return this.tokenizer.readBuffer(buf);
            case 3:
              return _context10.abrupt("return", buf);
            case 4:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function readBuffer(_x10) {
        return _readBuffer.apply(this, arguments);
      }
      return readBuffer;
    }()
  }, {
    key: "addTag",
    value: function addTag(tagId, value) {
      this.metadata.addTag('matroska', tagId, value);
    }
  }]);
  return MatroskaParser;
}(BasicParser_1.BasicParser);
exports.MatroskaParser = MatroskaParser;
},{"token-types":"node_modules/token-types/lib/index.js","debug":"node_modules/debug/src/browser.js","../common/BasicParser":"node_modules/music-metadata/lib/common/BasicParser.js","./types":"node_modules/music-metadata/lib/matroska/types.js","./MatroskaDtd":"node_modules/music-metadata/lib/matroska/MatroskaDtd.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/ParserFactory.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParserFactory = exports.parseHttpContentType = void 0;
var FileType = require("file-type/core");
var ContentType = require("content-type");
var MimeType = require("media-typer");
var debug_1 = require("debug");
var MetadataCollector_1 = require("./common/MetadataCollector");
var AiffParser_1 = require("./aiff/AiffParser");
var APEv2Parser_1 = require("./apev2/APEv2Parser");
var AsfParser_1 = require("./asf/AsfParser");
var FlacParser_1 = require("./flac/FlacParser");
var MP4Parser_1 = require("./mp4/MP4Parser");
var MpegParser_1 = require("./mpeg/MpegParser");
var musepack_1 = require("./musepack");
var OggParser_1 = require("./ogg/OggParser");
var WaveParser_1 = require("./wav/WaveParser");
var WavPackParser_1 = require("./wavpack/WavPackParser");
var DsfParser_1 = require("./dsf/DsfParser");
var DsdiffParser_1 = require("./dsdiff/DsdiffParser");
var MatroskaParser_1 = require("./matroska/MatroskaParser");
var debug = (0, debug_1.default)('music-metadata:parser:factory');
function parseHttpContentType(contentType) {
  var type = ContentType.parse(contentType);
  var mime = MimeType.parse(type.type);
  return {
    type: mime.type,
    subtype: mime.subtype,
    suffix: mime.suffix,
    parameters: type.parameters
  };
}
exports.parseHttpContentType = parseHttpContentType;
function _parse2(_x, _x2) {
  return _parse.apply(this, arguments);
}
function _parse() {
  _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tokenizer, parserId) {
    var opts,
      parser,
      metadata,
      _args4 = arguments;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
          _context4.next = 3;
          return ParserFactory.loadParser(parserId);
        case 3:
          parser = _context4.sent;
          metadata = new MetadataCollector_1.MetadataCollector(opts);
          _context4.next = 7;
          return parser.init(metadata, tokenizer, opts).parse();
        case 7:
          return _context4.abrupt("return", metadata.toCommonMetadata());
        case 8:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _parse.apply(this, arguments);
}
var ParserFactory = /*#__PURE__*/function () {
  function ParserFactory() {
    _classCallCheck(this, ParserFactory);
  }
  _createClass(ParserFactory, null, [{
    key: "parseOnContentType",
    value:
    /**
     * Parse metadata from tokenizer
     * @param tokenizer - Tokenizer
     * @param opts - Options
     * @returns Native metadata
     */
    function () {
      var _parseOnContentType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenizer, opts) {
        var _yield$tokenizer$file, mimeType, path, url, parserId;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return tokenizer.fileInfo;
            case 2:
              _yield$tokenizer$file = _context.sent;
              mimeType = _yield$tokenizer$file.mimeType;
              path = _yield$tokenizer$file.path;
              url = _yield$tokenizer$file.url;
              // Resolve parser based on MIME-type or file extension
              parserId = ParserFactory.getParserIdForMimeType(mimeType) || ParserFactory.getParserIdForExtension(path) || ParserFactory.getParserIdForExtension(url);
              if (!parserId) {
                debug('No parser found for MIME-type / extension: ' + mimeType);
              }
              return _context.abrupt("return", this.parse(tokenizer, parserId, opts));
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function parseOnContentType(_x3, _x4) {
        return _parseOnContentType.apply(this, arguments);
      }
      return parseOnContentType;
    }()
  }, {
    key: "parse",
    value: function () {
      var _parse3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tokenizer, parserId, opts) {
        var buf, guessedType;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (parserId) {
                _context2.next = 16;
                break;
              }
              // Parser could not be determined on MIME-type or extension
              debug('Guess parser on content...');
              buf = Buffer.alloc(4100);
              _context2.next = 5;
              return tokenizer.peekBuffer(buf, {
                mayBeLess: true
              });
            case 5:
              if (tokenizer.fileInfo.path) {
                parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);
              }
              if (parserId) {
                _context2.next = 16;
                break;
              }
              _context2.next = 9;
              return FileType.fromBuffer(buf);
            case 9:
              guessedType = _context2.sent;
              if (guessedType) {
                _context2.next = 12;
                break;
              }
              throw new Error('Failed to determine audio format');
            case 12:
              debug("Guessed file type is mime=".concat(guessedType.mime, ", extension=").concat(guessedType.ext));
              parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);
              if (parserId) {
                _context2.next = 16;
                break;
              }
              throw new Error('Guessed MIME-type not supported: ' + guessedType.mime);
            case 16:
              return _context2.abrupt("return", _parse2(tokenizer, parserId, opts));
            case 17:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parse(_x5, _x6, _x7) {
        return _parse3.apply(this, arguments);
      }
      return parse;
    }()
    /**
     * @param filePath - Path, filename or extension to audio file
     * @return Parser sub-module name
     */
  }, {
    key: "getParserIdForExtension",
    value: function getParserIdForExtension(filePath) {
      if (!filePath) return;
      var extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;
      switch (extension) {
        case '.mp2':
        case '.mp3':
        case '.m2a':
        case '.aac':
          // Assume it is ADTS-container
          return 'mpeg';
        case '.ape':
          return 'apev2';
        case '.mp4':
        case '.m4a':
        case '.m4b':
        case '.m4pa':
        case '.m4v':
        case '.m4r':
        case '.3gp':
          return 'mp4';
        case '.wma':
        case '.wmv':
        case '.asf':
          return 'asf';
        case '.flac':
          return 'flac';
        case '.ogg':
        case '.ogv':
        case '.oga':
        case '.ogm':
        case '.ogx':
        case '.opus': // recommended filename extension for Ogg Opus
        case '.spx':
          // recommended filename extension for Ogg Speex
          return 'ogg';
        case '.aif':
        case '.aiff':
        case '.aifc':
          return 'aiff';
        case '.wav':
        case '.bwf':
          // Broadcast Wave Format
          return 'riff';
        case '.wv':
        case '.wvp':
          return 'wavpack';
        case '.mpc':
          return 'musepack';
        case '.dsf':
          return 'dsf';
        case '.dff':
          return 'dsdiff';
        case '.mka':
        case '.mkv':
        case '.mk3d':
        case '.mks':
        case '.webm':
          return 'matroska';
      }
    }
  }, {
    key: "loadParser",
    value: function () {
      var _loadParser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(moduleName) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.t0 = moduleName;
              _context3.next = _context3.t0 === 'aiff' ? 3 : _context3.t0 === 'adts' ? 4 : _context3.t0 === 'mpeg' ? 4 : _context3.t0 === 'apev2' ? 5 : _context3.t0 === 'asf' ? 6 : _context3.t0 === 'dsf' ? 7 : _context3.t0 === 'dsdiff' ? 8 : _context3.t0 === 'flac' ? 9 : _context3.t0 === 'mp4' ? 10 : _context3.t0 === 'musepack' ? 11 : _context3.t0 === 'ogg' ? 12 : _context3.t0 === 'riff' ? 13 : _context3.t0 === 'wavpack' ? 14 : _context3.t0 === 'matroska' ? 15 : 16;
              break;
            case 3:
              return _context3.abrupt("return", new AiffParser_1.AIFFParser());
            case 4:
              return _context3.abrupt("return", new MpegParser_1.MpegParser());
            case 5:
              return _context3.abrupt("return", new APEv2Parser_1.APEv2Parser());
            case 6:
              return _context3.abrupt("return", new AsfParser_1.AsfParser());
            case 7:
              return _context3.abrupt("return", new DsfParser_1.DsfParser());
            case 8:
              return _context3.abrupt("return", new DsdiffParser_1.DsdiffParser());
            case 9:
              return _context3.abrupt("return", new FlacParser_1.FlacParser());
            case 10:
              return _context3.abrupt("return", new MP4Parser_1.MP4Parser());
            case 11:
              return _context3.abrupt("return", new musepack_1.default());
            case 12:
              return _context3.abrupt("return", new OggParser_1.OggParser());
            case 13:
              return _context3.abrupt("return", new WaveParser_1.WaveParser());
            case 14:
              return _context3.abrupt("return", new WavPackParser_1.WavPackParser());
            case 15:
              return _context3.abrupt("return", new MatroskaParser_1.MatroskaParser());
            case 16:
              throw new Error("Unknown parser type: ".concat(moduleName));
            case 17:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function loadParser(_x8) {
        return _loadParser.apply(this, arguments);
      }
      return loadParser;
    }()
  }, {
    key: "getExtension",
    value: function getExtension(fname) {
      var i = fname.lastIndexOf('.');
      return i === -1 ? '' : fname.slice(i);
    }
    /**
     * @param httpContentType - HTTP Content-Type, extension, path or filename
     * @returns Parser sub-module name
     */
  }, {
    key: "getParserIdForMimeType",
    value: function getParserIdForMimeType(httpContentType) {
      var mime;
      try {
        mime = parseHttpContentType(httpContentType);
      } catch (err) {
        debug("Invalid HTTP Content-Type header value: ".concat(httpContentType));
        return;
      }
      var subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;
      switch (mime.type) {
        case 'audio':
          switch (subType) {
            case 'mp3': // Incorrect MIME-type, Chrome, in Web API File object
            case 'mpeg':
              return 'mpeg';
            case 'aac':
            case 'aacp':
              return 'adts';
            case 'flac':
              return 'flac';
            case 'ape':
            case 'monkeys-audio':
              return 'apev2';
            case 'mp4':
            case 'm4a':
              return 'mp4';
            case 'ogg': // RFC 7845
            case 'opus': // RFC 6716
            case 'speex':
              // RFC 5574
              return 'ogg';
            case 'ms-wma':
            case 'ms-wmv':
            case 'ms-asf':
              return 'asf';
            case 'aiff':
            case 'aif':
            case 'aifc':
              return 'aiff';
            case 'vnd.wave':
            case 'wav':
            case 'wave':
              return 'riff';
            case 'wavpack':
              return 'wavpack';
            case 'musepack':
              return 'musepack';
            case 'matroska':
            case 'webm':
              return 'matroska';
            case 'dsf':
              return 'dsf';
          }
          break;
        case 'video':
          switch (subType) {
            case 'ms-asf':
            case 'ms-wmv':
              return 'asf';
            case 'm4v':
            case 'mp4':
              return 'mp4';
            case 'ogg':
              return 'ogg';
            case 'matroska':
            case 'webm':
              return 'matroska';
          }
          break;
        case 'application':
          switch (subType) {
            case 'vnd.ms-asf':
              return 'asf';
            case 'ogg':
              return 'ogg';
          }
          break;
      }
    }
  }]);
  return ParserFactory;
}();
exports.ParserFactory = ParserFactory;
},{"file-type/core":"node_modules/file-type/core.js","content-type":"node_modules/content-type/index.js","media-typer":"node_modules/media-typer/index.js","debug":"node_modules/debug/src/browser.js","./common/MetadataCollector":"node_modules/music-metadata/lib/common/MetadataCollector.js","./aiff/AiffParser":"node_modules/music-metadata/lib/aiff/AiffParser.js","./apev2/APEv2Parser":"node_modules/music-metadata/lib/apev2/APEv2Parser.js","./asf/AsfParser":"node_modules/music-metadata/lib/asf/AsfParser.js","./flac/FlacParser":"node_modules/music-metadata/lib/flac/FlacParser.js","./mp4/MP4Parser":"node_modules/music-metadata/lib/mp4/MP4Parser.js","./mpeg/MpegParser":"node_modules/music-metadata/lib/mpeg/MpegParser.js","./musepack":"node_modules/music-metadata/lib/musepack/index.js","./ogg/OggParser":"node_modules/music-metadata/lib/ogg/OggParser.js","./wav/WaveParser":"node_modules/music-metadata/lib/wav/WaveParser.js","./wavpack/WavPackParser":"node_modules/music-metadata/lib/wavpack/WavPackParser.js","./dsf/DsfParser":"node_modules/music-metadata/lib/dsf/DsfParser.js","./dsdiff/DsdiffParser":"node_modules/music-metadata/lib/dsdiff/DsdiffParser.js","./matroska/MatroskaParser":"node_modules/music-metadata/lib/matroska/MatroskaParser.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RandomUint8ArrayReader = void 0;
/**
 * Provides abstract Uint8Array access via the IRandomRead interface
 */
var RandomUint8ArrayReader = /*#__PURE__*/function () {
  function RandomUint8ArrayReader(uint8Array) {
    _classCallCheck(this, RandomUint8ArrayReader);
    this.uint8Array = uint8Array;
    this.fileSize = uint8Array.length;
  }
  /**
   * Read from a given position of an abstracted file or buffer.
   * @param uint8Array - Uint8Array that the data will be written to.
   * @param offset - Offset in the buffer to start writing at.
   * @param length - Integer specifying the number of bytes to read.
   * @param position - Specifies where to begin reading from in the file.
   * @return Promise providing bytes read
   */
  _createClass(RandomUint8ArrayReader, [{
    key: "randomRead",
    value: function () {
      var _randomRead = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(uint8Array, offset, length, position) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              uint8Array.set(this.uint8Array.subarray(position, position + length), offset);
              return _context.abrupt("return", length);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function randomRead(_x, _x2, _x3, _x4) {
        return _randomRead.apply(this, arguments);
      }
      return randomRead;
    }()
  }]);
  return RandomUint8ArrayReader;
}();
exports.RandomUint8ArrayReader = RandomUint8ArrayReader;
},{}],"node_modules/music-metadata/lib/lyrics3/Lyrics3.js":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLyricsHeaderLength = exports.endTag2 = void 0;
exports.endTag2 = 'LYRICS200';
function getLyricsHeaderLength(_x) {
  return _getLyricsHeaderLength.apply(this, arguments);
}
function _getLyricsHeaderLength() {
  _getLyricsHeaderLength = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(reader) {
    var buf, txt, tag;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(reader.fileSize >= 143)) {
            _context.next = 8;
            break;
          }
          buf = Buffer.alloc(15);
          _context.next = 4;
          return reader.randomRead(buf, 0, buf.length, reader.fileSize - 143);
        case 4:
          txt = buf.toString('binary');
          tag = txt.substr(6);
          if (!(tag === exports.endTag2)) {
            _context.next = 8;
            break;
          }
          return _context.abrupt("return", parseInt(txt.substr(0, 6), 10) + 15);
        case 8:
          return _context.abrupt("return", 0);
        case 9:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getLyricsHeaderLength.apply(this, arguments);
}
exports.getLyricsHeaderLength = getLyricsHeaderLength;
},{"buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/music-metadata/lib/core.js":[function(require,module,exports) {
var define;
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;
var strtok3 = require("strtok3/lib/core");
var ParserFactory_1 = require("./ParserFactory");
var RandomUint8ArrayReader_1 = require("./common/RandomUint8ArrayReader");
var APEv2Parser_1 = require("./apev2/APEv2Parser");
var ID3v1Parser_1 = require("./id3v1/ID3v1Parser");
var Lyrics3_1 = require("./lyrics3/Lyrics3");
/**
 * Parse audio from Node Stream.Readable
 * @param stream - Stream to read the audio track from
 * @param options - Parsing options
 * @param fileInfo - File information object or MIME-type string
 * @returns Metadata
 */
function parseStream(stream, fileInfo) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? {
    mimeType: fileInfo
  } : fileInfo), options);
}
exports.parseStream = parseStream;
/**
 * Parse audio from Node Buffer
 * @param uint8Array - Uint8Array holding audio data
 * @param fileInfo - File information object or MIME-type string
 * @param options - Parsing options
 * @returns Metadata
 * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15
 */
function parseBuffer(_x, _x2) {
  return _parseBuffer.apply(this, arguments);
}
function _parseBuffer() {
  _parseBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(uint8Array, fileInfo) {
    var options,
      bufferReader,
      tokenizer,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
          bufferReader = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(uint8Array);
          _context.next = 4;
          return scanAppendingHeaders(bufferReader, options);
        case 4:
          tokenizer = strtok3.fromBuffer(uint8Array, typeof fileInfo === 'string' ? {
            mimeType: fileInfo
          } : fileInfo);
          return _context.abrupt("return", parseFromTokenizer(tokenizer, options));
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _parseBuffer.apply(this, arguments);
}
exports.parseBuffer = parseBuffer;
/**
 * Parse audio from ITokenizer source
 * @param tokenizer - Audio source implementing the tokenizer interface
 * @param options - Parsing options
 * @returns Metadata
 */
function parseFromTokenizer(tokenizer, options) {
  return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);
}
exports.parseFromTokenizer = parseFromTokenizer;
/**
 * Create a dictionary ordered by their tag id (key)
 * @param nativeTags list of tags
 * @returns tags indexed by id
 */
function orderTags(nativeTags) {
  var tags = {};
  var _iterator = _createForOfIteratorHelper(nativeTags),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var tag = _step.value;
      (tags[tag.id] = tags[tag.id] || []).push(tag.value);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return tags;
}
exports.orderTags = orderTags;
/**
 * Convert rating to 1-5 star rating
 * @param rating: Normalized rating [0..1] (common.rating[n].rating)
 * @returns Number of stars: 1, 2, 3, 4 or 5 stars
 */
function ratingToStars(rating) {
  return rating === undefined ? 0 : 1 + Math.round(rating * 4);
}
exports.ratingToStars = ratingToStars;
/**
 * Select most likely cover image.
 * @param pictures Usually metadata.common.picture
 * @return Cover image, if any, otherwise null
 */
function selectCover(pictures) {
  return pictures ? pictures.reduce(function (acc, cur) {
    if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)']) return cur;
    return acc;
  }) : null;
}
exports.selectCover = selectCover;
function scanAppendingHeaders(_x3) {
  return _scanAppendingHeaders.apply(this, arguments);
}
function _scanAppendingHeaders() {
  _scanAppendingHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(randomReader) {
    var options,
      apeOffset,
      lyricsLen,
      _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
          apeOffset = randomReader.fileSize;
          _context2.next = 4;
          return (0, ID3v1Parser_1.hasID3v1Header)(randomReader);
        case 4:
          if (!_context2.sent) {
            _context2.next = 10;
            break;
          }
          apeOffset -= 128;
          _context2.next = 8;
          return (0, Lyrics3_1.getLyricsHeaderLength)(randomReader);
        case 8:
          lyricsLen = _context2.sent;
          apeOffset -= lyricsLen;
        case 10:
          _context2.next = 12;
          return APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);
        case 12:
          options.apeHeader = _context2.sent;
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _scanAppendingHeaders.apply(this, arguments);
}
exports.scanAppendingHeaders = scanAppendingHeaders;
},{"strtok3/lib/core":"node_modules/strtok3/lib/core.js","./ParserFactory":"node_modules/music-metadata/lib/ParserFactory.js","./common/RandomUint8ArrayReader":"node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js","./apev2/APEv2Parser":"node_modules/music-metadata/lib/apev2/APEv2Parser.js","./id3v1/ID3v1Parser":"node_modules/music-metadata/lib/id3v1/ID3v1Parser.js","./lyrics3/Lyrics3":"node_modules/music-metadata/lib/lyrics3/Lyrics3.js"}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;
  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== undefined) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
},{}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js":[function(require,module,exports) {
module.exports = require('events').EventEmitter;
},{"events":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/events/events.js"}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js":[function(require,module,exports) {

'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();
},{"buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js","util":"../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/destroy.js":[function(require,module,exports) {
var process = require("process");
'use strict';

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
},{"process":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js":[function(require,module,exports) {
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);
    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError;
  }(Base);
  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;
},{}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/state.js":[function(require,module,exports) {
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js"}],"node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"node_modules/util-deprecate/browser.js":[function(require,module,exports) {
var global = arguments[3];

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

},{}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_writable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
},{"util-deprecate":"node_modules/util-deprecate/browser.js","./internal/streams/stream":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js","./internal/streams/destroy":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/state.js","../errors":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_duplex":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_duplex.js","process":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_duplex.js":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
},{"./_stream_readable":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_readable.js","./_stream_writable":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_writable.js","inherits":"node_modules/inherits/inherits_browser.js","process":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/safe-buffer/index.js":[function(require,module,exports) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/string_decoder/lib/string_decoder.js":[function(require,module,exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"node_modules/safe-buffer/index.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;
},{"../../../errors":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js":[function(require,module,exports) {
var process = require("process");
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;
},{"./end-of-stream":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","process":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js":[function(require,module,exports) {
module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};
},{}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_readable.js":[function(require,module,exports) {

var global = arguments[3];
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},{"events":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/events/events.js","./internal/streams/stream":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js","buffer":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js","util":"../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/_empty.js","./internal/streams/buffer_list":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js","./internal/streams/destroy":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","./internal/streams/state":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/state.js","../errors":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js","inherits":"node_modules/inherits/inherits_browser.js","./_stream_duplex":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_duplex.js","string_decoder/":"node_modules/string_decoder/lib/string_decoder.js","./internal/streams/async_iterator":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js","./internal/streams/from":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js","process":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_transform.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js","./_stream_duplex":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_duplex.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_passthrough.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_transform.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;
},{"../../../errors":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/errors-browser.js","./end-of-stream":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"}],"node_modules/readable-web-to-node-stream/node_modules/readable-stream/readable-browser.js":[function(require,module,exports) {
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');
},{"./lib/_stream_readable.js":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_readable.js","./lib/_stream_writable.js":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_writable.js","./lib/_stream_duplex.js":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_duplex.js","./lib/_stream_transform.js":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_transform.js","./lib/_stream_passthrough.js":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/_stream_passthrough.js","./lib/internal/streams/end-of-stream.js":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","./lib/internal/streams/pipeline.js":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"}],"node_modules/readable-web-to-node-stream/lib/index.js":[function(require,module,exports) {
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReadableWebToNodeStream = void 0;
var readable_stream_1 = require("readable-stream");
/**
 * Converts a Web-API stream into Node stream.Readable class
 * Node stream readable: https://nodejs.org/api/stream.html#stream_readable_streams
 * Web API readable-stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
 * Node readable stream: https://nodejs.org/api/stream.html#stream_readable_streams
 */
var ReadableWebToNodeStream = /*#__PURE__*/function (_readable_stream_1$Re) {
  _inherits(ReadableWebToNodeStream, _readable_stream_1$Re);
  var _super = _createSuper(ReadableWebToNodeStream);
  /**
   *
   * @param stream Readable​Stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
   */
  function ReadableWebToNodeStream(stream) {
    var _this;
    _classCallCheck(this, ReadableWebToNodeStream);
    _this = _super.call(this);
    _this.bytesRead = 0;
    _this.released = false;
    _this.reader = stream.getReader();
    return _this;
  }
  /**
   * Implementation of readable._read(size).
   * When readable._read() is called, if data is available from the resource,
   * the implementation should begin pushing that data into the read queue
   * https://nodejs.org/api/stream.html#stream_readable_read_size_1
   */
  _createClass(ReadableWebToNodeStream, [{
    key: "_read",
    value: function () {
      var _read2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var data;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.released) {
                _context.next = 3;
                break;
              }
              this.push(null); // Signal EOF
              return _context.abrupt("return");
            case 3:
              this.pendingRead = this.reader.read();
              _context.next = 6;
              return this.pendingRead;
            case 6:
              data = _context.sent;
              // clear the promise before pushing pushing new data to the queue and allow sequential calls to _read()
              delete this.pendingRead;
              if (data.done || this.released) {
                this.push(null); // Signal EOF
              } else {
                this.bytesRead += data.value.length;
                this.push(data.value); // Push new data to the queue
              }
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _read() {
        return _read2.apply(this, arguments);
      }
      return _read;
    }()
    /**
     * If there is no unresolved read call to Web-API Readable​Stream immediately returns;
     * otherwise will wait until the read is resolved.
     */
  }, {
    key: "waitForReadToComplete",
    value: function () {
      var _waitForReadToComplete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.pendingRead) {
                _context2.next = 3;
                break;
              }
              _context2.next = 3;
              return this.pendingRead;
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function waitForReadToComplete() {
        return _waitForReadToComplete.apply(this, arguments);
      }
      return waitForReadToComplete;
    }()
    /**
     * Close wrapper
     */
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.syncAndRelease();
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function close() {
        return _close.apply(this, arguments);
      }
      return close;
    }()
  }, {
    key: "syncAndRelease",
    value: function () {
      var _syncAndRelease = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              this.released = true;
              _context4.next = 3;
              return this.waitForReadToComplete();
            case 3:
              _context4.next = 5;
              return this.reader.releaseLock();
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function syncAndRelease() {
        return _syncAndRelease.apply(this, arguments);
      }
      return syncAndRelease;
    }()
  }]);
  return ReadableWebToNodeStream;
}(readable_stream_1.Readable);
exports.ReadableWebToNodeStream = ReadableWebToNodeStream;
},{"readable-stream":"node_modules/readable-web-to-node-stream/node_modules/readable-stream/readable-browser.js"}],"node_modules/music-metadata-browser/lib/index.js":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;
const initDebug = require("debug");
const mm = require("music-metadata/lib/core");
const readable_web_to_node_stream_1 = require("readable-web-to-node-stream");
const debug = initDebug('music-metadata-browser:main');
var core_1 = require("music-metadata/lib/core");
Object.defineProperty(exports, "parseBuffer", { enumerable: true, get: function () { return core_1.parseBuffer; } });
Object.defineProperty(exports, "parseFromTokenizer", { enumerable: true, get: function () { return core_1.parseFromTokenizer; } });
Object.defineProperty(exports, "orderTags", { enumerable: true, get: function () { return core_1.orderTags; } });
Object.defineProperty(exports, "ratingToStars", { enumerable: true, get: function () { return core_1.ratingToStars; } });
Object.defineProperty(exports, "selectCover", { enumerable: true, get: function () { return core_1.selectCover; } });
/**
 * Parse audio Stream
 * @param stream - ReadableStream
 * @param contentType - MIME-Type
 * @param options - Parsing options
 * @returns Metadata
 */
exports.parseNodeStream = mm.parseStream;
/**
 * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream
 * @param stream - ReadableStream (web stream according WTWG Streams Standard)
 * @param fileInfo FileInfo object or MIME-Type
 * @param options - Parsing options
 * @returns Metadata
 */
async function parseReadableStream(stream, fileInfo, options) {
    const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);
    const res = await (0, exports.parseNodeStream)(ns, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo, options);
    await ns.close();
    return res;
}
exports.parseReadableStream = parseReadableStream;
/**
 * Parse Web API File
 * @param blob - Blob to parse
 * @param options - Parsing options
 * @returns Metadata
 */
async function parseBlob(blob, options) {
    const fileInfo = { mimeType: blob.type, size: blob.size };
    if (blob instanceof File) {
        fileInfo.path = blob.name;
    }
    const stream = (blob.stream ? blob.stream() : convertBlobToReadableStream(blob));
    return parseReadableStream(stream, { mimeType: blob.type, size: blob.size }, options);
}
exports.parseBlob = parseBlob;
/**
 * Convert Blob to ReadableStream
 * Fallback for Safari versions < 14.1
 * @param blob
 */
function convertBlobToReadableStream(blob) {
    const fileReader = new FileReader();
    return new ReadableStream({
        start(controller) {
            // The following function handles each data chunk
            fileReader.onloadend = event => {
                let data = event.target.result;
                if (data instanceof ArrayBuffer) {
                    data = new Uint8Array(data);
                }
                controller.enqueue(data);
                controller.close();
            };
            fileReader.onerror = error => {
                controller.close();
            };
            fileReader.onabort = error => {
                controller.close();
            };
            fileReader.readAsArrayBuffer(blob);
        }
    });
}
/**
 * Parse fetched file, using the Web Fetch API
 * @param audioTrackUrl - URL to download the audio track from
 * @param options - Parsing options
 * @returns Metadata
 */
async function fetchFromUrl(audioTrackUrl, options) {
    const response = await fetch(audioTrackUrl);
    const fileInfo = {
        size: parseInt(response.headers.get('Content-Length'), 10),
        mimeType: response.headers.get('Content-Type')
    };
    if (response.ok) {
        if (response.body) {
            const res = await parseReadableStream(response.body, fileInfo, options);
            debug('Closing HTTP-readable-stream...');
            if (!response.body.locked) { // Prevent error in Firefox
                await response.body.cancel();
            }
            debug('HTTP-readable-stream closed.');
            return res;
        }
        else {
            // Fall back on Blob
            return parseBlob(await response.blob(), options);
        }
    }
    else {
        throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);
    }
}
exports.fetchFromUrl = fetchFromUrl;

},{"debug":"node_modules/debug/src/browser.js","music-metadata/lib/core":"node_modules/music-metadata/lib/core.js","readable-web-to-node-stream":"node_modules/readable-web-to-node-stream/lib/index.js"}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/os-browserify/browser.js":[function(require,module,exports) {
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],"node_modules/lrc-parser/index.js":[function(require,module,exports) {
const EOL = typeof window === 'undefined' ? require('os').EOL : '\n'

/**
 * 
 * @param {string} data 
 * @example [length: 03:36]
 * @return {<Array>{string}} ['length', '03:06']
 */

function extractInfo(data) {
  const info = data.trim().slice(1, -1) // remove brackets: length: 03:06
  return info.split(': ')
}

function lrcParser(data) {
  if (typeof data !== 'string') {
    throw new TypeError('expect first argument to be a string')
  }
  // split a long stirng into lines by system's end-of-line marker line \r\n on Windows
  // or \n on POSIX
  let lines = data.split(EOL)
  const timeStart = /\[(\d*\:\d*\.?\d*)\]/ // i.g [00:10.55]
  const scriptText = /(.+)/ // Havana ooh na-na (ayy) 
  const timeEnd = timeStart
  const startAndText = new RegExp(timeStart.source + scriptText.source)


  const infos = []
  const scripts = []
  const result = {}

  for(let i = 0; startAndText.test(lines[i]) === false; i++) {
    infos.push(lines[i])
  }

  infos.reduce((result, info) => {
    const [key, value] = extractInfo(info)
    result[key] = value
    return result
  }, result)

  lines.splice(0, infos.length) // remove all info lines
  const qualified = new RegExp(startAndText.source + '|' + timeEnd.source)
  lines = lines.filter(line => qualified.test(line))
  
  for (let i = 0, l = lines.length; i < l; i++) {
    const matches = startAndText.exec(lines[i])
    const timeEndMatches = timeEnd.exec(lines[i + 1])  
    if (matches && timeEndMatches) {
      const [, start, text] = matches
      const [, end] = timeEndMatches
      scripts.push({
        start: convertTime(start),
        text,
        end: convertTime(end),
      })
    }
  }

  result.scripts = scripts
  return result
}

// convert time string to seconds
// i.g: [01:09.10] -> 69.10
function convertTime(string) {
  string = string.split(':');
  const minutes = parseInt(string[0], 10)
  const seconds = parseFloat(string[1])
  if (minutes > 0) {
    const sc = minutes * 60 + seconds
    return parseFloat(sc.toFixed(2))
  }
  return seconds
}

module.exports = lrcParser

},{"os":"../../AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/os-browserify/browser.js"}],"main.js":[function(require,module,exports) {
"use strict";

var mm = _interopRequireWildcard(require("music-metadata-browser"));
var _lrcParser = require("lrc-parser");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var fileInput = document.getElementById('file');
var player = document.getElementById('player');
var cover = document.getElementById('cover');
var lyricsDiv = document.getElementById('lyrics');
var lyrics;
fileInput.addEventListener('change', /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(e) {
    var file, metadata, _metadata$common, picture, lyricsText, artist, title, _picture$, data, format, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          file = e.target.files[0];
          if (file) {
            _context.next = 3;
            break;
          }
          return _context.abrupt("return");
        case 3:
          _context.next = 5;
          return mm.parseBlob(file);
        case 5:
          metadata = _context.sent;
          _metadata$common = metadata.common, picture = _metadata$common.picture, lyricsText = _metadata$common.lyrics, artist = _metadata$common.artist, title = _metadata$common.title; // Display cover
          if (picture && picture[0]) {
            _picture$ = picture[0], data = _picture$.data, format = _picture$.format;
            url = URL.createObjectURL(new Blob([data], {
              type: "image/".concat(format)
            }));
            cover.src = url;
          }

          // Display artist and title
          document.getElementById('artist').textContent = artist;
          document.getElementById('title').textContent = title;

          // Parse and display lyrics
          if (lyricsText && lyricsText[0]) {
            console.log(lyricsText[0].text); // Check if lyrics text is correctly extracted
            lyrics = (0, _lrcParser.parse)(lyricsText[0].text);
            console.log(lyrics); // Check if lyrics are correctly parsed
            lyricsDiv.innerHTML = lyrics.lines.map(function (line) {
              return "<p id=\"line-".concat(line.id, "\">").concat(line.text, "</p>");
            }).join('');
          }
          console.log(lyricsDiv.textContent); // Check if lyrics are correctly displayed

          // Play music
          player.src = URL.createObjectURL(file);
          player.play();
        case 14:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function (_x) {
    return _ref.apply(this, arguments);
  };
}());
player.addEventListener('timeupdate', function () {
  if (!lyrics) return;
  var line = lyrics.lines.find(function (line) {
    return line.time > player.currentTime * 1000;
  });
  if (line) {
    var lineElement = document.getElementById("line-".concat(line.id));
    if (lineElement) lineElement.scrollIntoView({
      behavior: 'smooth'
    });
  }
});
},{"music-metadata-browser":"node_modules/music-metadata-browser/lib/index.js","lrc-parser":"node_modules/lrc-parser/index.js"}],"../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "8550" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","main.js"], null)
//# sourceMappingURL=/main.js.map